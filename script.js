(function () {
    window.isDev = true;
    Math.randInt = function (min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    };
    var slotData = [{
        unlocked: true,
        used: true,
        cost: 0
    }, {
        unlocked: false,
        used: false,
        cost: 50
    }, {
        unlocked: false,
        used: false,
        cost: 200
    }, {
        unlocked: false,
        used: false,
        cost: 1e3
    }, {
        unlocked: false,
        used: false,
        cost: 1e3
    }, {
        unlocked: false,
        used: false,
        cost: 2e3
    }, {
        unlocked: false,
        used: false,
        cost: 2e3
    }, {
        unlocked: false,
        used: false,
        cost: 3e3
    }, {
        unlocked: true,
        used: false,
        cost: Infinity
    }];
    var updateLogger = (new class {
        constructor() {
            this.html = "";
        }
        grabHTML() {
            return `<div style="margin-left: 10px;">${this.html}</div>`;
        }
        lineBlock(content) {
            let text = "";
            content.forEach(e => {
                text += "- " + e + "<br>";
            });
            return text;
        }
        marginBlock(margin, content) {
            return `<div style="margin-left: ${margin}px;">${content}</div>`;
        }
        title(tag, content) {
            return `<${tag}>${content}</${tag}>`
        }
        newLog(header, content) {
            this.html = `
            <h1>${header}</h1>
            ${content}
            <hr style="margin-left: -10px;">
            ` + this.html;
        }
    }());
    updateLogger.newLog("V45 UPDATE NOTES", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New shape(s): Magenta Circle, and Gray Pentagon", "New weapon(s): Smuta and Razor", "New Workshop 2.0", "Massive Rebalances", "Bug Fixes"])}
            ${updateLogger.title("h2", `NEW SHAPE(S): Magenta Circle and Gray Pentagon`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Magenta Circle:`)}
                Magenta Circle, the celestial sentinel, epitomizes the pinnacle of airborne defense. Cloaked in an impervious purple absorber shield, this soaring entity defies conventional weaponry, rendering itself nearly invulnerable. Engaged in its ethereal flight, the Magenta Circle unleashes a symphony of four integrated weapons. As these formidable arms pummel adversaries, a resonating blast effect emanates, growing in intensity with each absorbed blow to the unyielding shield. This aerial juggernaut stands as a testament to unparalleled defense and strategic prowess in the face of opposition.
                ${updateLogger.title("h3", `Gray Pentagon:`)}
                The Gray Pentagon stands as a versatile assailant and robust tank on the battlefield. Enveloped by formidable physical shields, it remains impervious to even the most intense firepower, emerging unscathed. Its unique ability allows it to regenerate these protective barriers on demand, providing unparalleled durability. Additionally, the Gray Pentagon boasts exceptional mobility, covering extensive distances with efficiency. This amalgamation of offensive prowess, resilience, and maneuverability positions it as a formidable force, adept at confronting diverse challenges with unwavering strength.
            `)}
            ${updateLogger.title("h2", `NEW WEAPONS(S): Smuta and Razor`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Smuta and Razor:`)}
                Smuta, the heavy weapon, and Razor, the light weapon, are sophisticated homing machineguns. Once their projectiles cover a certain distance, they automatically lock onto the closest enemies, tracking them with precision. This homing capability adds a strategic edge to their firepower, ensuring that targets are pursued and engaged effectively, making Smuta and Razor formidable choices for combat situations.
            `)}
            ${updateLogger.title("h2", `WORKSHOP 2.0`)}
            ${updateLogger.marginBlock(10, `
                The revamped workshop feature introduces a more efficient game balancing system while facilitating the streamlined acquisition of items. This overhaul enhances the overall gaming experience by offering a smoother and more accessible avenue for obtaining essential items. The reworked workshop not only promotes better balance within the game but also ensures that players can readily access and incorporate valuable items, contributing to a more enjoyable and engaging gameplay.
            `)}
            ${updateLogger.title("h2", `NEW MICROCHIP(S): DESTROYER, POISON EXPERT, EXPLOSIVE EXPERTISE`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Destroyer:`)}
                Increases the shape's ability damage.
                ${updateLogger.title("h3", `Poison Expert:`)}
                Legendary Chip that increases the speed emiting DOT effects.
                ${updateLogger.title("h3", `Poison Expert:`)}
                Legendary Chip that increases the Overload ability damage.
            `)}
            ${updateLogger.title("h2", `OTHER IMPROVEMENTS`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Fixed many incorrect descriptions", "Performance Improvements", "Changed some lootbox rewards", "Changed reward formulas", "Bug Fixes and other improvements"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V46 UPDATE NOTES", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New shape(s): Red Orange Circle, Dark Blue Circle, Gray Heptagon, and Brown Pentagon", "More microchips", "New weapon(s): Taran", "Visual Improvements and Changes", "Multiple content unlocked", "Reworked channel log (see old updates here: <a href='./oldchannellog.html'>here</a>)", "Bug Fixes"])}
            ${updateLogger.title("h2", `NEW SHAPE(S): Red Orange Circle, Dark Blue Circle, Gray Heptagon, and Brown Pentagon`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Red Orange Circle:`)}
                Fortified with an formidable defense mechanism, the Red Orange Circle exhibits a unique defensive prowess. When its extraordinary ability is activated, adversaries are deterred from unleashing their firepower, as a significant portion of the damage is not only absorbed but also skillfully redirected back towards the assailant. This distinctive shape becomes a formidable deterrent, discouraging foes from engaging in direct confrontation and turning their own aggression against them.
                ${updateLogger.title("h3", `Dark Blue Circle:`)}
                Simple shape used for early leagues to get the just of sniping gameplay.
                ${updateLogger.title("h3", `Gray Heptagon:`)}
                Heptagon Industries proudly introduces its groundbreaking shape, a revolutionary flying entity designed to redefine aerial capabilities. Harnessing the extraordinary mechanics of shapeshifting, the shape boasts limitless flight endurance. Complemented by an integrated weaponry system adept at penetrating defense points, this marvel not only soars through the skies with grace but also delivers a formidable punch to any adversaries in its path.
                ${updateLogger.title("h3", `Brown Pentagon:`)}
                The next generation of shape technology, the Pentagon Industry (PI) developed ways to let shapes use their ability for as long as players want. Brown Pentagon, equipped with the Industry's signature feature, energy shield, and the ability to enter endless tank mode. It can enter and exit fights without a scratch!
            `)}
            ${updateLogger.title("h2", `NEW WEAPONS(S): Taran`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Taran:`)}
                A semi-automatic fireball weapon. It shoots with a high rate of fire. With its large ammo pool, it can deal a lot of damage over long encounters.
            `)}
            ${updateLogger.title("h2", `OTHER IMPROVEMENTS`)}
            ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["Nuclear Amp and many other items are purchasable", 'Items will have their "industry" shown in their description', "Buffed Veyron and Evora", "Adjusted some stats for shapes and weapons", "Improved effect (ingame) visuals"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V47 UPDATE NOTES", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Shape(s): Cyan Hexagon", "New Module(s): Immune Amplifier", "New Weapon(s): Redeemer, Cestus, and Labrys", "Lootbox Rewards Reworked", "Balance Changes", "New Module: Active Modules!", "Bug Fixes"])}
            ${updateLogger.title("h2", `NEW SHAPES(S): Cyan Hexagon`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Cyan Hexagon:`)}
                [Hexagon Industry]'s proudest innovation, proudly positioned at tier 5, transcends the technological achievements of the [Circle Industry] counterpart by pushing the boundaries of capability even further. The Cyan Hexagon introduces a groundbreaking feature: the ability to teleport additional armor and turrets, multiple times, enhancing its resilience in combat. This cutting-edge advancement not only builds upon the proven technology of the Circle Industry but propels Hexagon Industry to new heights in terms of durability and strategic adaptability on the battlefield.
            `)}
            ${updateLogger.title("h2", `NEW WEAPON(S): Redeemer, Cestus, and Labrys`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Redeemer:`)}
                Heavy variant of Taran.
                ${updateLogger.title("h3", `Cestus and Labrys:`)}
                Semi-auto fireball weapons that emit blast effect and has defense bypass.
            `)}
            ${updateLogger.title("h2", `NEW FEATURE: ACTIVE MODULE`)}
            ${updateLogger.marginBlock(10, `
                Accessible to all players, active modules stand as open resources for seamless integration. Each shape provides space for only one active module slot, emphasizing a strategic and singular choice. Once a module is equipped, its presence becomes irrevocable. However, the utilization of the module's unique abilities necessitates the investment of workshop points, adding an element of resource management to the dynamic gameplay experience.
                <br><br>
                CURRENT ACTIVE MODULE(S):<br>
                ${updateLogger.lineBlock([
        "<strong>Repair Unit</strong>: Repairs X% durability over X seconds. 200 WKSP Cost",
        "<strong>Advanced Repair Unit</strong>: Repairs X% durability over X seconds. 400 WKSP Cost",
        "<strong>Phase Shift</strong>: Activates a phase shift for 3 seconds. 800 WKSP Cost",
        "<strong>Unstable Conduit</strong>: Find out ability at in-game description. 1600 WKSP Cost"
    ])}
            `)}
            ${updateLogger.title("h2", `BALANCE CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Gold Circle: +50% DOT Dmg", "Self Fix Unit: +20% Healing Power", "Taran: -30% Damage", "Gray Pentagon: Shield Durability: -20%", "Gray Pentagon: Removed Gray Damage Fix On Kill"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V48 UPDATE NOTES", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Feature: Drones", "Visual Improvements", "Added Player Profiles", "Balance Changes", "Bug Fixes"])}
            ${updateLogger.title("h2", `DRONES`)}
            ${updateLogger.marginBlock(10, `
                Discover a groundbreaking approach to personalize your shapes like never before! Harness the versatility of drones to not only customize but also infuse a new level of excitement and innovation into your designs. Elevate your creations with the added dimension and dynamic flair that drones bring to the table, making your shapes truly one-of-a-kind. Shape your imagination into reality, now with the thrilling bonus of drone-powered enhancements!
            `)}
            ${updateLogger.title("h2", `VISUAL IMPROVEMENTS/CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["In Game UI Changes/Improvements", "Hanger UI Improvements", "Kill Logger Changes", "Beacon Progress UI Changes", "Reworked End Game Battle Stats UI", "Shape Customization UI Fixes + Changes"])}
                Note: some changes may not be 100% finished.
            `)}
            ${updateLogger.title("h2", `BALANCE CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Increased the defense mitigation of all tier 5 weapons.", "Damage Controller: Gray Damage Decrease: 15% -> 21%", "Tan Circle: Immune to gray damage from all dot", "Delay and Slumber: Effect Duration: 2 -> 5 seconds", "Pinkish Red Circle: Ability Cooldown: 8 -> 3 seconds", "Gray Pentagon: +25% Shield Durability", "Gray Pentagon: Max Health Restored by Popping Shields: 40% -> 20%", "Orange Circle: -20% Health", "Gray Pentagon: changes on [onDamageFix]", "Ultimate Green Circle: changes on [onDamageP-Shield]", "Shatter and Brisant: Ammo: 8 -> 6, Fire Rate: 450 -> 550", "Evora and Veyron: Ammo: 130 -> 125, Fire Rate: 40 -> 50 (ms)"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V49 UPDATE NOTES", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Feature: Critical Hit", "Reworked Maps", "Increased amount of player xp you earn per battle", "New Shape(s): Cyan Heptagon", "Visual Improvements", "New Drone(s): Pascal and Beak", "New Microchip(s): Blink Supporter", "Bug Fixes"])}
            ${updateLogger.title("h2", `NEW SHAPE(S): CYAN HEPTAGON`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Cyan Heptagon:`)}
                Heptagon Industries continues to push the boundaries with its latest breakthrough: its 2nd T5 marvel. This innovative shape boasts unparalleled radar-evading capabilities, surpassing all others in its class. The engineering marvel behind this design ensures seamless removal from enemy radar, showcasing Heptagon Industries' commitment to cutting-edge technology and staying ahead in the ever-evolving landscape of defense and security.
            `)}
            ${updateLogger.title("h2", `NEW DRONE(S): PASCAL AND BEAK`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Beak`)}
                In the face of overwhelming firepower, safeguard your shape with the "Beak" drone! This cutting-edge addition to your arsenal is engineered to provide a crucial advantage when the going gets tough. Activate the "Beak" drone, and watch as it conceals you from enemy radars, granting you a strategic escape when under intense assault. When the pressure is on and damage mounts, trust the "Beak" to navigate you through the shadows, leaving adversaries bewildered and searching in vain. Stay one step ahead with Heptagon Industries' "Beak" - your ticket to survival in the heart of chaos.
            `)}
            ${updateLogger.title("h2", `NEW MICROCHIP(S): BLINK SUPPORTER`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Blink Supporter (Cyan Hexagon)`)}
                Elevate your turret experience to new heights! Introducing the "Blink Supporter" microchip - the ultimate game-changer for maximizing damage and durability of the turrets. Have a blast fine-tuning your turrets with this groundbreaking enhancement. Watch as they not only unleash even more devastating firepower but also exhibit increased resilience, ensuring they stand strong in the heat of battle. Say goodbye to ordinary, and embrace the extraordinary with Hexagon Industries' "Blink Supporter" - where fun meets firepower!
            `)}
            ${updateLogger.title("h2", `CRITICAL HITS`)}
            ${updateLogger.marginBlock(10, `
                When a shape is at low durability, there's a chance that it'll take a critical hit.<br>
                On top of taking normal damage, it can:<br>
                ${updateLogger.lineBlock(["Blow off a shape's weapon permanently"])}<br>
                Things that cannot do a critical hit:<br>
                ${updateLogger.lineBlock(["DoT Damage", "Reflector"])}
            `)}
            ${updateLogger.title("h2", `VISUALS`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Fixed incorrect visuals/displays"])}
            `)}
            ${updateLogger.title("h2", `NEW MAPS`)}
            ${updateLogger.marginBlock(10, `
            ${updateLogger.title("h3", `Space Shuttle`)}
            space_shuttle/desc
            `)}
            ${updateLogger.title("h2", `BUG FIXES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Reflector reflecting damage from DoT", "Fixed certain microchips not working as intended", "Fixed Module and Weapons upgrading problems", "Fixed UI Problems", "Fixed some drone abilities", "Fixed incorrect rendering"])}
            `)}
            ${updateLogger.title("h2", `OTHER IMPROVEMENTS/CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Task feature disabled, a new improved version will come next update.", "Fixed description of Damper and Deceiver", "Pumpkin Orange Circle, Ultimate Green Circle, and Ultimate Tan Pentagon: No longer obtainable", "You can now view the descriptions of drones and their abilities.", "MK3 enhancement cost reduced by 50%"])}
            `)}
            ${updateLogger.title("h2", `BALANCE CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Orange Circle DoT Duration: 20 -> 7 seconds", "Tan Circle DoT Duration: 20 -> 7 seconds", "Pink Circle DoT Duration: 7 -> 10 seconds", "Pink Circle: DoT Gray Damage Resistance: 0% -> 80%", "Brisant and Shatter: Fire Rate: 550 -> 500 ms, Ammo: 6 -> 10", "Reaper: -15% Damage", "Damper Dot Damage: +100%", "Orange Circle, Gray Pentagon, and Gold Circle: Gray Damage Resistance: 45% -> 25%"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V50 UPDATE NOTES", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Feature: Pilots", "Microchips are reworked into pilots", "New Weapon(s): Maha Vajra and Vajra", "New Drone: Hiruko", "New Active Module(s): Life Saver", "New Shape(s): White Heptagon and Green Triangle", "Bug Fixes"])}
            ${updateLogger.title("h2", `SHAPES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `White Heptagon`)}
                The generation of Heptagon shaped brawlers. The designers of this shape wanted the Industry to leap into a more close ranged brawl. White Heptagon uses reflector shields and suppression to stay alive.
                ${updateLogger.title("h3", `Green Triangle`)}
                First generation of support healing shapes (ignoring Ultimate Green Circle).
            `)}
            ${updateLogger.title("h2", `PILOTS`)}
            ${updateLogger.marginBlock(10, `
                Pilots are a new way for players to equip and choose their "microchip" skills.
                Each pilot has their own story and expands the story behide the game.
            `)}
            ${updateLogger.title("h2", `WEAPONS`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Maha Vajra and Vajra`)}
                Maha Vajra and Vajra are plasma energy shotguns that does high damage but has high spread. Every hit emits a slowdown effect that lasts for a long 15 seconds.
            `)}
            ${updateLogger.title("h2", `DRONE(S)`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Hiruko`)}
                Hiruko, the first drone with a built-in weapon. Perfectly suited for Tan Circle/Orange Circle/Pink Circle since it provides buffs when under DoT Effects.
            `)}
            ${updateLogger.title("h2", `BUG FIXES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Fixed Ultimate Green Circle's ally healing not working", "Fixed bug where it doesn't count healing allies for end game rewards."])}
            `)}
            ${updateLogger.title("h2", `BALANCE CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Delay and Slumber: +25% Damage", "Gray Pentagon: Total shield count: 8 -> 5", "Magenta Circle: Enchancement how prefers ability damage over blast charge effect accumulation", "Magenta Circle: +200% Ability Damage", "Atomizer and Nucleon: Time until overheat: 16 -> 10 seconds", "Atomizer and Nucleon: Cooldown: 5.3 -> 1 seconds", "Damper, Deceiver, Trickster, Tamer: Rate of Fire: 24 -> 48 ms", "Trickster and Tamer: +15 Dmg", "Damper and Deceiver: DoT Damage -35%", "Damper and Deceiver: No limit on DoT Stacks"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V51 UPDATE NOTES (Feb 2, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Shape(s): Purple Heptagon and Light Blue Heptagon", "New Pilot(s): Eleanor Thorne, Elijah Forge, Caleb Sterling, and Sebastian Wren", "Changes to some lootboxes", "Reduced total amount of OXP to reach max level", "Increased Player XP rewards", "New Weapon(s): Tonans and Fulgur", "Balance Changes"])}
            ${updateLogger.title("h2", `NEW SHAPES(S): PURPLE HEPTAGON and LIGHT BLUE HEPTAGON`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Purple Heptagon:`)}
                A long ranged sniper that has the ability to deal percentage based damage.
                ${updateLogger.title("h3", `Light Blue Heptagon:`)}
                Next generation of flying shapes, it can teleport extra armor for defense and weapons for offense. The extra armor is removed once it is destroyed or the shape lands.
            `)} 
            ${updateLogger.title("h2", `NEW PILOTS`)}
            ${updateLogger.marginBlock(10, `
                Eleanor Thorne pilots Purple Heptagon<br>
                Elijah Forge pilots Cyan Hexagon<br>
                Caleb Sterling pilots Orange Circle<br>
                Sebastian Wren pilots Light Blue Heptagon<br><br>
                Their stories are currently work in progress.
            `)}
            ${updateLogger.title("h2", `NEW WEAPONS(S): TONANS and FULGUR`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Tonans and Fulgur:`)}
                Long ranged laser weapons that deal increased damage to tier 5 shapes.
            `)}
            ${updateLogger.title("h2", `BALANCE CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Pantagruel and Gangantua: Increased lifesteal power", "Pascal: On Threshold Heal: Cooldown: 10 -> 5 seconds", "Pascal: Gray Damage Healing: 50 -> 25%", "White Heptagon: Suppression Limit: 2 -> 5", "Many other minor changes."])}
            `)}
        `)}
    `);
    updateLogger.newLog("V52 UPDATE NOTES (Feb 9, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["Updated Bluebell's Hanger", "New Shape(s): Dark Brown Pentagon and Magenta Hexagon", "New Weapon(s): Jaw and Talon", "New Map(s): Void and Rome"])}
            ${updateLogger.title("h2", `NEW WEAPON(S): DARK BROWN PENTAGON and MAGENTA HEXAGON`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.title("h3", `Magenta Hexagon:`)}
                ${updateLogger.marginBlock(10, `
                    Improved version of yellow hexagon.
                `)}
                ${updateLogger.title("h3", `Dark Brown Pentagon:`)}
                ${updateLogger.marginBlock(10, `
                    A shape that can place down turrets.
                `)}
            `)}
            ${updateLogger.title("h2", `NEW WEAPON(S): JAW and TALON`)}
            ${updateLogger.marginBlock(10, `
                Homing rockets that emit rust and fragility effects.
            `)}
            ${updateLogger.title("h2", `BUG FIXES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Pascal: On Threshold Defense: 100 -> 200", "Tan Circle: Ability Cooldown: 6 -> 7 seconds", "Fixed Blue-Outlined Tan Circle from taking gray damage from DoT sources"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V53 UPDATE NOTES (Feb 17, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["Special prizes for Data Boxes after you open X amount.", "New Shape(s): Dark Green Pentagon and Dark Tan Circle", "New Module: Defense Amplifier", "New Weapon: Subduer", "Balance Changes / Other Improvements"])}
            ${updateLogger.title("h2", `CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Evora and Veyron: Reload time: 4 -> 3.5 sec", "Brown Pentagon: Hardpoints changed to: 2 light + 1 heavy", "Avalanche: AoE Range: 40 -> 80, Ammo gains per tick: 4 -> 6, and faster firing rate", "Fulgur and Tonans don't bypass energy shields no more"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V54 UPDATE NOTES (Feb 26, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Shape(s): Light Blue Triangle and Red Octagon", "New Weapon(s): Vortex and Thermite", "Balance Changes / Other Improvements"])}
            ${updateLogger.title("h2", `CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Armadillo: -50% Cooldown; +100% Defense Points on Beacon Capture", "Hiruko: +50% Damage", "Dark Tan Circle: Ability Health Increase: X4 -> x1.5", "Subduer: Damage: -25%; Shot Interval: 24 -> 48 ms; Reload Time: 4 -> 5 seconds; Rust Duration: 10 -> 5 seconds; Rust Power: 0.425 -> 0.213%"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V55 UPDATE NOTES (Mar 6, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Shape: Purple Pentagon", "New Weapon(s): Leiming, Fengbao, Inferno, and Pyro", "Less OXP is needed to reach level 200 at the Osperation", "Balance Changes / Other Improvements"])}
            ${updateLogger.title("h2", `CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Reduced the effectiveness of all slowdown effects."])}
            `)}
        `)}
    `);
    updateLogger.newLog("V56 UPDATE NOTES (Apr 1, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["Bots have access to motherships now", "New Shape(s): Ultimate Brown Pentagon, Blue Triangle, Pinkish-Red Heptagon, and Ultimate Brown Circle", "Balance Changes / Other Improvements"])}
            ${updateLogger.title("h2", `CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Reflector is its separate defense system and not a defense point attribute; Reflector is immune from defense mitigation like the defense system: forcefield. The effects are stack-able.", "Changed Bluebell's and Redbell's hangers", "Cyan Pentagon and Brown Pentagon: Removed Movement Dir Delay", "Cyan Pentagon: Shield Health: +200%", "Orange Heptagon: Ability Cooldown: 14 -> 12 seconds", "Reaper: gains the [Defense Breach] effect like DoT and Blast Effect", "Deceiver and Damper: +50% DoT Damage", "Toxin and Bane: +1000% DoT Damage", "Cyan Pentagon: Shield Regeneration Speed Increased", "Glacier and Rime: +100% Ammo", "Jaw and Talon: Increased fragility effectiveness", "Pyro and Inferno: Changed firing mechanic", "Pyro and Inferno: Increased Mothership Charge", "Pascal: Changes to On Threshold abilties", "Tan Circle: DoT Resistance: 60 -> 80%", "Damper, Deceiver, Trickster, and Tamer: Reduced Mothership Charge per Projectile", "Fengbao and Leiming: -15% Damage", "Minor changes"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V57 UPDATE NOTES (Apr 7, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Gameplay Event: Ratatatata", "New Limited Edition Active Modules", "New Active Modules: Shield Breaker and Repairing Conduit", "Changes to Unstable Conduit", "Balance Changes / Other Improvements"])}
            ${updateLogger.title("h2", `CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Veyron and Evora: +35% Damage", "Blue Triangle: Cannot bond with itself", "Gray Pentagon: Healing per Shield: 2.5 -> 10%", "White Heptagon: Reflector Blocked: 66.7 -> 80%", "Dark Green Pentagon: +50% Shield Durability"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V57 UPDATE NOTES (Apr 13, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Shape(s): Teal Pentagon", "New Weapon(s): Mace and Hammer", "Balance Changes / Other Improvements"])}
            ${updateLogger.title("h2", `CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Total modules rebalance", "Total pilot skills rebalance", "Total drone rebalance", "Total shape rebalance", "Total weapon rebalance (not built-in weapons from shapes)"])}
            `)}
        `)}
    `);
    updateLogger.newLog("V58 UPDATE NOTES (Apr 28, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Feature: Titans", "New Content: Titan Weapons, Titan Shapes, and Titan Modules", "Balance Changes / Other Improvements"])}
            ${updateLogger.title("h2", `CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Dark Tan Circle: Turret Effect Power: 2.5 -> 1.25%", "Gray Pentagon: -45% Shield Durability", "Gray Pentagon: 100 -> 50 Base Defense Points", "Blight and Decay: +15% Damage", "ULTIMATE Teal Circle: Durability Increase: 10 -> 5%", "ULTIMATE Teal Circle: Ability Cooldown: 6 -> 8 seconds", "All bots have max out mothership if they have one", "All bots have pilot skills equiped on their shapes now (expert league and above).", "Shape weapons no longer have defense mitigation", "Defense Amp: immunities are temporary."])}
            `)}
        `)}
    `);
    updateLogger.newLog("V59 UPDATE NOTES (May 21, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["New Titan: Luchador", "New Shape: Light Gray Heptagon", "New Weapons: Athos and Aramis", "New Titan Weapons: Igniter and Discharger", "Balance Changes / Other Improvements"])}
            ${updateLogger.title("h2", `CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Reaper Mothership Charge: -50%", "Last Stand: Invincibility -> 9000 Defense Points", "Blue Triangle: Healing Power: 15 -> 10%", "Kestrel: Deathmark Affector: 25 -> 15%", "White Octagon: Skyward Damage: -40%", "All 'Anti-Tier' Shapes will do more increased damage to titans as well."])}
            `)}
        `)}
    `);
    updateLogger.newLog("V60 UPDATE NOTES (June 17, 2024)", `
        ${updateLogger.marginBlock(10, `
            ${updateLogger.lineBlock(["Titans can now use pilots", "New Titan: Sharanga, Eiffel, and Bersagliere", "New Titan Weapons: Kramola, Razdor, Vendicatore, and Striker", "New Titan Module(s): Titan Charger", "Bots use titans now", "Balance Changes / Other Improvements"])}
            ${updateLogger.title("h2", `CHANGES`)}
            ${updateLogger.marginBlock(10, `
                ${updateLogger.lineBlock(["Yellow Heptagon: Forcefield Durability: 120k -> 300k", "Aramis and Athos: Increased healing percentage when dealing damage", "Removed the dontSell tag on many shapes and weapons", "Discharger and Igniter: +100% Blast Charge Accumulation", "Pyro and Inferno: +50% Mothership Charge", "Purple Pentagon: Fixed shield bugs", "Mace and Hammer: +175% Projectile Spread", "Repairing Conduit: Duration: 15 -> 6 seconds", "ULTIMATE Gray Pentagon: Defense Points: 150 -> 250", "Blight and Decay: Fire Rate: 400/75/75 -> 400/125/125, Reload: 3 -> 4 seconds, Damage Boost: 100%/150%/200% -> 100%/200%/300%", "Hammer, Mace, Brisant, Shatter, Maha Vajra, Vajra, Veyron, Evora: Many Buffs", "Ultimate Destroyer and Ultimate Punisher: +58% Damage", "Discharger and Igniter: -50% Mothership Charge", "Changes to the mothership: Black Oval"])}
            `)}
        `)}
    `);
    var mainDisplayText = updateLogger.grabHTML();
    document.getElementById("sideDisplay").innerHTML = "";
    function getValue(id) {
        return localStorage.getItem(id);
    }
    function saveValue(id, value) {
        localStorage.setItem(id, value);
    }
    var canvas = document.getElementById("gameCanvas");
    var ctx = canvas.getContext("2d");
    var mouseX = 0;
    var mouseY = 0;
    var player = {
        exterminationData: null,
        sliver: 200e3,
        gold: 250,
        keys: 1e3,
        shapes: [],
        weapons: [],
        modules: [],
        drones: [],
        pilots: [],
        motherships: [],
        gameMode: -1,
        ULIMATEXP: 0,
        workshopPoints: 0,
        league: 0,
        league2: 0,
        exterminationIndx: 0,
        lootboxSpecialPrize: {
            mk1: Math.randInt(12, 25),
            mk2: Math.randInt(25, 50),
            mk3: Math.randInt(37, 50)
        },
        profile: {
            level: 1,
            xp: {
                current: 0,
                max: 300
            }
        },
        tokens: {
            mk1: 0,
            mk2: 0,
            mk3: 0
        },
        parts: {
            shapes: {},
            weapons: {}
        }
    };
    //base x: 1980, base y: 1080
    var maxScreen = {
        x: 1980,
        y: 1080
    };
    var auSource = "./images/icons/au_icon.png";
    var agSource = "./images/icons/ag_icon.png";
    var sliverUpgradesByTier = [{//tier 1
        shapes: [0, 10e3, 20e3, 40e3, 80e3, 100e3, 200e3, 400e3, 800e3, 1e6, 2e6, 5e6],
        weapons: [0, 7.5e3, 15e3, 30e3, 60e3, 90e3, 150e3, 300e3, 700e3, 1e6, 1.5e6, 3e6],
        modules: [0, 500e3, 500e3, 1e6, 5e6, 5e6]
    }, {//tier 2
        shapes: [0, 20e3, 40e3, 80e3, 200e3, 400e3, 800e3, 1e6, 2e6, 4e6, 5e6, 8e6],
        weapons: [0, 10e3, 30e3, 60e3, 180e3, 300e3, 600e3, 900e3, 1.5e6, 3e6, 4e6, 6e6],
        modules: [0, 10e6, 10e6, 10e6, 10e6, 10e6]
    }, {//tier 3
        modules: [0, 40e6, 40e6, 40e6, 40e6, 40e6],
        shapes: [0, 120e3, 240e3, 480e3, 1e6, 1.5e6, 3e6, 5e6, 10e6, 20e6, 40e6, 80e6],
        weapons: [0, 100e3, 200e3, 400e3, 800e3, 1e6, 2e6, 4e6, 8e6, 16e6, 32e6, 64e6]
    }, {//tier 4
        modules: [0, 80e6, 80e6, 80e6, 80e6, 80e6],
        shapes: [0, 600e3, 1e6, 2e6, 5e6, 9e6, 14e6, 16e6, 25e6, 50e6, 90e6, 120e6],
        weapons: [0, 400e3, 800e3, 1.2e6, 4e6, 8e6, 12e6, 14e6, 20e6, 40e6, 80e6, 100e6]
    }, {//tier 5
        modules: [0, 1e9, 1e9, 2e9, 2e9, 2e9],
        shapes: [0, 5.625e6, 28.125e6, 56.25e6, 112.5e6, 225e6, 450e6, 675e6, 675e6, 843.75e6, 1012.5e6, 1406.25e6],
        weapons: [0, 3375e3, 16875e3, 3375e4, 675e5, 135e6, 27e6, 405e6, 405e6, 50625e4, 6075e5, 84375e4]
    }];
    sliverUpgradesByTier[10] = {
        shapes: [0, 250e6, 500e6, 1e9, 10e9, 50e9, 50e9, 100e9, 250e9, 500e9, 1e10, 5e10]
    };
    var unlockedAtTier = [1, 6, 13, 21, 30];
    var shapeSids = 0;
    class shape {
        constructor(data, slot, dontSID) {
            this.blind = false;
            this.isItem = true;
            this.x = 0;
            this.bonds = [];
            this.y = 0;
            this.layer = 0;
            this.velx = 0;
            this.tracers = [];
            this.industryName = data.industryName || "";
            this.reflectorData = data.reflectorData ? { ...data.reflectorData } : undefined;
            this.hullIntegrity = data.hullIntegrity;
            this.flightAnimationSpeed = data.flightAnimationSpeed;
            this.oldScale = data.scale;
            this.flightVisualData = 0;
            this.thingToKill = true;
            this.revive = data.revive;
            this.vely = 0;
            this.baseDP = 0;
            this.titan = data.titan || false;
            this.activeModuleIndex = data.activeModuleIndex || 0;
            this.costParts = data.costParts;
            this.grayDamage = 0;
            this.borderColor = data.borderColor;
            this.specialOf = data.specialOf;
            this.moduleHardpoints = data.moduleHardpoints;
            this.tier = data.tier;
            this.desc = data.desc;
            this.health = this.maxhealth = data.healthData ? data.healthData.base : data.health;
            this.speed = data.speed;
            this.color = data.color;
            this.fieldOfViewMulti = data.fieldOfViewMulti;
            this.effects = [];
            this.name = data.name;
            this.slot = slot;
            this.scale = data.scale;
            if (!dontSID) this.sid = shapeSids;
            this.hardpoints = data.hardpoints;
            this.level = 1;
            if (!dontSID) shapeSids++;
            this.sellPrice = 0;
            /** @type {drone} */
            this.drones = [];
            if (data.builtInDefensePointsData) {
                data.builtInDefensePoints = data.builtInDefensePointsData.base;
            }
            if (data.builtInDefensePoints) {
                this.normalDefensePoints = data.builtInDefensePoints;
                this.HAHAHAHHAHAHHANORMALDEFENENENNENENENNE = data.builtInDefensePoints;
            } else {
                this.normalDefensePoints = 0;
                this.HAHAHAHHAHAHHANORMALDEFENENENNENENENNE = 0;
            }
            this.additionalHealth = data.additionalHealthData ? data.additionalHealthData.base : data.additionalHealth;
            this.healingMulti = data.healingMultiData ? data.healingMultiData.base : data.healingMulti;
            this.builtInDefensePoints = data.builtInDefensePoints;
            this.baseDamageIncrease = data.baseDamageIncrease;
            this.baseShielding = null;
            this.turnDmgIntoDOT = data.turnDmgIntoDOT;
            this.enhanceCost = (this.tier + 1) * 2e3;
            if (data.shieldData || data.baseShielding) {
                if (data.baseShielding) data.shieldData = data.baseShielding;
                this.baseShielding = {
                    health: (data.shieldData.base || data.shieldData.health),
                    type: data.shieldData.type,
                    regen: data.shieldData.regen,
                    amountOfShields: data.shieldData.amountOfShields
                }
            }
            this.dotResistance = data.dotResistance;
            if (this.tier == 4) {
                this.sellPrice = 250e6;
            } else if (this.tier == 3) {
                this.sellPrice = 25e6;
            } else if (this.tier == 2) {
                this.sellPrice = 1e6;
            } else if (this.tier == 1) {
                this.sellPrice = 500e3;
            } else {
                this.sellPrice = 25e3;
            }
            this.healingAura = data.healingAuraData ? data.healingAuraData.base : data.healingAura;
            this.ability = null;
            this.indexRole = data.indexRole;
            this.abilities = [];
            if (data.abilities) {
                let Data = data.abilities;
                let robotName = data.name;
                for (let i = 0; i < Data.length; i++) {
                    let data = Data[i];
                    let ability = {
                        name: data.name,
                        desc: data.desc,
                        reload: data.reload,
                        iconSource: data.iconSource,
                        oldIconSource: data.iconSource,
                        defensePointToReflector: data.defensePointToReflector
                    };
                    if (data.name == "Defense Breach") {
                        ability.lastingTime = data.lastingTime;
                    } else if (data.name == "Overpower") {
                        ability.damageIncrease = data.damageIncreaseData ? data.damageIncreaseData.base : data.damageIncrease;
                        ability.lastingTime = data.lastingTime;
                    } else if (data.name == "Mute Blast") {
                        ability.abilityEffectDuration = data.abilityEffectDurationData ? data.abilityEffectDurationData.base : data.abilityEffectDuration;
                    } else if (data.name == "Plalanx Mode") {
                        ability.lastingTime = data.lastingTime;
                    } else if (data.name == "Stove" || data.name == "Blast Wave" || data.name == "Mastermind") {
                        ability.lastingTime = data.lastingTime;
                        ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                    } else if (data.name == "Full Action" && robotName == "Kid") {
                        ability.lastingTime = data.lastingTime;
                        if (data.abilityDefensePointsData) {
                            ability.abilityDefensePoints = data.abilityDefensePointsData.base;
                        } else {
                            ability.abilityDefensePoints = data.abilityDefensePoints;
                        }
                    } else if (data.name == "Hook") {
                        ability.lastingTime = data.lastingTime;
                        ability.charges = data.charges;
                        ability.maxcharge = data.charges;
                    } else if (data.name == "Dark Light") {
                        ability.lastingTime = data.lastingTime;
                        ability.deathmark = data.deathmarkData ? data.deathmarkData.base : data.deathmark;
                    } else if (data.name == "Track") {
                        ability.lastingTime = data.lastingTime;
                        ability.deathmark = data.deathmarkData ? data.deathmarkData.base : data.deathmark;
                        if (data.abilityDefensePointsData) {
                            ability.abilityDefensePoints = data.abilityDefensePointsData.base;
                        } else {
                            ability.abilityDefensePoints = data.abilityDefensePoints;
                        }
                    } else if (data.name == "Blocking Matrix") {
                        ability.effectAccumulation = data.effectAccumulationData ? data.effectAccumulationData.base : data.effectAccumulation;
                    } else if (data.name == "Ferocity" || data.name == "Clain Blink" || data.name == "Barrier Field") {
                        ability.lastingTime = data.lastingTime;
                        ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                        ability.executionThreshold = data.executionThresholdData ? data.executionThresholdData.base : data.executionThreshold;
                        ability.durabilityLimit = data.durabilityLimitData ? data.durabilityLimitData.base : data.durabilityLimit;
                        ability.shieldHp = data.shieldHpData ? data.shieldHpData.base : data.shieldHp;
                    } else if (data.name == "Active Support" || data.name == "Remote Assault" || data.name == "Blink Assault") {
                        ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                        ability.lastingTime = data.lastingTime;
                        ability.healingPercent = data.healingPercentData ? data.healingPercentData.base : data.healingPercent;
                        if (data.abilityDefensePointsData) {
                            ability.abilityDefensePoints = data.abilityDefensePointsData.base;
                        } else {
                            ability.abilityDefensePoints = data.abilityDefensePoints;
                        }
                        ability.charges = data.charges;
                        ability.maxcharge = data.charges;
                    } else if (data.name == "Frog Splash" || data.name == "Comet Splash") {
                        ability.lastingTime = data.lastingTime;
                        ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                        ability.charges = data.charges;
                        ability.maxcharge = data.charges;
                    } else if (data.name == "Cannonier") {
                        ability.lastingTime = data.lastingTime;
                        ability.additionalHealth = data.additionalHealthData ? data.additionalHealthData.base : data.additionalHealth;
                    } else if (data.name == "Annihilation Mode") {
                        ability.lastingTime = data.lastingTime;
                        ability.healingPower = data.healingPowerData ? data.healingPowerData.base : data.healingPower;
                    } else if (data.name == "Remote Repair" || data.name == "Support" || data.name == "Long Shot") {
                        ability.lastingTime = data.lastingTime;
                        if (data.name == "Support" || data.name == "Remote Repair") ability.healingPower = data.healingPowerData ? data.healingPowerData.base : data.healingPower;
                        if (data.name == "Remote Repair") {
                            ability.charges = data.charges;
                            ability.maxcharge = data.charges;
                        }
                    } else if (data.name == "Matrix") {
                        ability.lastingTime = data.lastingTime;
                        ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                    } else if (data.name == "Shapeshift") {
                        ability.mode = 0;
                        if (data.abilityDefensePointsData) {
                            ability.abilityDefensePoints = data.abilityDefensePointsData.base;
                        } else {
                            ability.abilityDefensePoints = data.abilityDefensePoints;
                        }
                        ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                    } else if (data.name == "Ultimate Reflecting Dash" || data.name == "Ultimate Reflector") {
                        ability.lastingTime = data.lastingTime;
                        if (data.abilityDefensePointsData) {
                            ability.abilityDefensePoints = data.abilityDefensePointsData.base;
                        } else {
                            ability.abilityDefensePoints = data.abilityDefensePoints;
                        }
                        if (data.suppressionPowerData) {
                            ability.suppressionPower = data.suppressionPowerData.base;
                        } else {
                            ability.suppressionPower = data.suppressionPower;
                        }
                    } else if (data.name == "Castling") {
                        ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                        ability.lastingTime = data.lastingTime;
                        if (data.abilityDefensePointsData) {
                            ability.abilityDefensePoints = data.abilityDefensePointsData.base;
                        } else {
                            ability.abilityDefensePoints = data.abilityDefensePoints;
                        }
                    } else if (data.name == "Reflector" || data.name == "Dismantle") {
                        ability.showDuration = true;
                        if (data.lastingTimeData) {
                            ability.lastingTime = data.lastingTimeData.base;
                        } else {
                            ability.lastingTime = data.lastingTime;
                        }
                        ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                        if (data.abilityDefensePointsData) {
                            ability.abilityDefensePoints = data.abilityDefensePointsData.base;
                        } else {
                            ability.abilityDefensePoints = data.abilityDefensePoints;
                        }
                    } else if (data.name == "Reinforce Hull" || data.name == "Blink Support") {
                        ability.showDuration = true;
                        if (data.abilityHealthMultiData) {
                            ability.abilityHealthMulti = data.abilityHealthMultiData.base;
                        } else {
                            ability.abilityHealthMulti = data.abilityHealthMulti;
                        }
                        if (data.lastingTimeData) {
                            ability.lastingTime = data.lastingTimeData.base;
                        } else {
                            ability.lastingTime = data.lastingTime;
                        }
                        if (data.abilityDefensePointsData) {
                            ability.abilityDefensePoints = data.abilityDefensePointsData.base;
                        } else {
                            ability.abilityDefensePoints = data.abilityDefensePoints;
                        }
                        ability.charges = data.charges;
                        ability.maxcharge = data.charges;
                        ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                    } else if (data.name == "Nuclear Rocket Shot" || data.name == "Roulette Strike" || data.name == "Paladin" || data.name == "Stealth Dash" || data.name == "Phase Shift" || data.name == "Dash" || data.name == "Fortify") {
                        ability.charges = data.charges;
                        ability.maxcharge = data.charges;
                        ability.lastingTime = data.lastingTime;
                        if (data.name == "Fortify" || data.name == "Paladin") {
                            ability.shieldHp = data.shieldHpData ? data.shieldHpData.base : data.shieldHp;
                        } else if (data.name == "Roulette Strike" || data.name == "Nuclear Rocket Shot") {
                            ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                            ability.dotDamage = data.dotData ? data.dotData.base : data.dotDamage;
                        }
                    } else {
                        if (data.name == "Absorption" || data.name == "Nuclear Strike" || data.name == "Skyward" || data.name == "Clear Sky" || data.name == "Divine Judgement" || data.name == "Grand Fortitude" || data.name == "Overload" || data.name == "Cold Pulse" || data.name == "Dragon Flight" || data.name == "Retribution" || data.name == "Stampede") {
                            ability.dmg = data.damageData ? data.damageData.base : data.dmg;
                            ability.charges = data.charges;
                            ability.maxcharge = data.charges;
                            console.log(ability.charges);
                            if (data.name == "Absorption" || data.name == "Skyward" || data.name == "Clear Sky" || data.name == "Divine Judgement" || data.name == "Grand Fortitude" || data.name == "Overload" || data.name == "Stampede" || data.name == "Dragon Flight" || data.name == "Retribution") {
                                ability.lastingTime = data.lastingTime;
                                if (data.name == "Clear Sky" || data.name == "Grand Fortitude" || data.name == "Dragon Flight") {
                                    ability.dotDamage = data.dotData ? data.dotData.base : data.dotDamage;
                                    ability.projPerShot = data.projPerShot;
                                    ability.fireRate = data.fireRate;
                                    ability.effectIncrease = data.effectIncreaseData ? data.effectIncreaseData.base : data.effectIncrease;
                                    ability.effectIncreaseName = data.effectIncreaseData ? data.effectIncreaseData.effect : data.effectIncreaseName;
                                }
                            }
                        } else {
                            ability.lastingTime = data.lastingTime;
                        }
                    }
                    this.abilities.push(ability);
                }
            }
        }
    }
    var shapeData = [{
        tier: 0,
        name: "Gray Circle",
        indexRole: 1,
        speed: 0.0018,
        speedLevel: [0, 0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0.0001, 0.0002, 0.0003, 0.0004],
        scale: 55,
        fieldOfViewMulti: 1.5,
        desc: `
        Training shape for mastering the basics of combat.<br><br>
        Recommended Equipment: x2 Punisher
        `,
        healthData: {
            base: 38e3,
            level: [0, 39e2, 42e2, 44e2, 46e2, 48e2, 5e3, 52e2, 56e2, 6e3, 8e3, 8e3],
        },
        hardpoints: {
            light: 2,
            heavy: 0
        },
        color: "#808080",
        moduleHardpoints: 0,
        cost: {
            sliver: 75e3,
            gold: 0
        }
    }, {
        tier: 0,
        name: "Black Circle",
        indexRole: 1,
        speed: 0.0012,
        speedLevel: [0, 0, 0.0001, 0.0001, 0, 0, 0, 0, 0.0001, 0.0001, 0.0002, 0.0002],
        scale: 75,
        fieldOfViewMulti: 1.5,
        desc: `
        Boasting 4 light weapon slots, 
        this shape is extremely versatile - a universal soldier. 
        Fit for combat at any range.<br><br>
        Recommended Equipment: x4 Punisher
        `,
        healthData: {
            base: 55e3,
            level: [0, 6e3, 6e3, 61e2, 61e2, 7e3, 71e2, 75e2, 8e3, 8e3, 9e3, 10e3],
        },
        hardpoints: {
            light: 4,
            heavy: 0
        },
        color: "#000",
        moduleHardpoints: 0,
        cost: {
            sliver: 570e3,
            gold: 0
        }
    }, {
        tier: 0,
        name: "Light Gray Circle",
        speed: 0.0028,
        indexRole: 2,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0004],
        scale: 45,
        fieldOfViewMulti: 1.35,
        desc: `
        One of the fastest shapes. 
        Holding 3 light weapons this shape can claim victory against the toughest enemies.<br><br>
        Recommended Equipment: x3 Landslide
        `,
        healthData: {
            base: 31e3,
            level: [0, 2e3, 2e3, 21e2, 31e2, 3e3, 41e2, 45e2, 4e3, 5e3, 6e3, 7e3],
        },
        hardpoints: {
            light: 3,
            heavy: 0
        },
        color: "#bababa",
        moduleHardpoints: 0,
        cost: {
            sliver: 0,
            gold: 250
        }
    }, {
        tier: 1,
        name: "Yellow Circle",
        speed: 0.0012,
        indexRole: 1,
        speedLevel: [0, 0, 0, 0.0001, 0, 0.0002, 0, 0.0001, 0.0001, 0, 0.0001, 0.0003],
        scale: 85,
        fieldOfViewMulti: 2.3,
        desc: `
        Holding 3 heavy weapons, this shape has unparalleled fire power.
        No other shape of the same tier can survive an onslaught of this shape.<br><br>
        Recommended Equipment: x3 Destroyer
        `,
        healthData: {
            base: 59e3,
            level: [0, 5e3, 5e3, 54e2, 8e3, 9e3, 12e3, 14e3, 16e3, 19e3, 20e3, 21e3],
        },
        hardpoints: {
            light: 0,
            heavy: 3
        },
        color: "#ffff00",
        moduleHardpoints: 1,
        cost: {
            sliver: 0,
            gold: 1e3
        }
    }, {
        tier: 1,
        name: "Green Circle",
        speed: 0.0021,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002],
        scale: 55,
        fieldOfViewMulti: 1.2,
        desc: `
        Moderately armored shape with the ability to heal itself when damaged.<br><br>
        Recommended Equipment: x1 Destroyer + x1 Punisher
        `,
        healthData: {
            base: 38e3,
            level: [0, 37e2, 41e2, 45e2, 58e2, 59e2, 6e3, 65e2, 66e2, 8e3, 81e2, 85e2],
        },
        abilities: [{
            name: "Self Heal",
            desc: `
            <span style="font-width: bolder; color: #fff;">Self Heal</span>
            Repairs a part of the shape's max durability over time.<br><br>
            Healing Rate: .5 second<br>
            Healing Power: 2.5%<br>
            Duration: 5 seconds<br>
            Cooldown: 12 seconds
            `,
            iconSource: "./images/abilities/self_heal.png",
            lastingTime: 5e3,
            reload: 12e3
        }],
        hardpoints: {
            light: 1,
            heavy: 1
        },
        color: "#00ff00",
        moduleHardpoints: 1,
        cost: {
            sliver: 0,
            gold: 15e2
        }
    }, {
        tier: 2,
        name: "Purple Circle",
        speed: 0.0014,
        indexRole: 0,
        speedLevel: [0, 0, 0, 0, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0.0002],
        scale: 55,
        fieldOfViewMulti: 1.4,
        desc: `
        This shape has an built-in defense system that decreases all incoming damage.
        Perfect warrior of any kind.<br><br>
        Recommended Equipment: x1 Avalanche + x2 Landslide
        `,
        builtInDefensePoints: 50,
        healthData: {
            base: 96e3,
            level: [0, 3e3, 3e3, 34e2, 4e3, 44e2, 5e3, 6e3, 64e2, 68e2, 7e3, 7e3],
        },
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#800080",
        moduleHardpoints: 2,
        cost: {
            sliver: 0,
            gold: 35e2
        }
    }, {
        tier: 1,
        name: "Blue Circle",
        speed: 0.0018,
        indexRole: 2,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002],
        scale: 45,
        fieldOfViewMulti: 1.25,
        desc: `
        Blue Circle has the ability to increase its defense.
        This ability allows it to go into short fights without taking a lot of dmg.<br><br>
        Recommended Equipment: x4 Hawk
        `,
        healthData: {
            base: 33e3,
            level: [0, 2550, 2805, 3060, 3400, 3655, 3655, 4250, 4250, 4675, 4845, 5100],
        },
        abilities: [{
            name: "Full Action",
            desc: `
            <span style="font-width: bolder; color: #fff;">Full Action</span>
            The shape activates a defense system, lowering all incoming damage.<br><br>
            Duration: 5 seconds<br>
            Damage Reduction: 60 Defense Points (37.5% resistance)<br>
            Cooldown: 16 seconds
            `,
            iconSource: "./images/abilities/full_action.png",
            lastingTime: 5e3,
            reload: 16e3
        }],
        hardpoints: {
            light: 4,
            heavy: 0
        },
        color: "#0000ff",
        moduleHardpoints: 1,
        cost: {
            sliver: 3e6,
            gold: 0
        }
    }, {
        tier: 2,
        name: "Teal Circle",
        speed: 0.001,
        indexRole: 0,
        speedLevel: [0, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0.0002, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.45,
        desc: `
        Improved version of blue circle.
        Teal Circle can do almost everything blue circle can do but better.<br><br>
        Recommended Equipment: x1 Punisher + x2 Destroyer
        `,
        healthData: {
            base: 86e3,
            level: [0, 9e3, 9e3, 9e3, 10e3, 13e3, 16e3, 18e3, 19e3, 20e3, 22e3, 25e3],
        },
        abilities: [{
            name: "Full Action",
            desc: `
            <span style="font-width: bolder; color: #fff;">Full Action</span>
            The shape activates a defense system, lowering all incoming damage.<br><br>
            Duration: 12 seconds<br>
            Damage Reduction: 200 Defense Points (66.7% resistance)<br>
            Cooldown: 16 seconds
            `,
            iconSource: "./images/abilities/full_action.png",
            lastingTime: 12e3,
            reload: 16e3
        }],
        hardpoints: {
            light: 1,
            heavy: 2
        },
        color: "#008080",
        moduleHardpoints: 3,
        cost: {
            sliver: 0,
            gold: 3e3
        }
    }, {
        tier: 2,
        name: "White Circle",
        speed: 0.0018,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001],
        scale: 55,
        fieldOfViewMulti: 1.25,
        desc: `
        White Circle has the ability to freeze enemies in place.<br><br>
        Recommended Equipment: x2 Eagle
        `,
        healthData: {
            base: 55e3,
            level: [0, 5e3, 5e3, 5e3, 5e3, 6e3, 6e3, 6e3, 6e3, 7e3, 7e3, 85e2],
        },
        abilities: [{
            name: "Cold Pulse",
            desc: `
            <span style="font-width: bolder; color: #fff;">Cold Pulse</span>
            The shape emits a pulse of cold energy. The pulse will freeze enemies in place,
            not allowing the usage of: abilities or active movement. For every enemy in the radius, the shape heals back some health.<br><br>
            Ability Range: 1200 PX<br>
            Effect Duration: 3 Seconds<br>
            Cooldown: 14 seconds<br>
            Heal back (per enemy): 5K HP
            `,
            damageData: {
                base: 500,
                level: [0, 25, 25, 25, 25, 25, 50, 50, 50, 50, 75, 75],
            },
            iconSource: "./images/abilities/cold_pulse.png",
            reload: 14e3
        }],
        hardpoints: {
            light: 0,
            heavy: 2
        },
        color: "#fff",
        moduleHardpoints: 2,
        cost: {
            sliver: 1e6,
            gold: 3750
        }
    }, {
        tier: 3,
        name: "Dark Gray Circle",
        speed: 0.0016,
        indexRole: 0,
        speedLevel: [0, 0, 0, 0, 0.0001, 0.0001, 0, 0.0001, 0, 0.0002, 0.0002, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.3,
        desc: `
        This shape has an built-in defense system with an twist.
        some of the damage taken will be redirected to the attacker.<br><br>
        Recommended Equipment: x3 Hawk / x3 Flux
        `,
        reflectorData: {
            resistance: .333,
            return: .6
        },
        healthData: {
            base: 77e3,
            level: [0, 5e3, 5e3, 7e3, 7e3, 7e3, 8e3, 8e3, 8e3, 10e3, 10e3, 15e3],
        },
        hardpoints: {
            light: 3,
            heavy: 0
        },
        color: "#4e4e4e",
        moduleHardpoints: 3,
        cost: {
            sliver: 0,
            gold: 75e2
        }
    }, {
        tier: 3,
        name: "Red Circle",
        speed: 0.0014,
        indexRole: 1,
        speedLevel: [0, 0, 0, 0, 0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002],
        scale: 75,
        fieldOfViewMulti: 2,
        desc: `
        Holding 4 heavy weapons-unparalleled fire power.
        Shape comes with built-in arc reactor, increasing its damage by 25%.<br><br>
        Recommended Equipment: x4 Viper
        `,
        baseDamageIncrease: .25,
        healthData: {
            base: 78e3,
            level: [0, 9e3, 9e3, 9e3, 9e3, 10e3, 10e3, 10e3, 10e3, 11e3, 11e3, 15e3],
        },
        hardpoints: {
            light: 0,
            heavy: 4
        },
        color: "#f00",
        moduleHardpoints: 3,
        cost: {
            sliver: 0,
            gold: 75e2
        }
    }, {
        tier: 1,
        name: "Red Pentagon",
        speed: 0.0014,
        indexRole: 1,
        speedLevel: [0, 0, 0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002],
        scale: 55,
        fieldOfViewMulti: 1.3,
        desc: `
        First shape with an energy shield.
        Energy shields protects the shape from non energy based projectiles, "direct" hits like the AOE effect from extermination enemies don't count and will be ignored.
        Energy Shield regens 5%, every 5 seconds.<br><br>
        Recommended Equipment: x1 Punisher + x1 Destroyer
        `,
        shieldData: {
            type: "energy",
            base: 10e3,
            level: [0, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3],
            regen: 0.05
        },
        healthData: {
            base: 55e3,
            level: [0, 3e3, 3e3, 3e3, 4e3, 4e3, 5e3, 5e3, 5e3, 5e3, 6e3, 6e3],
        },
        hardpoints: {
            light: 1,
            heavy: 1
        },
        color: "#f00",
        moduleHardpoints: 1,
        cost: {
            sliver: 0,
            gold: 15e2
        }
    }, {
        tier: 3,
        name: "Pink Circle",
        speed: 0.0021,
        indexRole: 0,
        speedLevel: [0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0.0001, 0.0002, 0.0002, 0.0002, 0.0003],
        scale: 65,
        fieldOfViewMulti: 1.6,
        desc: `
        Heavyly armored shape that can turn all damage into DOT damage.
        Alllowing the robot not to take a lot of damage instantly.<br><br>
        Recommended Equipment: x4 Atomizer
        `,
        turnDmgIntoDOT: true,
        healthData: {
            base: 118e3,
            level: [0, 9e3, 9e3, 9e3, 9e3, 9e3, 9e3, 11e3, 11e3, 14e3, 14e3, 16e3],
        },
        abilities: [{
            name: "Self Heal",
            desc: `
            <span style="font-width: bolder; color: #fff;">Self Heal</span>
            Repairs a part of the shape's max durability over time.<br><br>
            Healing Rate: .5 second<br>
            Healing Power: 10%<br>
            Duration: 8 seconds<br>
            Cooldown: 7 seconds
            `,
            iconSource: "./images/abilities/self_heal.png",
            lastingTime: 8e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 4,
            heavy: 0
        },
        color: "#ffc0cb",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 2,
        name: "Blue Pentagon",
        speed: 0.0016,
        indexRole: 0,
        speedLevel: [0, 0, 0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.3,
        desc: `
        Blue Pentagon is a shield dependent shape.
        Low base health but really high shield hp.
        Moves decently fast.<br><br>
        Recommended Equipment: x2 Viper
        `,
        shieldData: {
            type: "energy",
            base: 45500,
            level: [0, 3900, 3900, 5200, 5200, 6500, 6500, 7800, 9750, 11050, 13000, 13000],
            regen: 0.1
        },
        healthData: {
            base: 26e3,
            level: [0, 3e3, 3e3, 3e3, 4e3, 4e3, 4e3, 4e3, 5e3, 5e3, 5e3, 55e2],
        },
        abilities: [{
            name: "Shield Regeneration",
            desc: `
            <span style="font-width: bolder; color: #fff;">Shield Regeneration</span>
            The shape activates a powerful matrix that increases the regeneration rate of its shields.<br><br>
            Duration: 6 seconds<br>
            Rate Multiplier: 10<br>
            Cooldown: 14 seconds
            `,
            iconSource: "./images/abilities/shield_regen.png",
            lastingTime: 6e3,
            reload: 14e3
        }],
        hardpoints: {
            light: 0,
            heavy: 2
        },
        color: "#00f",
        moduleHardpoints: 2,
        cost: {
            sliver: 500e3,
            gold: 5e3
        }
    }, {
        tier: 3,
        name: "Brown Circle",
        speed: 0.0016,
        indexRole: 1,
        flightAnimationSpeed: 10e3,
        speedLevel: [0, 0, 0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.45,
        desc: `
        Brown Circle is equipped with flight tech.<br><br>
        Recommended Equipment: x2 Viper + x2 Sting
        `,
        healthData: {
            base: 74e3,
            level: [0, 2e3, 2e3, 2e3, 2e3, 4e3, 5e3, 5e3, 5e3, 7e3, 7e3, 7e3],
        },
        abilities: [{
            name: "Dragon Flight",
            desc: `
            <span style="font-width: bolder; color: #fff;">Dragon Flight</span>
            The shape flies up, ignoring all buildings while moving and activates a power built-in weapon.<br><br>
            Duration: 6 seconds<br>
            Damage Reduction: 9000 Defense Points (99% resistance)<br>
            Speed Increase: 200%<br>
            Cooldown: 14 seconds
            `,
            damageData: {
                base: 62,
                level: [0, 14, 17, 20, 23, 23, 26, 27, 29, 30, 32, 33]
            },
            dotData: {
                base: 5,
                level: [0, 5, 5, 5, 5, 5, 5, 10, 10, 10, 10, 20],
            },
            lastingTime: 6e3,
            iconSource: "./images/abilities/dragon_flight.png",
            reload: 14e3
        }],
        hardpoints: {
            light: 2,
            heavy: 2
        },
        color: "#964b00",
        moduleHardpoints: 3,
        cost: {
            sliver: 10e6,
            gold: 75e2
        }
    }, {
        tier: 4,
        name: "Orange Circle",
        speed: 0.0012,
        indexRole: 0,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002],
        scale: 75,
        fieldOfViewMulti: 1.6,
        desc: `
        Orange Circle has an built-in defense system, with an reflector built-in it.
        The shape also has an ability to heal itself and to turn all damage into DOT.
        Shape also takes less GRAY DAMAGE.
        <br><br>
        Recommended Equipment: x1 Storm + x2 Thunder
        `,
        hullIntegrity: .25,
        healthData: {
            base: 100e3,
            level: [0, 11e3, 12e3, 13e3, 14e3, 16e3, 18e3, 18e3, 18e3, 18e3, 20e3, 25e3]
        },
        hardpoints: {
            light: 1,
            heavy: 2
        },
        abilities: [{
            name: "Ultimate Defense",
            desc: `
            <span style="font-width: bolder; color: #fff;">Ultimate Defense</span>
            The shape activates its built-in matrix. This allows the shape to convert all damage to DoT,
            and allows for a quick built-in healing.<br><br>
            DoT Duration: 15 seconds<br>
            Healing Power: 2.5%<br>
            Healing Rate: .5 seconds<br>
            Duration: 8 seconds<br>
            Cooldown: 10 seconds
            `,
            iconSource: "./images/abilities/shield_regen.png",
            lastingTime: 8e3,
            reload: 10e3
        }],
        reflectorData: {
            resistance: .5,
            return: .2
        },
        color: "#ffa500",
        moduleHardpoints: 3,
        cost: {
            sliver: 900e6,
            gold: 100e3,
            workshopPoints: 2e3
        }
    }, {
        tier: 2,
        name: "White Pentagon",
        speed: 0.0014,
        indexRole: 2,
        speedLevel: [0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.25,
        desc: `
        White Pentagon is a legendary brawler.
        With the ability to remove itself from enemy radars, it can deliver damage without getting targeted.<br><br>
        Recommended Equipment: x2 Storm + x1 Thunder
        `,
        shieldData: {
            type: "yellow",
            base: 37e3,
            level: [0, 2e3, 2e3, 2e3, 3e3, 3e3, 4e3, 4e3, 4e3, 5e3, 5e3, 6e3],
            regen: 0.05
        },
        healthData: {
            base: 56e3,
            level: [0, 2e3, 2e3, 4e3, 4e3, 4e3, 6e3, 6e3, 8e3, 8e3, 10e3, 12e3],
        },
        abilities: [{
            name: "Stealth",
            desc: `
            <span style="font-width: bolder; color: #fff;">Stealth</span>
            Removes the shape from all enemy radars.<br><br>
            Duration: 4 seconds<br>
            Speed Increase: 100%<br>
            Cooldown: 12 seconds
            `,
            iconSource: "./images/stealth.png",
            lastingTime: 4e3,
            reload: 12e3
        }],
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#fff",
        moduleHardpoints: 2,
        cost: {
            sliver: 2e6,
            gold: 5e3
        }
    }, {
        tier: 3,
        name: "Tan Pentagon",
        indexRole: 1,
        speed: 0.0024,
        speedLevel: [0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.35,
        desc: `
        Tan Pentagon is a dangerous shape that can turn enemies fire power aganist them.
        <br><br>
        Recommended Equipment: x4 Atomizer
        `,
        healthData: {
            base: 68e3,
            level: [0, 2e3, 2e3, 3e3, 3e3, 4e3, 4e3, 4e3, 5e3, 5e3, 6e3, 8e3],
        },
        abilities: [{
            name: "Retribution",
            desc: `
            <span style="font-width: bolder; color: #fff;">Retribution</span>
            The shape activates a purple shield and its built-in weapons. Damage aborbed by the shield will increase the effectiveness of the built-in weapons.<br><br>
            Duration: 12 seconds<br>
            Max Increase: 100%<br>
            Ability Range: 800PX<br>
            Ability Fire Rate: .1 seconds<br>
            Cooldown 10 seconds
            `,
            iconSource: "./images/abilities/retribution.png",
            damageData: {
                base: 567,
                level: [0, 77, 77, 99, 99, 99, 133, 133, 133, 167, 167, 167],
            },
            lastingTime: 12e3,
            reload: 10e3
        }],
        hardpoints: {
            light: 4,
            heavy: 0
        },
        color: "#d2b48c",
        moduleHardpoints: 3,
        cost: {
            sliver: 2e6,
            gold: 75e2
        }
    }, {
        tier: 3,
        name: "Purple Hexagon",
        speed: 0.0018,
        indexRole: 2,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.35,
        desc: `
        Purple Hexagon is a stealthy fighter.
        <br><br>
        Recommended Equipment: x2 Storm + x1 Thunder
        `,
        healthData: {
            base: 85e3,
            level: [0, 5e3, 5e3, 6e3, 6e3, 6e3, 7e3, 8e3, 9e3, 10e3, 12e3, 15e3],
        },
        abilities: [{
            name: "Stealth Dash",
            desc: `
            <span style="font-width: bolder; color: #fff;">Stealth Dash</span>
            The shape leaps forward in a chosen direction. During that, the shape activates stealth that lasts during and after the dash.<br><br>
            Max Charges: 3<br>
            Usage Interval: .75 seconds<br>
            Cooldown (per charge): 8 seconds
            `,
            iconSource: "./images/abilities/stealth_dash.png",
            charges: 3,
            lastingTime: 750,
            reload: 8e3
        }],
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#800080",
        moduleHardpoints: 3,
        cost: {
            sliver: 1e6,
            gold: 5e3,
            workshopPoints: 2e3
        }
    }, {
        tier: 3,
        name: "Yellow Hexagon",
        speed: 0.0012,
        indexRole: 2,
        speedLevel: [0, 0, 0.0001, 0, 0.0001, 0.0001, 0, 0.0001, 0, 0, 0.0001, 0.0002],
        scale: 75,
        fieldOfViewMulti: 1.35,
        desc: `
        Yellow Hexagon is a super fighter, with the ability to not take any damage.
        <br><br>
        Recommended Equipment: x4 Storm
        `,
        healthData: {
            base: 96e3,
            level: [0, 10e3, 10e3, 10e3, 10e3, 12e3, 14e3, 14e3, 16e3, 16e3, 18e3, 25e3],
        },
        abilities: [{
            name: "Phase Shift",
            desc: `
            <span style="font-width: bolder; color: #fff;">Phase Shift</span>
            The shape activates a powerful matrix that allows it not to take any damage. Negative Effects are all nullfied during the ability.<br><br>
            Duration: 2 seconds<br>
            Max Charges: 2<br>
            Speed Increase: 150%<br>
            Cooldown (per charge): 8 seconds
            `,
            iconSource: "./images/abilities/phase_shift.png",
            charges: 2,
            lastingTime: 2e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 4,
            heavy: 0
        },
        color: "#ffff00",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 2,
        name: "Gray Hexagon",
        speed: 0.0018,
        indexRole: 2,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002, 0.0004],
        scale: 55,
        fieldOfViewMulti: 1.1,
        desc: `
        Gray Hexagon is a fast moving attacker.
        <br><br>
        Recommended Equipment: x2 Delay
        `,
        healthData: {
            base: 66e3,
            level: [0, 3000, 3000, 3000, 3000, 3600, 4200, 4200, 4800, 4800, 5400, 7500]
        },
        abilities: [{
            name: "Dash",
            desc: `
            <span style="font-width: bolder; color: #fff;">Dash</span>
            The shape leaps into a chosen direction.<br><br>
            Max Charges: 5<br>
            Usage Interval: .3 seconds<br>
            Cooldown (per charge): 2 seconds
            `,
            iconSource: "./images/abilities/dash.png",
            charges: 5,
            lastingTime: 300,
            reload: 2e3
        }],
        hardpoints: {
            light: 0,
            heavy: 2
        },
        color: "#808080",
        moduleHardpoints: 2,
        cost: {
            sliver: 500e3,
            gold: 5e3
        }
    }, {
        tier: 3,
        name: "Red Hexagon",
        speed: 0.0016,
        indexRole: 0,
        speedLevel: [0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002],
        scale: 60,
        fieldOfViewMulti: 1.3,
        desc: `
        Red Hexagon is a shield stacker.
        <br><br>
        Recommended Equipment: x2 Rime + x1 Glacier
        `,
        healthData: {
            base: 44e3,
            level: [0, 3e3, 3e3, 3e3, 3e3, 4e3, 4e3, 4e3, 5e3, 5e3, 6e3, 8e3],
        },
        abilities: [{
            name: "Fortify",
            desc: `
            <span style="font-width: bolder; color: #fff;">Fortify</span>
            The shape activates its generator and generates a energy shield. Energy shields obtained cannot regenerate health.<br><br>
            Duration of Shields: Until Destruction<br>
            Usage Interval: 1 second<br>
            Max Charges: 2<br>
            Shield Type: Blue (when MK2 or MK3, yellow)<br>
            Cooldown (per charge): 12 seconds
            `,
            iconSource: "./images/modules/fortifier.png",
            shieldHpData: {
                base: 35e3,
                level: [0, 4e3, 4e3, 4e3, 4e3, 4e3, 10e3, 10e3, 12e3, 12e3, 12e3, 16e3],
            },
            charges: 2,
            lastingTime: 2e3,
            reload: 12e3
        }],
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#f00",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Tan Circle",
        speed: 0.0012,
        speedLevel: [0, 0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0.0002, 0.0002],
        scale: 70,
        fieldOfViewMulti: 1.4,
        desc: `
        A great shape to bully your enemies.
        Tan Circle rams into enemies, converts damage into DOT.
        Tan Circle also has resistance aganist DOT damage.
        <br><br>
        Recommended Equipment: x3 Shatter + x1 Brisant / x3 Evora + x1 Veyron
        `,
        healthData: {
            base: 90e3,
            level: [0, 4500, 9000, 9750, 11250, 12000, 13500, 15e3, 16500, 18750, 18750, 22500]
        },
        dotResistance: .4,
        abilities: [{
            name: "Stampede",
            desc: `
            <span style="font-width: bolder; color: #fff;">Stampede</span>
            The shape speeds up and activates its defense system that turns all damage to DoT. During the ability, the shape becomes harder to control and activates a magnetic field.<br><br>
            DoT Duration (per stack): 7 seconds<br>
            Magnetic Field Range: 400PX<br>
            Speed Increase: +200%<br>
            Duration: 10 seconds<br>
            Cooldown: 12 seconds
            `,
            iconSource: "./images/abilities/stampede.png",
            damageData: {
                base: 440,
                level: [0, 270, 300, 330, 360, 390, 420, 450, 480, 510, 540, 570],
            },
            lastingTime: 10e3,
            reload: 12e3
        }],
        hardpoints: {
            light: 3,
            heavy: 1
        },
        color: "#d2b48c",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 3,
        name: "Orange Pentagon",
        speed: 0.0014,
        indexRole: 1,
        speedLevel: [0, 0, 0, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001],
        scale: 55,
        fieldOfViewMulti: 1.35,
        desc: `
        Orange Pentagon has a strong yellow energy shield that doesn't repair itself.
        Great for attacking grouped up enemies.
        Orange Pentagon has a special system that makes [CINDER] deal increased damage (+100%).
        <br><br>
        Recommended Equipment: x3 Cinder
        `,
        healthData: {
            base: 96e3,
            level: [0, 6e3, 6e3, 6e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 12e3, 12e3],
        },
        shieldData: {
            type: "normal",
            base: 450e3,
            amountOfShields: 5,
            level: [0, 10e3, 20e3, 30e3, 30e3, 40e3, 40e3, 40e3, 50e3, 50e3, 60e3, 80e3],
            regen: 0
        },
        abilities: [{
            name: "Overload",
            desc: `
            <span style="font-width: bolder; color: #fff;">Overload</span>
            The shape speeds up and activates a ticking bomb, after the timer reaches 0: the shape expodes, dealing AoE damage.<br><br>
            Duration: 3 seconds<br>
            Ability Range: 500<br>
            Speed Increase: 100%<br>
            Cooldown: 4 seconds
            `,
            iconSource: "./images/weapons/cinder.png",
            damageData: {
                base: 9260,
                level: [0, 778, 778, 1166, 1166, 1555, 1555, 1944, 1944, 3888, 3888, 9720]
            },
            lastingTime: 3e3,
            reload: 4e3
        }],
        hardpoints: {
            light: 0,
            heavy: 3
        },
        color: "#ffa500",
        moduleHardpoints: 3,
        cost: {
            sliver: 10e6,
            gold: 75e2,
            workshopPoints: 2e3
        }
    }, {
        tier: 3,
        name: "Black Pentagon",
        speed: 0.0012,
        indexRole: 2,
        speedLevel: [0, 0, 0.0001, 0.0001, 0, 0, 0.0001, 0.00005, 0, 0.0001, 0.0002, 0.0002],
        scale: 60,
        fieldOfViewMulti: 1.4,
        desc: `
        Black Pentagon has the ability to decide if you need more health or to incapacitate enemies!
        <br><br>
        Recommended Equipment: x3 Devastator
        `,
        healthData: {
            base: 64e3,
            level: [0, 3e3, 3e3, 3e3, 3e3, 5e3, 5e3, 5e3, 5e3, 5e3, 8e3, 12e3],
        },
        abilities: [{
            name: "Paladin",
            desc: `
            <span style="font-width: bolder; color: #fff;">Paladin</span>
            Activates a shield, that when destroyed: it emits a pulse that EMP's all enemies, disabling them of their abilties, and when not destroyed: restores durability and increase max durability.<br><br>
            Shield Duration: 10 seconds<br>
            Cooldown: 8 seconds
            `,
            iconSource: "./images/modules/fortifier.png",
            shieldHpData: {
                base: 150e3,
                level: [0, 6e3, 7e3, 8e3, 8e3, 8e3, 8e3, 8e3, 9e3, 10e3, 10e3, 11e3],
            },
            lastingTime: 10e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 0,
            heavy: 3
        },
        color: "#000",
        moduleHardpoints: 3,
        cost: {
            sliver: 5e6,
            gold: 75e2,
            workshopPoints: 1e3
        }
    }, {
        tier: 4,
        name: "Red Heptagon",
        speed: 0.0028,
        indexRole: 1,
        speedLevel: [0, 0, 0.0001, 0.0001, 0, 0, 0.0001, 0.00005, 0, 0.0001, 0.0001, 0.0001],
        scale: 120,
        fieldOfViewMulti: 3.5,
        desc: `
        The first shape able to fire 6 heavy weapons simultaneously.
        It's the true embodiment of unparalleled firepower.
        <br><br>
        Recommended Equipment: x6 Reaper / x6 Veyron
        `,
        healthData: {
            base: 134e3,
            level: [0, 8e3, 8e3, 12e3, 12e3, 24e3, 24e3, 24e3, 10e3, 12e3, 15e3, 20e3],
        },
        hardpoints: {
            light: 0,
            heavy: 6
        },
        abilities: [{
            name: "Self Heal",
            desc: `
            <span style="font-width: bolder; color: #fff;">Self Heal</span>
            The shape repairs a part of its max durability over time.<br><br>
            Healing Power: 2.5%<br>
            Duration: 5 seconds<br>
            Healing Rate: .5 seconds<br>
            Cooldown: 6 seconds
            `,
            iconSource: "./images/abilities/self_heal.png",
            lastingTime: 5e3,
            reload: 6e3
        }],
        color: "#f00",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Gold Circle",
        speed: 0.001,
        indexRole: 0,
        speedLevel: [0, 0.0001, 0.0001, 0, 0, 0, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0.0001],
        scale: 85,
        fieldOfViewMulti: 1.65,
        desc: `
        First Shape to hold more than 4 module slots.
        Gold Circle is a super tank worthy of your possession.
        The shape has the passive ability to self revive after its destruction, and
        healing is 50% more effective.
        The shape also takes next to no gray damage.
        <br><br>
        Recommended Equipment: x2 Evora + x2 Veyron
        `,
        hullIntegrity: .25,
        healthData: {
            base: 100e3,
            level: [0, 8500, 10e3, 10e3, 10e3, 10e3, 15e3, 15e3, 20e3, 20e3, 20e3, 25e3]
        },
        hardpoints: {
            light: 2,
            heavy: 2
        },
        abilities: [{
            name: "Grand Fortitude",
            desc: `
            <span style="font-width: bolder; color: #fff;">Grand Fortitude</span>
            The shape leaps forward in a chosen direction and activates its defense system. After the shape stops, it emits a powerful blast that deals damage and emits DoT.<br><br>
            Duration of Defense: 16 seconds<br>
            Reflector Blocked: 33.3%<br>
            Reflector Returned: 15%<br>
            Instant Heal on Ability: 10%<br>
            Cooldown: 6 seconds
            `,
            iconSource: "./images/abilities/grand_fortitude.png",
            damageData: {
                base: 7250,
                level: [0, 1450, 2900, 2900, 2900, 2900, 2900, 2900, 2900, 2900, 2900, 2900]
            },
            dotData: {
                base: 870,
                level: [0, 216, 216, 216, 216, 216, 216, 455, 455, 455, 455, 455]
            },
            lastingTime: 0,
            reload: 6e3
        }],
        healingMulti: 1.5,
        revive: .5,
        color: "#ffd700",
        moduleHardpoints: 4,
        costParts: true
    }, {
        tier: 0,
        name: "Black Hexagon",
        speed: 0.0012,
        indexRole: 2,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0004],
        scale: 45,
        fieldOfViewMulti: 1.15,
        desc: `
        Black Hexagon is a fast moving attacker.
        <br><br>
        Recommended Equipment: x3 Punisher
        `,
        healthData: {
            base: 32e3,
            level: [0, 1e3, 1e3, 2e3, 2e3, 2e3, 2e3, 3e3, 3e3, 3e3, 4e3, 5e3]
        },
        abilities: [{
            name: "Dash",
            desc: `
            <span style="font-width: bolder; color: #fff;">Dash</span>
            The shape leaps into a chosen direction.<br><br>
            Max Charges: 2<br>
            Cooldown (per charge): 5 seconds
            `,
            iconSource: "./images/abilities/dash.png",
            charges: 2,
            lastingTime: 500,
            reload: 5e3
        }],
        hardpoints: {
            light: 3,
            heavy: 0
        },
        color: "#000",
        moduleHardpoints: 0,
        cost: {
            sliver: 0,
            gold: 500
        }
    }, {
        tier: 2,
        name: "White Hexagon",
        speed: 0.0012,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001],
        scale: 65,
        fieldOfViewMulti: 1.4,
        desc: `
        White Hexagon is a tier 3 shape with the ability to take down tier 4 and tier 5 shapes!<br><br>
        Recommended Equipment: x2 Flux
        `,
        healthData: {
            base: 67e3,
            level: [0, 4e3, 4e3, 4e3, 5e3, 6e3, 6e3, 6e3, 6e3, 7e3, 7e3, 85e2],
        },
        abilities: [{
            name: "Divine Judgement",
            desc: `
            <span style="font-width: bolder; color: #fff;">Divine Judgement</span>
            The shape slows down, activates a defense system, and a built-in weapon. The damage of its built-in weapon is enchance by the enemy's shape information (deals +150% more damage to titans).<br><br>
            Duration: 5 seconds<br>
            Damage Reduction: 9000 Defense Points (99% resistance)<br>
            Speed Decrease: 80%<br>
            Cooldown: 12 seconds
            `,
            damageData: {
                base: 360,
                level: [0, 12, 12, 15, 12, 12, 12, 24, 24, 24, 24, 48]
            },
            lastingTime: 5e3,
            iconSource: "./images/weapons/flux.png",
            reload: 12e3
        }],
        hardpoints: {
            light: 0,
            heavy: 2
        },
        color: "#fff",
        moduleHardpoints: 2,
        costParts: true
    }, {
        tier: 3,
        name: "Blue Heptagon",
        speed: 0.0014,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002],
        scale: 75,
        fieldOfViewMulti: 1.55,
        desc: `
        This shape possesses the <strong>Infinite Void</strong> ability,
        allowing it to immobilize enemies for 12 seconds
        while making them more susceptible to damage.
        <br><br>
        Recommended Equipment: x2 Veyron + 1 Evora
        `,
        healthData: {
            base: 93e3,
            level: [0, 4e3, 4e3, 4e3, 4e3, 5e3, 6e3, 7e3, 9e3, 9e3, 10e3, 15e3],
        },
        abilities: [{
            name: "Domain Expansion: Infinite Void",
            desc: `
            <span style="font-width: bolder; color: #fff;">Domain Expansion: Infinite Void</span><br><br>
            <span style="font-width: bolder; color: #fff;">Domain Expansion</span> represents an advanced shield technology that harnesses the intrinsic essence of shapes, encapsulating them within protective barriers. Regardless of whether an entity is friend or foe, once they step into a domain aligned with their own shape, they gain increased defense and speed, thanks to this synergy.<br><br>
            <span style="font-width: bolder; color: #fff;">Infinite Void</span> is a formidable ability that leaves all foes trapped within its dominion entirely immobilized, rendering them incapable of counterattacks or utilizing their unique abilities, including any projectiles they may possess. Furthermore, while ensnared within this void, they become more susceptible to damage, increasing their vulnerability.<br><br>
            Duration: 4 seconds<br>
            Cooldown: 14 seconds
            `,
            lastingTime: 4e3,
            iconSource: "./images/abilities/infinite_void.png",
            reload: 14e3
        }],
        hardpoints: {
            light: 1,
            heavy: 2
        },
        color: "#00f",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Cyan Pentagon",
        speed: 0.0026,
        indexRole: 2,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0004, 0.0004, 0.0006],
        scale: 65,
        fieldOfViewMulti: 1.3,
        desc: `
        Cyan Pentagon is a fast shield fighter.
        Holding 6 light weapons, this shape can enter and win fights without taking any damage to its hull.<br><br>
        Recommended Equipment: x6 Lance
        `,
        shieldData: {
            type: "yellow",
            base: 40e3,
            level: [0, 10e3, 10e3, 14e3, 14e3, 17500, 17500, 17500, 17500, 19250, 22750, 43750],
            regen: 0.15
        },
        revive: .5,
        healthData: {
            base: 76e3,
            level: [0, 4e3, 4e3, 4e3, 5e3, 5e3, 5e3, 5e3, 6e3, 6e3, 8e3, 8e3],
        },
        abilities: [{
            name: "Shield Regeneration",
            desc: `
            <span style="font-width: bolder; color: #fff;">Shield Regeneration</span>
            The shape increases the regeneration rate of its shield and its movement speed.<br><br>
            Speed Increase: 150%<br>
            Regeneration Increase: x13<br>
            Duration: 6 seconds<br>
            Cooldown: 10 seconds
            `,
            iconSource: "./images/abilities/shield_regen.png",
            lastingTime: 6e3,
            reload: 10e3
        }],
        hardpoints: {
            light: 6,
            heavy: 0
        },
        color: "#00ffff",
        moduleHardpoints: 3,
        costParts: true
    }, {
        dontSell: true,
        tier: 3,
        name: "Cyan Circle",
        speed: 0.0012,
        indexRole: 0,
        speedLevel: [0, 0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0002, 0.0002, 0.0002, 0.0002],
        scale: 75,
        fieldOfViewMulti: 1.45,
        desc: `
        The Cyan Circle can temporarily increase its hull's
        durability and gain extra resistance,
        allowing it to engage in fights without
        sustaining any serious long-term damage.
        <br><br>
        Recommended Equipment: x3 Gangantua + x1 Pantagruel
        `,
        healthData: {
            base: 116e3,
            level: [0, 8e3, 8e3, 10e3, 10e3, 15e3, 15e3, 15e3, 15e3, 15e3, 20e3, 20e3],
        },
        abilities: [{
            name: "Reinforce Hull",
            desc: `
            <span style="font-width: bolder; color: #fff;">Reinforce Hull</span>
            The shape teleports in extra armor, increasing its health for a period of time. After the ability ends, the shape's total gray damage is reduced by 75%.<br><br>
            Duration: Based on shape level<br>
            Cooldown: 8 seconds
            `,
            abilityHealthMultiData: {
                base: 1.5,
                level: [0, .05, .05, .05, .05, .05, .5, .1, .1, .1, .1, .15]
            },
            abilityDefensePointsData: {
                base: 25,
                level: [0, 25, 0, 25, 0, 25, 0, 25, 0, 0, 0, 25]
            },
            lastingTimeData: {
                base: 2e3,
                level: [0, 100, 100, 100, 100, 100, 250, 250, 500, 500, 1e3, 1e3]
            },
            iconSource: "./images/modules/heavy_armor_plating.png",
            reload: 8e3
        }],
        hardpoints: {
            light: 1,
            heavy: 3
        },
        color: "#00ffff",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Pinkish-Red Circle",
        speed: 0.0012,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0004],
        scale: 60,
        fieldOfViewMulti: 1.45,
        desc: `
        The Pinkish-Red Circle, a formidable shape in the
        realm of combat, serves as the optimal configuration
        for ensuring enemies bear witness to their gradual
        demise, all the while being incapacitated from rejuvenating
        their vitality. This strategic shape is designed to offer a
        visually compelling and practically
        disadvantageous spectacle for foes.
        <br><br>
        Recommended Equipment: x1 Damper + x2 Tamer
        `,
        dotResistance: .1,
        healthData: {
            base: 68e3,
            level: [0, 6e3, 6e3, 6e3, 6e3, 6e3, 11e3, 11e3, 11e3, 11e3, 15e3, 15e3],
        },
        abilities: [{
            name: "Roulette Strike",
            desc: `
            <span style="font-width: bolder; color: #fff;">Roulette Strike</span>
            The shape fires a projectile that emits a field upon destruction. The field emits rust and DoT effects to any enemy near its radius. Also upon activation, the shape reduces the duration of all rust effects applied to the shape.<br><br>
            Proj. Range: 1400PX<br>
            Max Charges: 3<br>
            Effect Durations: 15 seconds<br>
            Effect Emit Speed: .25 seconds<br>
            Cooldown (per charge): 6 seconds
            `,
            iconSource: "./images/abilities/roulette_strike.png",
            damageData: {
                base: 500,
                level: [0, 100, 100, 100, 150, 150, 200, 200, 250, 250, 300, 400]
            },
            dotData: {
                base: 200,
                level: [0, 60, 60, 60, 100, 100, 140, 140, 200, 200, 300, 400]
            },
            charges: 3,
            lastingTime: 1e3,
            reload: 6e3
        }],
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#fc0072",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Magenta Circle",
        speed: 0.0016,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0004],
        scale: 65,
        fieldOfViewMulti: 1.6,
        desc: `
        Making shapes go "boom" is what this shape does very well.
        <br><br>
        Recommended Equipment: x4 Scald / x4 Shatter / x4 Labrys
        `,
        healthData: {
            base: 75e3,
            level: [0, 14e3, 14e3, 15e3, 16e3, 16e3, 16e3, 17e3, 17e3, 18e3, 18e3, 20e3].map(e => e / 2)
        },
        abilities: [{
            name: "Clear Sky",
            desc: `
            <span style="font-width: bolder; color: #fff;">Clear Sky</span>
            The shape flies up, ignore all buildings when moving. The shape, upon activation of the ability, also activates built-in weapons that emit blast effect and a purple shield. Damage done to the purple shield will enchance the built-in weapons.<br><br>
            Duration: 8 seconds<br>
            Cooldown: 6 seconds
            `,
            iconSource: "./images/abilities/clear_sky.png",
            damageData: {
                base: 220,
                level: [0, 30, 30, 30, 45, 45, 60, 60, 75, 120, 140, 200]
            },
            projPerShot: 1,
            fireRate: 100,
            effectIncreaseData: {
                base: .02,
                effect: "blast",
                level: [0, .01, .01, .01, .01, .02, .02, .02, .02, .03, .04, .05]
            },
            lastingTime: 8e3,
            reload: 12e3
        }],
        hardpoints: {
            light: 4,
            heavy: 0
        },
        color: "#ff00ff",
        moduleHardpoints: 3,
        costParts: true
    }, {
        dontSell: true,
        tier: 4,
        name: "Gray Pentagon",
        speed: 0.001,
        indexRole: 0,
        speedLevel: [0, 0, 0, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001],
        scale: 97,
        fieldOfViewMulti: 1.9,
        hullIntegrity: .25,
        desc: `
        Ultimate tank-fighter with physical shields mounted around the shape.
        Gray Pentagon can travel long distances and force enemies into a close-ranged brawl.
        Armored heavily, this is a trophy for any player.
        <br><br>
        <strong>Physical Shields</strong> are physical shields that
        are attached physically to the shapes,
        thus making them unable to be disabled (negatively).
        They can be bypassed only by aoe effect weapons and abilities.
        Projectiles characterized as "normal" will do x2 damage to the shield.
        <br><br>
        All of the health of the shields are split equally,
        but the one amounted on front of the shape. The
        durability of that shield is half of the total.
        <br><br>
        Recommended Equipment: x1 Brisant + x2 Shatter
        `,
        healthData: {
            base: 78000,
            level: [0, 9850, 16302, 16302, 17846, 17846, 17846, 19310, 19310, 19310, 20805, 22242]
        },
        shieldData: {
            type: "normal",
            base: 671287 * 6,
            amountOfShields: 5,
            level: [0, 33600, 33600, 33600, 33600, 44753, 44753, 44753, 44753, 89505, 89505, 89505].map(e => e * 6),
            regen: 0
        },
        abilities: [{
            name: "Castling",
            desc: `
            <span style="font-width: bolder; color: #fff;">Castling</span>
            The ability starts by popping of all active shields and stopping the shape from moving. The shape will regenerate health for each popped shield. The shape soon takes off into the sky and regains all its physcial shields in 1 second before waiting another 2 seconds. After 2 seconds the shape starts moving in a selected direction. The 2 second timer and the movement can be skipped at will by another activation of the shape's ability. The shape lastly starts emiting waves that deal AoE damage.<br><br>
            Duration: 12 seconds<br>
            Healing (per shield): 5%<br>
            Gray Damage Healing (% of total): 15%<br>
            Ability Range: 800PX<br>
            Cooldown: 12 seconds
            `,
            damageData: {
                base: 900,
                level: [0, 125, 125, 125, 125, 125, 250, 250, 250, 250, 250, 500]
            },
            abilityDefensePointsData: {
                base: 25,
                level: [0, 6.25, 6.25, 6.25, 6.25, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 25]
            },
            iconSource: "./images/abilities/castling.png",
            lastingTime: 12e3,
            reload: 12e3
        }],
        builtInDefensePoints: 50,
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#808080",
        moduleHardpoints: 4,
        costParts: true
    }, {
        tier: 2,
        name: "Red Orange Circle",
        speed: 0.002,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0003, 0.0004],
        scale: 60,
        indexRole: 0,
        fieldOfViewMulti: 1.45,
        desc: `
        Fortified with an formidable defense mechanism,
        the Red Orange Circle exhibits a unique defensive prowess.
        When its extraordinary ability is activated,
        adversaries are deterred from unleashing their firepower,
        as a significant portion of the damage is not only absorbed
        but also skillfully redirected back towards the assailant.
        This distinctive shape becomes a formidable deterrent,
        discouraging foes from engaging in direct confrontation and turning
        their own aggression against them.
        `,
        healthData: {
            base: 67e3,
            level: [0, 4e3, 4e3, 5e3, 5e3, 5e3, 5e3, 6e3, 6e3, 6e3, 8e3, 10e3],
        },
        abilities: [{
            name: "Reflector",
            desc: `
            <span style="font-width: bolder; color: #fff;">Reflector</span>
            The shape activates its powerful defense system.<br><br>
            Duration: Based on shape level<br>
            Reflector Blocked: based on shape level<br>
            Reflector Returned: 50%<br>
            Cooldown: 8 seconds
            `,
            defensePointToReflector: true,
            abilityDefensePointsData: {
                base: 100,
                level: [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
            },
            lastingTimeData: {
                base: 5e3,
                level: [0, 100, 100, 100, 100, 100, 200, 200, 200, 200, 200, 200]
            },
            iconSource: "./images/modules/heavy_armor_plating.png",
            reload: 8e3
        }],
        hardpoints: {
            light: 4,
            heavy: 0
        },
        color: "#FF4500",
        moduleHardpoints: 2,
        costParts: true
    }, {
        dontSell: true,
        tier: 3,
        name: "Brown Pentagon",
        speed: 0.0032,
        indexRole: 0,
        speedLevel: [0, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0004],
        scale: 75,
        fieldOfViewMulti: 1.65,
        desc: `
        A well protected shape that can swtich between modes to increase its mobility or defense.
        `,
        healthData: {
            base: 99e3,
            level: [0, 4e3, 6e3, 6e3, 9e3, 11e3, 11e3, 11e3, 11e3, 11e3, 14e3, 14e3],
        },
        abilities: [{
            name: "Shapeshift",
            desc: `
            <span style="font-width: bolder; color: #fff;">Shapeshift</span> The shape, upon activating the ability, switches between modes.<br><br>
            <span style="font-width: bolder; color: #fff;">Travel Mode</span>: Robot activates its energy shield, drops its 2 heavy weapons, and moves faster.<br><br>
            <span style="font-width: bolder; color: #fff;">Tank Mode</span>: Robot disables its energy shield, activates its 2 heavy weapons, moves slower, and activates a defense system. During Tank Mode, the energy shield regens faster (1000%).<br><br>
            Default Mode: Travel Mode<br>
            Cooldown: 1 second
            `,
            iconSource: "./images/abilities/shapeshift.png",
            abilityDefensePointsData: {
                base: 100,
                level: [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
            },
            reload: 1e3
        }],
        shieldData: {
            type: "yellow",
            base: 47e3,
            level: [0, 400, 400, 800, 800, 800, 800, 1e3, 1e3, 2e3, 4e3, 8e3],
            regen: 0.05
        },
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#964b00",
        moduleHardpoints: 3,
        costParts: true
    }, {
        dontSell: true,
        tier: 3,
        name: "Gray Heptagon",
        speed: 0.0012,
        indexRole: 2,
        speedLevel: [0, 0.00005, 0.00005, 0.00005, 0.00005, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001],
        scale: 55,
        fieldOfViewMulti: 1.15,
        desc: `
        The Heptagon Industry's very own "flying dragon". This shape is able to stay in the air,
        for as long as it wants, using the same mechanic as shapeshifters.<br><br>
        Recommended Equipment: x4 Flux / x4 Nucleon / x4 Veyron / x4 Reaper
        `,
        healthData: {
            base: 65e3,
            level: [0, 4e3, 4e3, 4e3, 4e3, 6e3, 6e3, 6e3, 6e3, 9e3, 9e3, 11e3],
        },
        abilities: [{
            name: "Shapeshift",
            desc: `
            <span style="font-width: bolder; color: #fff;">Shapeshift</span> The shape, upon activating its ability, switches between modes.<br><br>
            <span style="font-width: bolder; color: #fff;">Ground Mode</span>: During this mode, the shape has increased defense system and able to shoot all its weapons.<br><br>
            <span style="font-width: bolder; color: #fff;">Flight Mode</span>: During this mode, the shape takes off and flies upwards, ignoring all buildings when flying. 2 of its heavy weapons are disabled, a built-in weapon and a purple shield is activated. As the purple shield takes damage, it enchances the built-in weapon of the shape.<br><br>
            Purple Shield Duration: 5 seconds<br>
            Cooldown: 5 seconds
            `,
            iconSource: "./images/abilities/shapeshift.png",
            damageData: {
                base: 480,
                level: [0, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40]
            },
            reload: 5e3
        }],
        hardpoints: {
            light: 0,
            heavy: 4
        },
        color: "#808080",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 0,
        name: "Dark Blue Circle",
        speed: 0.002,
        indexRole: 1,
        speedLevel: [0, 0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0.0001, 0.0002, 0.0002, 0.0004],
        scale: 60,
        fieldOfViewMulti: 2,
        desc: `
        Equipped with a heavy weapon slot. Fast and nimble sniper.<br><br>
        Recommended Equipment: x1 Destroyer / x1 Shocker
        `,
        healthData: {
            base: 50e3,
            level: [0, 2e3, 2e3, 4e3, 4e3, 6e3, 6e3, 6e3, 6e3, 6e3, 8e3, 12e3],
        },
        hardpoints: {
            light: 0,
            heavy: 1
        },
        color: "#00008B",
        moduleHardpoints: 0,
        cost: {
            sliver: 75e3,
            gold: 0
        }
    }, {
        tier: 4,
        name: "Cyan Hexagon",
        speed: 0.0012,
        indexRole: 1,
        speedLevel: [0, 0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0002, 0.0002, 0.0002, 0.0002],
        scale: 75,
        fieldOfViewMulti: 1.45,
        desc: `
        Hexagon Industry's very first tier 5.
        It can teleport in turrets and extra armor for support.
        <br><br>
        Recommended Equipment: x2 Cestus / x2 Veyron / x2 Brisant
        `,
        healthData: {
            base: 126e3,
            level: [0, 10e3, 10e3, 10e3, 15e3, 15e3, 15e3, 15e3, 15e3, 15e3, 20e3, 30e3],
        },
        abilities: [{
            name: "Blink Support",
            desc: `
            <span style="font-width: bolder; color: #fff;">Blink Support</span>
            Upon activation, the shape teleports in extra armor, and 2 autonomous turrets for support.<br>
            One of the turrets deal most of the damage, while the other emits negative effects at enemies.<br><br>
            Duration of Turrets: x2 the duration of the ability<br>
            Duration: Based on shape level<br>
            Max Charges: 2<br>
            Cooldown (per charge): 12 seconds
            `,
            abilityHealthMultiData: {
                base: 1.2,
                level: [0, 0.05, 0.05, 0.05, 0.05, 0.1, 0.1, 0.1, 0.1, 0.15, 0.15, 0.2]
            },
            abilityDefensePointsData: {
                base: 5,
                level: [0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 7]
            },
            damageData: {
                base: 80,
                level: [0, 20, 20, 40, 40, 40, 50, 50, 50, 60, 80, 90]
            },
            lastingTimeData: {
                base: 6e3,
                level: [0, 50, 50, 100, 100, 150, 150, 200, 200, 300, 300, 400]
            },
            charges: 2,
            iconSource: "./images/abilities/shield_t.png",
            reload: 12e3
        }],
        hardpoints: {
            light: 0,
            heavy: 2
        },
        color: "#00ffff",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Cyan Heptagon",
        speed: 0.0012,
        indexRole: 1,
        speedLevel: [0, 0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0002, 0.0002, 0.0002, 0.0002],
        scale: 85,
        fieldOfViewMulti: 1.55,
        desc: `
        Behold Heptagon's remarkable creation – adept at seamlessly vanishing from enemy radar. Witness its prowess: now you see it, now you don't, a testament to cutting-edge technology in action.
        `,
        healthData: {
            base: 100e3,
            level: [0, 8000, 12000, 12000, 12800, 12800, 12800, 14400, 14400, 14400, 16000, 24000]
        },
        abilities: [{
            name: "Matrix",
            desc: `
            <span style="font-width: bolder; color: #fff;">Matrix</span>
            The shape enters steath, and activates a gravity field around the shape. Any enemy that touches the shape, would take damage during the ability. After the ability ends, it emits a pulse that suppresses enemy weapon damage.<br><br>
            Gravity Field Range: 400PX<br>
            Suppression Range: 800PX<br>
            Damage Reduction (Suppression Power): 90%<br>
            Duration: 6 seconds<br>
            Cooldown: 8 seconds
            `,
            iconSource: "./images/abilities/matrix.png",
            damageData: {
                base: 2550,
                level: [0, 120, 120, 180, 180, 240, 240, 300, 300, 360, 420, 540],
            },
            lastingTime: 6e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 3,
            heavy: 1
        },
        color: "#00ffff",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "White Heptagon",
        speed: 0.0012,
        indexRole: 0,
        speedLevel: [0, 0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0002, 0.0002, 0.0002, 0.0002],
        scale: 100,
        fieldOfViewMulti: 1.8,
        desc: `
        After Heptagon Industry's lastest T5 shape, the Cyan Heptagon, they've wanted to make another one.
        This time, Heptagon Industry (HI), created a poweful close ranged brawler that can take advantage of the Industry's newest advancement, suppression.
        The shape, like other T5 brawlers, take less gray damage from all sources (25%).<br><br>
        Suppression, a effect that decreases the weapon damage output for enemies for a selected period of time. The damage decrease is accumulative and will never be permanent.<br><br>
        Recommended Equipment: x2 Maha Vajra + x1 Vajra
        `,
        healthData: {
            base: 133900,
            level: [0, 5200, 5200, 6500, 6500, 6500, 9100, 9100, 11700, 14300, 22100, 32500]
        },
        hullIntegrity: .25,
        healingMulti: 1.5,
        abilities: [{
            name: "Ultimate Reflecting Dash",
            desc: `
            <span style="font-width: bolder; color: #fff;">Ultimate Reflecting Dash</span>
            The shape leaps forward and activates a powerful defense system.
            During the movement, the player can activate the ability a second time to force end the "leap".
            After the movement, the player becomes unable to move and it suppresses enemies that shoot it.<br><br>
            When enemies reach the max-suppression limit, it'll instead repenish all effect stacks instead of adding new ones.<br><br>
            Suppression Limit: 5<br>
            Suppression Power: depends on shape level<br>
            Reflector Blocked: depends on shape level<br>
            Reflector Returned: 75%<br>
            Duration: 8 seconds<br>
            Cooldown: 12 seconds
            `,
            iconSource: "./images/abilities/ultimate_reflecting_dash.png",
            suppressionPowerData: {
                base: .05,
                level: [0, .01, .01, .01, .01, .01, .02, .02, .02, .02, .02, .05]
            },
            defensePointToReflector: true,
            abilityDefensePointsData: {
                base: 25,
                level: [0, 25, 0, 25, 0, 25, 0, 25, 0, 25, 25, 25]
            },
            lastingTime: 8e3,
            reload: 12e3
        }],
        hardpoints: {
            light: 1,
            heavy: 2
        },
        color: "#fff",
        moduleHardpoints: 4,
        costParts: true
    }, {
        tier: 2,
        name: "Green Triangle",
        speed: 0.0018,
        indexRole: 3,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002],
        scale: 55,
        fieldOfViewMulti: 1.25,
        desc: `
        Healing technology is usually self-centered around self-healing, but this new shaope ascends it to new heights.
        By transfering nano-bots to allies, it allows you to actively heal your teammates and keep them alive in battle.
        `,
        healthData: {
            base: 79e3,
            level: [0, 3e3, 3e3, 4e3, 4e3, 4e3, 5e3, 5e3, 5e3, 9e3, 11e3, 13e3],
        },
        abilities: [{
            name: "Support",
            desc: `
            <span style="font-width: bolder; color: #fff;">Support</span> The shape speeds up and gets increased defense points. During the ability, it emits waves of healing that repair all allies and itself.<br><br>
            Defense Points: 150 (60% Resistance)<br>
            Speed Increase: 75%<br>
            Healing Pulses: 16<br>
            Pulse Range: 400PX<br>
            Ability Duration: 8 seconds<br>
            Cooldown: 12 seconds
            `,
            iconSource: "./images/abilities/self_heal.png",
            healingPowerData: {
                base: 5e3,
                level: [0, 1e3, 1e3, 1e3, 2e3, 2e3, 2e3, 2e3, 3e3, 3e3, 3e3, 4e3]
            },
            lastingTime: 8e3,
            reload: 12e3
        }],
        hardpoints: {
            light: 3,
            heavy: 0
        },
        color: "#0f0",
        moduleHardpoints: 2,
        costParts: true
    }, {
        tier: 4,
        name: "Purple Heptagon",
        speed: 0.001,
        indexRole: 1,
        speedLevel: [0, 0, 0, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0, 0.0004],
        scale: 125,
        fieldOfViewMulti: 3.25,
        baseDamageIncrease: .25,
        desc: `
        Heptagon Industries promotes all sorts of playstyles, but the playstyle that the Industry prefers the most is sniping.
        Purple Heptagon is a long ranged sniper that can fire a powerful built-in weapon charge that deals damage based on the max health of enemies.<br><br>
        Recommened Equipment: x2 Fulgur + x2 Tonans
        `,
        healthData: {
            base: 75e3,
            level: [0, 6000, 6000, 6000, 6000, 6000, 8000, 8000, 8000, 12500, 15000, 20000]
        },
        abilities: [{
            name: "Long Shot",
            desc: `
            <span style="font-width: bolder; color: #fff;">Long Shot</span> The shape activates a built-in weapon that goes though walls and deals damage based on the enemies' max health.<br><br>
            Built-In Weapon Defense Mitigation: 100%<br>
            Ability Range: 3800<br>
            Damage Percentage: 10%<br>
            Projectiles: 1<br>
            Duration: 1 seconds<br>
            Fire Rate: 0 ms (Instant)<br>
            Cooldown: 6 seconds
            `,
            iconSource: "./images/weapons/shocker.png",
            lastingTime: 1e3,
            reload: 6e3
        }],
        hardpoints: {
            light: 2,
            heavy: 2
        },
        color: "#800080",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Light Blue Heptagon",
        speed: 0.0012,
        indexRole: 2,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002],
        scale: 95,
        fieldOfViewMulti: 1.5,
        desc: `
        Another flying sniper. This shape takes firepower to the next level, it "teleports" in new weapons everytime it flies up. Gaining additional damage during the flight, it can snipe all enemies and not take any long term damage.<br><br>
        Recommended Equipment: x2 Discordia + x3 Tumultus / x2 Fulgur + x3 Tonans
        `,
        healthData: {
            base: 75e3,
            level: [0, 13e3, 13e3, 13e3, 13e3, 13e3, 13e3, 13e3, 13e3, 13e3, 13e3, 13e3],
        },
        abilities: [{
            name: "Cannonier",
            desc: `
            <span style="font-width: bolder; color: #fff;">Cannonier</span> The shape takes flight and activates its disabled two heavy weapons. It gains temporary fixed health, increased movement speed, and deals increased damage.<br><br>
            You can press the ability while it is active to dash. After all dashes are used up, activating the ability again will force end it. You will need to wait at least .5 second to use the first dash, and an .25 second delay for the rest.<br><br>
            Dash Amount: 2<br> 
            Damage Increase: 50%<br>
            Speed Increase: 100%<br>
            Additional Weapons Unlocked: 2<br>
            Duration: 10 seconds<br>
            Cooldown: 12 seconds
            `,
            additionalHealthData: {
                base: 137500,
                level: [0, 11250, 11250, 11250, 11250, 11250, 11250, 11250, 22500, 22500, 22500, 22500]
            },
            iconSource: "./images/abilities/shapeshift.png",
            lastingTime: 10e3,
            reload: 12e3
        }],
        hardpoints: {
            light: 2,
            heavy: 3
        },
        color: "#add8e6",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 3,
        name: "Dark Brown Pentagon",
        speed: 0.002,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002, 0.0004],
        scale: 65,
        fieldOfViewMulti: 1.6,
        desc: `
        A shape armored with a powerful energy shield and a portable weapon that can be deployed anywhere in its field of view. Dark Brown Pentagon can suppress or demotivate enemies from going into areas.<br><br>
        Recommended Equipment: x3 Talon / x3 Tumultus
        `,
        healthData: {
            base: 69e3,
            level: [0, 2e3, 2e3, 3e3, 3e3, 4e3, 4e3, 4e3, 5e3, 6e3, 8e3, 10e3],
        },
        abilities: [{
            name: "Remote Assault",
            desc: `
            <span style="font-width: bolder; color: #fff;">Remote Assault</span> The shape deploys its built-in turret to where the cursor is at.<br><br>
            When the turret is deployed, it applies slowdown effect to the enemy.<br><br>
            Turret Fire Rate: 100 ms<br>
            Turret Fire Rate (undeployed): 150 ms<br>
            Turret Range: 2300 PX<br>
            Duration: 15 seconds<br>
            Movement Speed Increase: 100%<br>
            Cooldown: 6 seconds
            `,
            iconSource: "./images/weapons/landslide.png",
            damageData: {
                base: 600,
                level: [0, 30, 30, 30, 60, 60, 60, 60, 60, 120, 120, 120]
            },
            lastingTime: 15e3,
            reload: 6e3
        }],
        shieldData: {
            type: "yellow",
            base: 45500,
            level: [0, 650, 650, 1300, 1300, 1300, 1300, 2600, 2600, 3900, 5200, 10400],
            regen: 0.15
        },
        hardpoints: {
            light: 0,
            heavy: 3
        },
        color: "#452200",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Magenta Hexagon",
        speed: 0.001,
        indexRole: 0,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002],
        scale: 95,
        fieldOfViewMulti: 1.6,
        desc: `
        Next generation of the Yellow Hexagon. Hexagon Industries has improved their tech once again. This shape does everything Yellow Hexagon can, but even better!<br><br>
        Recommended Equipment: x2 Vajra + x1 Maha Vajra / x2 Shatter + x1 Brisant
        `,
        builtInDefensePoints: 50,
        healthData: {
            base: 65625,
            level: [0, 3125, 3125, 6250, 6250, 6250, 9375, 12500, 12500, 18750, 25000, 50000]
        },
        healingMulti: 1.25,
        abilities: [{
            name: "Phase Shift",
            desc: `
            <span style="font-width: bolder; color: #fff;">Phase Shift</span> The shape activates a powerful matrix that allows it not to take any damage. Negative effects are all nullfied during the ability.<br><br>
            Also upon activation, the shape bonds with the nearest enemy, slowing them down. After the bond ends, it does percentage based damage to the enemy.<br><br>
            Damage Percentage: 10%<br>
            Bond Duration: 6 seconds<br>
            Bond Range: 1500 PX<br>
            Healing: 200% of damage done with bond<br>
            Duration: 2 seconds<br>
            Max Charges: 2<br>
            Speed Increase: 80%<br>
            Cooldown (per charge): 8 seconds
            `,
            iconSource: "./images/abilities/phase_shift.png",
            charges: 2,
            lastingTime: 2e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#ff00ff",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Dark Green Pentagon",
        speed: 0.0018,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.8,
        desc: ``,
        healthData: {
            base: 75e3,
            level: [0, 5e3, 5e3, 5e3, 5e3, 10e3, 10e3, 10e3, 15e3, 15e3, 20e3, 50e3],
        },
        abilities: [{
            name: "Clain Blink",
            desc: `
            <span style="font-width: bolder; color: #fff;">Clain Blink</span> The shape sets a translocator on its current location, it then teleports to the chosen location. It can teleport up to 4 times and it gains a temporary shield for every teleport. After all charges are used up, another activation will teleport you to the translocator. Regardless, after the ability ends, you'll teleport back to the locator.<br><br>
            Delay per teleportion: 3 seconds<br>
            Teleportation Charges (not counting initial teleport): 3<br>
            Max Teleportation Range: 2000PX<br>
            Duration: 30 seconds<br>
            Cooldown: 14 seconds
            `,
            iconSource: "./images/abilities/clain_blink.png",
            shieldHpData: {
                base: 78750,
                level: [0, 2250, 2250, 2250, 4500, 4500, 4500, 4500, 9000, 9000, 9000, 18000]
            },
            lastingTime: 30e3,
            reload: 14e3
        }],
        hardpoints: {
            light: 1,
            heavy: 3
        },
        color: "#009100",
        moduleHardpoints: 3,
        costParts: true
    }, {
        dontSell: true,
        tier: 4,
        name: "Dark Tan Circle",
        speed: 0.002,
        indexRole: 2,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0004],
        scale: 65,
        fieldOfViewMulti: 1.8,
        desc: `
        The suppose it next generation of an already T5 shape, Cyan Hexagon.
        The shape can gain extra health boosts that makes it more tanky than any other shape of
        it's class.<br><br>
        Recommended Equipment: x2 Subduer / x2 Sorrow / x2 Veyron
        `,
        healthData: {
            base: 57000 * 1.75,
            level: [0, 3750, 7500, 7500, 7500, 7500, 11250, 11250, 11250, 18750, 18750, 18750].map(e => e * 1.75)
        },
        builtInDefensePoints: 50,
        abilities: [{
            name: "Blink Assault",
            desc: `
            <span style="font-width: bolder; color: #fff;">Blink Assault</span> The shape teleports in extra armor and turrets. It speeds up as well.<br><br>
            The ability starts to cooldown when the extra armor is destroyed, but the turrets will still remain.<br><br>
            Bonus Health: X1.5 of max health<br>
            Speed Increase: 75%<br>
            Turret Range: 2000 PX<br>
            Turret Rate of Fire: 75 ms<br>
            Turret Amount: 2<br>
            Turret Duration: 8 seconds<br>
            Ability Duration: 8 seconds<br>
            Cooldown: 8 seconds
            `,
            damageData: {
                base: 750 * 1.75,
                level: [0, 25, 38, 50, 63, 75, 88, 100, 113, 113, 113, 125].map(e => e * 1.75)
            },
            iconSource: "./images/abilities/shield_t.png",
            lastingTime: 8e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 0,
            heavy: 2
        },
        color: "#7a6951",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Red Octagon",
        speed: 0.0014,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0002, 0.0002, 0, 0.0002, 0.0002, 0.0002],
        scale: 75,
        fieldOfViewMulti: 1.65,
        desc: `
        Sharing similar with Blue Heptagon, this shape benefits when enemies go inside it's "domain". The shape is well built to withstand fights and can carry 6 weapons at the same time.<br><br>
        Recommended Equipment: x2 Sorrow + x4 Grief / x2 Veyron + x4 Evora / x2 Maha Vajra + x4 Vajra
        `,
        healthData: {
            base: 97500,
            level: [0, 6500, 6500, 6500, 6500, 9750, 9750, 9750, 16250, 16250, 19500, 22750]
        },
        hullIntegrity: .25,
        abilities: [{
            name: "Dismantle",
            desc: `
            <span style="font-width: bolder; color: #fff;">Dismantle</span> summons a area that any shape can enter. All enemy shapes in the area will take a sure hit damage effect constantly. Projectiles that are not shot inside the "domain" are converted into red bubbles and all turrets will be dismantled automatically from the area.<br><br>
            When the area deals damage, it repairs durability of its owner.<br><br>
            When the area ends, the owner of it gains defense points for every enemy in the area.<br><br>
            Area Radius: 600 PX<br>
            Sure Hit Effect Fire Rate: 125 ms<br>
            Duration of area: based on shape level<br>
            Cooldown: 16 seconds
            `,
            damageData: {
                base: 1250,
                level: [0, 113, 113, 138, 138, 138, 213, 213, 250, 250, 313, 388]
            },
            iconSource: "./images/abilities/dismantle.png",
            lastingTimeData: {
                base: 5e3,
                level: [0, 250, 250, 250, 250, 250, 250, 500, 500, 500, 750, 1250]
            },
            reload: 16e3
        }],
        hardpoints: {
            light: 4,
            heavy: 2
        },
        color: "#f00",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 3,
        name: "Light Blue Triangle",
        speed: 0.0012,
        indexRole: 3,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0.0001, 0, 0.0006],
        scale: 75,
        fieldOfViewMulti: 2,
        desc: `
        Light Blue Triangle can teleport support turrets to allies. This allows the shape to actively support the team, while not being destroyed in the process. Since supporters are very important in the battle field, the Triangle Industries have made it so that this shape is mobile and durable.<br><br>
        Recommended Equipment: x3 Vortex / x3 Evora / x3 Jaw
        `,
        healthData: {
            base: 70e3,
            level: [0, 4e3, 4e3, 4e3, 6e3, 6e3, 8e3, 8e3, 10e3, 10e3, 10e3, 12e3],
        },
        abilities: [{
            name: "Remote Repair",
            desc: `
            <span style="font-width: bolder; color: #fff;">Remote Repair</span> builds a turret that repairs all allies in its radius.<br><br>
            Charges: 3<br>
            Repair Radius: 600 PX<br>
            Repair Rate: 250 ms<br>
            Gray Damage Repair: 15% of healing<br>
            Duration: 20 seconds<br>
            Cooldown per charge: 15 seconds<br>
            `,
            iconSource: "./images/abilities/self_heal.png",
            healingPowerData: {
                base: 3e3,
                level: [0, 500, 500, 1e3, 1500, 2e3, 2500, 2500, 2500, 2500, 2500, 2500]
            },
            lastingTime: 1e3,
            charges: 3,
            reload: 15e3
        }],
        hardpoints: {
            light: 3,
            heavy: 0
        },
        color: "#add8e6",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Purple Pentagon",
        speed: 0.001,
        indexRole: 0,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0.0002],
        scale: 85,
        fieldOfViewMulti: 1.65,
        desc: `
        The smartest engineering minds at Pentagon have taken the word protection to the next level with this shape. This shape isn't afraid to take on the heavy fire power of enemies. It can place a purple shield that blocks incoming damage and extends its durability.<br><br>
        Recommended Equipment: x1 Pyro + x2 Inferno
        `,
        healthData: {
            base: 50e3,
            level: [0, 5e3, 5e3, 10e3, 10e3, 15e3, 15e3, 25e3, 25e3, 25e3, 30e3, 35e3],
        },
        builtInDefensePoints: 50,
        abilities: [{
            name: "Barrier Field",
            desc: `
            <span style="font-width: bolder; color: #fff;">Barrier Field</span> The shape activates a purple shield that is streamlined to protect the front of the shape. Any and all damage dealt to the shield will increase the durability of the shape.<br><br>
            Duration: 6 seconds<br>
            Shield Cover: 225 Degrees<br>
            Cooldown Time: 14 seconds
            `,
            durabilityLimitData: {
                base: 75e3,
                level: [0, 7500, 7500, 7500, 7500, 7500, 18750, 18750, 18750, 18750, 18750, 18750]
            },
            iconSource: "./images/abilities/shield_t.png",
            lastingTime: 6e3,
            reload: 14e3
        }],
        hardpoints: {
            light: 1,
            heavy: 2
        },
        color: "#800080",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 3,
        name: "Yellow Heptagon",
        speed: 0.0012,
        indexRole: 2,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002, 0.0004],
        scale: 50,
        fieldOfViewMulti: 1.25,
        desc: `
        A real predator, this shape can hunt down enemies with its quick movement speed and can execute them at low durability.<br><br>
        <strong style="color: #fff">Forcefield</strong> Another type of defense which reduces damage taken. It cannot be mitigated by defense mitigation effect weapon but may be reduced. Forcefield is based on durability but not considered as a shield.<br><br>
        Damage Reduction: 90% (MAX) to 75% (MIN)<br>
        Durability: 300,000<br>
        Regeneration Time: 6 seconds
        `,
        healthData: {
            base: 65e3,
            level: [0, 3e3, 3e3, 5e3, 5e3, 5e3, 5e3, 5e3, 6e3, 7e3, 8e3, 10e3],
        },
        abilities: [{
            name: "Ferocity",
            desc: `
            <strong style="color: #fff">Ferocity</strong> The shape enter stealth and moves faster. A built-in weapon is activated, shots fired from this weapon can instantly kill enemies at a threshold.<br><br>
            Duration: 4 seconds<br>
            Speed Increase: 50%<br>
            Fire Rate: .5 seconds<br>
            Cooldown: 8 seconds
            `,
            iconSource: "./images/weapons/reaper.png",
            executionThresholdData: {
                base: .05,
                level: [0, .01, .01, .01, .01, .01, .02, .03, .03, .03, .04, .05]
            },
            damageData: {
                base: 1e3,
                level: [0, 250, 250, 250, 500, 500, 500, 500, 500, 1e3, 1e3, 1e3]
            },
            lastingTime: 4e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 0,
            heavy: 2
        },
        color: "#ffff00",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Orange Heptagon",
        speed: 0.0004,
        indexRole: 0,
        speedLevel: [0, 0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0.0001],
        scale: 95,
        fieldOfViewMulti: 2,
        desc: `
        Legendary Tank, walking into enemy fire with 100% confidence is this shape's special ability. Orange Heptagon can accumulate block effects that prevent it from taking any damage. The only downside: it's speed.
        <br><br>
        Recommended Equipment: x5 Brisant / x5 Inferno / x5 Maha Vajra
        `,
        healthData: {
            base: 125000,
            level: [0, 7500, 7500, 10000, 10000, 10000, 10000, 12500, 12500, 17500, 17500, 22500]
        },
        hardpoints: {
            light: 0,
            heavy: 3
        },
        abilities: [{
            name: "Blocking Matrix",
            desc: `
            <span style="font-width: bolder; color: #fff;">Blocking Matrix</span> The shape gains permanent effects of Block.<br><br>
            <span style="font-width: bolder; color: #fff;">Block</span> This effect blocks/ignores damage per stack of effect.<br><br>
            Cooldown: 12 seconds
            `,
            iconSource: "./images/icons/block.png",
            effectAccumulationData: {
                base: 10,
                level: [0, 5, 5, 5, 5, 5, 10, 10, 10, 10, 10, 15]
            },
            reload: 12e3
        }],
        builtInDefensePoints: 100,
        color: "#ffa500",
        moduleHardpoints: 4,
        costParts: true
    }, {
        tier: 1,
        name: "Pinkish-Red Heptagon",
        speed: 0.001,
        indexRole: 2,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0004],
        scale: 60,
        fieldOfViewMulti: 1.55,
        desc: `
        This sniping shape is the pinnacle of Heptagon engineering and can stay in
        flight indefinitely. On the ground, its defence system is enhanced;
        while in flight, its speed is increased and all weapon slots are active.<br><br>
        Recommended Equipment: x2 Reaper + x2 Lance / x2 Shocker + x2 Lance / x2 Glaive + x2 Lance
        `,
        healthData: {
            base: 58e3,
            level: [0, 3e3, 3e3, 6e3, 6e3, 6e3, 6e3, 6e3, 6e3, 9e3, 11e3, 13e3],
        },
        abilities: [{
            name: "Shapeshift",
            desc: `
            <span style="font-width: bolder; color: #fff;">Shapeshift</span> The shape, upon activating the ability, switches between modes.<br><br>
            <span style="font-width: bolder; color: #fff;">Ground Mode</span>: The shape only uses 2 out of its 4 weapons and gains a powerful defense system (+200 defense points).<br><br>
            <span style="font-width: bolder; color: #fff;">Flight Mode</span>: The shape uses all weapons and flies up.<br><br>
            Default Mode: Ground Mode<br>
            Cooldown: 12 second
            `,
            iconSource: "./images/abilities/shapeshift.png",
            reload: 12e3
        }],
        hardpoints: {
            light: 2,
            heavy: 2
        },
        color: "#fc0072",
        moduleHardpoints: 1,
        cost: {
            sliver: 0,
            gold: 1500
        }
    }, {
        tier: 3,
        name: "White Octagon",
        speed: 0.0018,
        indexRole: 1,
        speedLevel: [0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.45,
        desc: `
        Death swoops down on [T5 shapes] upon great wings.
        This shape was specifically created to fight T5.
        The shape activates its weapons in flight,
        striking enemies with a discharge of lasers.<br><br>
        Recommended Equipment: x2 Reaper / x2 Tumultus / x2 Veyron / x2 Flux
        `,
        healthData: {
            base: 78e3,
            level: [0, 3e3, 5e3, 7e3, 7e3, 7e3, 7e3, 8e3, 8e3, 8e3, 8e3, 11e3]
        },
        hardpoints: {
            light: 0,
            heavy: 2
        },
        abilities: [{
            name: "Skyward",
            desc: `
            <strong style="color: #fff">Skyward</strong> The shape takes flight and activites its built-in weapon. The weapon fires in a arc, the target closest to the cursor takes 100% of the damage while the rest only take half. It does 250% damage to T5 and bypasses reflector effects and does a even more damage to Titans (50%).<br><br>
            <strong style="color: #fff">Forcefield</strong> Another type of defense which reduces damage taken. It cannot be mitigated by defense mitigation effect weapon but may be reduced. Forcefield is based on durability but not considered as a shield.<br><br>
            Damage Reduction: 90% (MAX) to 50% (MIN)<br>
            Durability: 100% of Max Health<br>
            Regeneration Time: 10 seconds<br><br>
            Duration: 8 seconds<br>
            Built-in Weapon Range: 2000 PX<br>
            Defense Mitigation: 100%<br>
            Cooldown: 12 seconds
            `,
            damageData: {
                base: 156,
                level: [0, 76, 76, 127, 127, 127, 178, 178, 280, 280, 382, 510]
            },
            iconSource: "./images/abilities/shapeshift.png",
            lastingTime: 8e3,
            reload: 12e3
        }],
        color: "#fff",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Blue Triangle",
        speed: 0.0016,
        indexRole: 3,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0.0001, 0, 0.0006],
        scale: 80,
        fieldOfViewMulti: 2.5,
        desc: `
        A ultimate healer. This shape can bond with itself or its allies to provide defense, healing, and speed boosts. Equipped with decent firepower, this shape can allow you and your allies to be always 100% repaired after battles.<br><br>
        Recommended Equipment: x2 Decay + x1 Blight
        `,
        healthData: {
            base: 100e3,
            level: [0, 10e3, 15e3, 15e3, 20e3, 20e3, 20e3, 20e3, 20e3, 20e3, 25e3, 30e3],
        },
        abilities: [{
            name: "Active Support",
            desc: `
            <span style="font-width: bolder; color: #fff;">Active Support</span> The shape bonds with an ally shape. When bonded, both shapes (if there is any allies) start repairing durability (gray damage as well). After when the bond ends, the bonded shape will gain extra durability for the entire battle.<br><br>
            The shape cannot also bond with itself.<br><br>
            Bond Distance: 2000 PX<br>
            Bond Duration: 12 seconds<br>
            Defense Points Duration (when bonded): 30 seconds<br>
            Speed Increase (to the bonded): 100%<br>
            Gray Durability Repair: 25%<br>
            Extra Durability: 10%<br>
            Charges: 3<br>
            Cooldown (per charge): 12 seconds
            `,
            iconSource: "./images/abilities/self_heal.png",
            healingPercentData: {
                base: 0.095,
                level: [0, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005]
            },
            abilityDefensePointsData: {
                base: 35,
                level: [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 15, 15]
            },
            lastingTime: 2e3,
            charges: 4,
            reload: 14e3
        }],
        hardpoints: {
            light: 1,
            heavy: 2
        },
        color: "#00f",
        moduleHardpoints: 3,
        costParts: true
    }, {
        dontSell: true,
        tier: 3,
        name: "Dark Green Circle",
        speed: 0.0018,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.55,
        desc: ``,
        healthData: {
            base: 75e3,
            level: [0, 2e3, 2e3, 2e3, 5e3, 5e3, 5e3, 10e3, 10e3, 15e3, 15e3, 20e3],
        },
        abilities: [{
            name: "Nuclear Strike",
            desc: `
            <span style="font-width: bolder; color: #fff;">Nuclear Strike</span> Strikes a area with negative effects for a duration.<br><br>
            Duration of Area: 8 second(s)<br>
            Radius of Area: 600 PX<br>
            Effect Duration: 6 second(s)<br>
            Cooldown: 10 second(s)
            `,
            iconSource: "./images/weapons/decay.png",
            damageData: {
                base: 2e3,
                level: [0, 240, 240, 240, 240, 360, 360, 360, 360, 360, 480, 600]
            },
            reload: 10e3
        }],
        hardpoints: {
            light: 0,
            heavy: 3
        },
        color: "#009100",
        moduleHardpoints: 3,
        costParts: true
    }, {
        dontSell: true,
        tier: 4,
        name: "Teal Pentagon",
        speed: 0.0014,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0.0002, 0.0002],
        scale: 95,
        fieldOfViewMulti: 1.8,
        desc: `
        Another sheild dependant shape. This shape takes frontlines with minimal damage takes to its hull.<br><br>
        <strong style="color: #fff">Forcefield</strong> Another type of defense which reduces damage taken. It cannot be mitigated by defense mitigation effect weapon but may be reduced. Forcefield is based on durability but not considered as a shield.<br><br>
        Damage Reduction: 99% (MAX) to 90% (MIN)<br>
        Durability: X2 of Health<br>
        Regeneration Time: 8 seconds<br><br>
        Recommended Equippment: x2 Veyron + x1 Evora / x1 Discordia + x2 Tumultus
        `,
        healthData: {
            base: 62500,
            level: [0, 2500, 5000, 7500, 10000, 12500, 15000, 17500, 17500, 20000, 22500, 25000]
        },
        abilities: [{
            name: "Absorption",
            desc: `
            <span style="font-width: bolder; color: #fff;">Absorption</span> The shape activates 3 built-in weapons and a purple shield. The more damage the shield takes, the stronger the weapons will be (x2.5 max). After the ability ends, the robot heals and gains a yellow shield depending on how much damage the purple shield took.<br><br>
            Duration: 8 second(s)<br>
            Built-in Weapon Ranges: 2000 PX<br>
            Built-in WPN1: Fires energy shells<br>
            Built-in WPN2: Fires rocket shells that emit blast effect<br>
            Built-in WPN3: Fires normal homing shells<br>
            Cooldown: 12 second(s)
            `,
            damageData: {
                base: 170,
                level: [0, 11, 21, 32, 43, 64, 85, 106, 128, 149, 170, 212]
            },
            iconSource: "./images/abilities/absorption.png",
            lastingTime: 8e3,
            reload: 12e3
        }],
        hardpoints: {
            light: 1,
            heavy: 2
        },
        color: "#008080",
        moduleHardpoints: 3,
        costParts: true
    }, {
        dontSell: true,
        dontShow: true,
        tier: 10,
        name: "Polygon",
        speed: 0.002,
        speedLevel: [0, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005],
        scale: 85,
        fieldOfViewMulti: 1.8,
        desc: `
        Polygon has every shape's abilities, taking all the good and leaving out the bad. It adapts to any situation, offering flexibility and strength. With Polygon, every action is at its best, making sure you succeed in any challenge.<br><br>
        This shape increases all mothership charge by 25%.
        `,
        dotResistance: .99,
        revive: 1,
        indexRole: 4,
        builtInDefensePoints: 900,
        healingMulti: 4,
        hullIntegrity: .9,
        healthData: {
            base: 200e3,
            level: [0, 30e3, 30e3, 30e3, 30e3, 30e3, 30e3, 30e3, 30e3, 30e3, 30e3, 30e3],
        },
        hardpoints: {
            light: 2,
            heavy: 2
        },
        color: "#008080",
        moduleHardpoints: 4,
        cost: {
            sliver: 1,
            gold: 1,
            workshopPoints: 1
        }
    }, {
        dontSell: true,
        tier: 4,
        name: "Teal Heptagon",
        speed: 0.002,
        indexRole: 3,
        speedLevel: [0, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0.0002, 0.0002],
        scale: 65,
        fieldOfViewMulti: 1.8,
        desc: `A support shape that allows allies or itself to deal increased damage to targets it chooses. It's main defense system is "Counter Suppression".<br><br>
        Counter suppression suppresses the attacker. The shape gains a new effect stack every 7 seconds (40% suppression power). 
        Recommended Equipment: x3 Talons / x3 Ultimate Destroyer / x3 Decay / x3 Reaper`,
        healthData: {
            base: 75e3,
            level: [0, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 10e3, 10e3, 10e3, 10e3, 15e3]
        },
        abilities: [{
            name: "Track",
            desc: `
            <span style="font-width: bolder; color: #fff;">Track</span> Marks an enemy to "death". The marked enemy takes increased damage. Anyone who takes part in killing the marked shape, gains benefits to their damage, defense, and speed.<br><br>
            Max Hunt Stacks: 5<br>
            Speed Bonus: 15%<br>
            Damage Bonus: 15%<br>
            Repair Power: 15%<br>
            Gray Damage Repair (% of healing): 100%<br>
            Defense Points: based on shape level<br><br>
            All benefits are all permanent.
            `,
            iconSource: "./images/weapons/reaper.png",
            deathmarkData: {
                base: .1,
                level: [0, .02, .02, .04, .04, .04, .04, .04, .04, .06, .08, .08],
            },
            abilityDefensePointsData: {
                base: 20,
                level: [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
            },
            lastingTime: 2e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 0,
            heavy: 3
        },
        color: "#008080",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 0,
        name: "Kid",
        industryName: "Circle",
        indexRole: 0,
        speed: 0.0008,
        speedLevel: [0, 0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001],
        scale: 125,
        fieldOfViewMulti: 3.2,
        desc: `Multi-purpose titan. When in danger, it can bring out it's heavy weapon and enhance its defense systems.<br><br>Recommended Equipment: x1 Vengenance + x2 Retaliator`,
        builtInDefensePointsData: {
            base: 25,
            level: [0, 5, 0, 5, 0, 5, 0, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
        },
        healthData: {
            base: 468600,
            level: [0, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 15e3, 15e3, 15e3, 15e3, 15e3, 15e3]
        },
        abilities: [{
            name: "Full Action",
            desc: `
            <span style="font-width: bolder; color: #fff;">Full Action</span>
            The shape activates it's heavy weapon and increases it's defense system.<br><br>
            Duration: 8 seconds<br>
            Cooldown: 16 seconds
            `,
            iconSource: "./images/abilities/full_action.png",
            abilityDefensePointsData: {
                base: 75,
                level: [0, 5, 0, 5, 0, 5, 0, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
            },
            lastingTime: 8e3,
            reload: 16e3
        }, {
            name: "Stove",
            desc: `
            <span style="font-width: bolder; color: #fff;">Stove</span>
            The shape activates a AoE damage area around the shape.<br><br>
            Duration: 4 seconds<br>
            AoE Radius: 800 PX<br>
            Cooldown: 8 seconds
            `,
            iconSource: "./images/weapons/cinder.png",
            damageData: {
                base: 2e3,
                level: [0, 50, 65, 85, 95, 100, 105, 105, 110, 115, 115, 115, 115, 135, 135, 135, 135, 135, 135, 135, 135, 135, 145, 155, 165]
            },
            lastingTime: 4e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#808080",
        titan: true,
        moduleHardpoints: 2,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 15e3
        }
    }, {
        tier: 1,
        name: "Arthur",
        industryName: "Pentagon",
        indexRole: 0,
        speed: 0.0005,
        speedLevel: [0, 0, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0, 0, 0.0001, 0, 0, 0, 0.0001, 0.0001],
        scale: 125,
        fieldOfViewMulti: 3.2,
        desc: `
        Slow and heavily armored titan. An enormous physical shield that protects the titan against even the most fiercest onslaught.<br><br>
        Recommended Equipment: x1 Orkan + x2 Rupture
        `,
        builtInDefensePointsData: {
            base: 25,
            level: [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 20]
        },
        healthData: {
            base: 345e3,
            level: [0, 1e3, 1e3, 1e3, 2e3, 2e3, 2e3, 3e3, 3e3, 3e3, 3e3, 4e3, 4e3, 4e3, 4e3, 4e3, 4e3, 4e3, 4e3, 4e3, 5e3, 5e3, 5e3, 5e3, 5e3]
        },
        abilities: [{
            name: "Phalanx Mode",
            desc: `
            <span style="font-width: bolder; color: #fff;">Phalanx Mode</span>
            The shape changes the direction of its shields.<br><br>
            Cooldown: 2 seconds
            `,
            iconSource: "./images/abilities/shapeshift.png",
            lastingTime: 1e3,
            reload: 1e3
        }, {
            name: "Blast Wave",
            desc: `
            <span style="font-width: bolder; color: #fff;">Blast Wave</span>
            The shape emits a blast wave that damages enemies and pushes them away.<br><br>
            Duration: .25 seconds<br>
            AoE Radius: 800 PX<br>
            Cooldown: 12 seconds
            `,
            iconSource: "./images/weapons/cinder.png",
            damageData: {
                base: 32e3,
                level: [0, 500, 500, 500, 500, 500, 500, 750, 750, 750, 750, 750, 750, 750, 750, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 2e3]
            },
            lastingTime: 250,
            reload: 12e3
        }],
        shieldData: {
            type: "normal",
            base: 1120800,
            amountOfShields: 2,
            level: [0, 10e3, 10e3, 10e3, 10e3, 20e3, 20e3, 20e3, 20e3, 20e3, 20e3, 20e3, 30e3, 30e3, 30e3, 30e3, 40e3, 40e3, 40e3, 40e3, 40e3, 40e3, 40e3, 50e3, 50e3],
            regen: 0
        },
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#f00",
        titan: true,
        moduleHardpoints: 3,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 55e3
        }
    }, {
        dontSell: true,
        tier: 3,
        name: "Indra",
        industryName: "Hexagon",
        indexRole: 0,
        speed: 0.0008,
        speedLevel: [0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0, 0.0001, 0, 0, 0.0001, 0.0001, 0.0001],
        scale: 115,
        fieldOfViewMulti: 3.2,
        desc: `A titan that can enter a phase where it is unable to take damage. Powerful brawler that can survive the toughest fights without a scratch.<br><br>Recommended Equipment: x1 Disintegrator + x2 Havoc`,
        healingMultiData: {
            base: 1,
            level: [0, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .02]
        },
        builtInDefensePointsData: {
            base: 25,
            level: [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 10]
        },
        healthData: {
            base: 453e3,
            level: [0, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241, 9241]
        },
        abilities: [{
            name: "Phase Shift",
            desc: `
            <span style="font-width: bolder; color: #fff;">Phase Shift</span> The shape activates a powerful matrix that allows it not to take any damage. Negative effects are all nullfied during the ability.<br><br>
            Duration: 2 seconds<br>
            Charges: 2<br>
            Speed Increase: 50%<br>
            Cooldown (per charge): 15 seconds
            `,
            iconSource: "./images/abilities/phase_shift.png",
            charges: 2,
            lastingTime: 3e3,
            reload: 15e3
        }, {
            name: "Mute Blast",
            desc: `
            <span style="font-width: bolder; color: #fff;">Mute Blast</span> The shape sends a battle ship strike that emits mute and emp effects.<br><br>
            Effect Duration: depends on shape level<br>
            Time before strike: 1 seconds<br>
            Effect Radius: 300 PX<br>
            Cooldown: 18 seconds
            `,
            iconSource: "./images/icons/blind.png",
            abilityEffectDurationData: {
                base: 250,
                level: [0, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125]
            },
            reload: 18e3
        }],
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#79468c",
        titan: true,
        moduleHardpoints: 4,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 175e3
        }
    }, {
        dontSell: true,
        tier: 4,
        name: "Luchador",
        industryName: "Circle",
        indexRole: 0,
        speed: 0.0006,
        speedLevel: [0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0, 0.0001, 0, 0, 0.0001, 0.0001, 0.0001],
        scale: 120,
        fieldOfViewMulti: 3.2,
        desc: `
        A super tank titan that uses reflectors for defense. Jump tech and suppression tech allows this shape to travel long distances and weaken enemy weapon damage output. This titan also takes less gray "unrepairable" damage.
        <br><br>Recommended Equipment: x1 Discharger + x2 Ingiter
        `,
        healingMultiData: {
            base: 1,
            level: [0, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .02, .04]
        },
        builtInDefensePointsData: {
            base: 25,
            level: [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 10, 10]
        },
        healthData: {
            base: 480e3,
            level: [0, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3]
        },
        hullIntegrity: .35,
        abilities: [{
            name: "Ultimate Reflector",
            desc: `
            <span style="font-width: bolder; color: #fff;">Ultimate Reflector</span> The shape digs to the ground and activates a powerful reflector, after the reflector ends the shape repairs some of its durability.<br><br>
            Duration: 8 seconds<br>
            Repairable Durability: 25,000/SEC<br>
            Reflector Blocked: depends on shape level<br>
            Reflector Returned: 25%<br>
            Cooldown (per charge): 15 seconds
            `,
            iconSource: "./images/icons/reflector.png",
            lastingTime: 8e3,
            defensePointToReflector: true,
            abilityDefensePointsData: {
                base: 12.5,
                level: [0, 12.5, 0, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 25, 25, 25, 25, 25, 25, 25, 25]
            },
            reload: 15e3
        }, {
            name: "Frog Splash",
            desc: `
            <span style="font-width: bolder; color: #fff;">Frog Splash</span> The shape leaps into the air and activates a reflector.<br><br>
            Charges: 2<br>
            Repair Power: 10%<br>
            Gray Damage Repair: 15%<br>
            Effect Radius: 400PX<br>
            Duration: 1 seconds<br>
            Reflector Blocked: 40%<br>
            Reflector Returned: 10%<br>
            Suppression Power: 40%<br>
            Cooldown (per charge): 18 seconds
            `,
            damageData: {
                base: 8e3,
                level: [0, 750, 750, 750, 750, 850, 950, 950, 950, 1050, 1050, 1050, 1050, 1050, 1350, 1350, 1350, 1350, 1450, 1450, 1550, 1650, 1750, 1750, 1750]
            },
            iconSource: "./images/icons/reflector.png",
            charges: 2,
            lastingTime: 1e3,
            reload: 12e3
        }],
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#fff",
        titan: true,
        moduleHardpoints: 4,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 305e3
        }
    }, {
        dontSell: true,
        tier: 4,
        name: "Light Gray Heptagon",
        speed: 0.0012,
        indexRole: 0,
        speedLevel: [0, 0.00005, 0.00005, 0.00005, 0.00005, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001],
        scale: 85,
        fieldOfViewMulti: 1.5,
        desc: `no description lol<br>too lazy`,
        builtInDefensePoints: 50,
        hullIntegrity: .25,
        healthData: {
            base: 125e3,
            level: [0, 15e3, 15e3, 15e3, 15e3, 15e3, 15e3, 15e3, 15e3, 15e3, 15e3, 15e3],
        },
        healingMulti: 1.25,
        abilities: [{
            name: "Comet Splash",
            desc: `
            <span style="font-width: bolder; color: #fff;">Comet Splash</span> The shape leaps up high in the air and activates a powerful reflector. After the shape goes to the ground or it smashes to the ground, it activates a laser that repairs health when dealing damage.<br><br>
            Reflector Blocked: 70%<br>
            Reflector Returned: 20%<br>
            Built-In Weapon Duration: 5 seconds<br>
            Built-In Weapon Range: 600 PX<br>
            Built-In Weapon Damage Heal-Back: 60%<br>
            AoE Blast Radius: 600PX<br>
            Dashing Duration: 3 seconds<br>
            Duration of entire ability: 8 seconds<br>
            Cooldown (per charge): 18 seconds
            `,
            iconSource: "./images/icons/reflector.png",
            damageData: {
                base: 15e3,
                level: [0, 1e3, 1e3, 1e3, 1e3, 1e3, 2e3, 2e3, 2e3, 2e3, 3e3, 4e3]
            },
            charges: 2,
            lastingTime: 8e3,
            reload: 18e3
        }],
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#bababa",
        moduleHardpoints: 4,
        costParts: true
    }, {
        tier: 2,
        name: "Sharanga",
        industryName: "Heptagon",
        indexRole: 1,
        speed: 0.0003,
        speedLevel: [0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0, 0.0001, 0, 0, 0.0001, 0.0001, 0.0001],
        scale: 120,
        fieldOfViewMulti: 4.2,
        desc: `A sniping titan that can increase it's weapon's damage output for a short time. It can also phase out of trouble.<br><br>Recommended Equipment: x3 Striker`,
        builtInDefensePointsData: {
            base: 25,
            level: [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 10]
        },
        healthData: {
            base: 445e3,
            level: [0, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3]
        },
        abilities: [{
            name: "Overpower",
            desc: `
            <span style="font-width: bolder; color: #fff;">Overpower</span> Increases all weapon damage output and allows the ability to bypass energy shields.<br><br>
            Duration: 3 seconds<br>
            Cooldown: 12 seconds
            `,
            iconSource: "./images/modules/nuclear_reactor.png",
            damageIncreaseData: {
                base: .25,
                level: [0, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .01, .02]
            },
            lastingTime: 3e3,
            reload: 6e3
        }, {
            name: "Phase Shift",
            desc: `
            <span style="font-width: bolder; color: #fff;">Phase Shift</span> The shape enters into a stage where it cannot take damage. During this stage, the weapons of the robot will be disabled.<br><br>
            Duration: 4 seconds<br>
            Charges: 2<br>
            Cooldown (per charge): 20 seconds
            `,
            iconSource: "./images/abilities/phase_shift.png",
            lastingTime: 4e3,
            charges: 2,
            reload: 20e3
        }],
        hardpoints: {
            light: 0,
            heavy: 3
        },
        color: "#ffff00",
        titan: true,
        moduleHardpoints: 3,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 105e3
        }
    }, {
        dontSell: true,
        tier: 4,
        name: "Bersagliere",
        industryName: "Heptagon",
        indexRole: 1,
        speed: 0.0003,
        speedLevel: [0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0, 0.0001, 0, 0, 0.0001, 0.0001, 0.0001],
        scale: 130,
        fieldOfViewMulti: 4.2,
        desc: `
        A titan designed for far ranged sniping. It can activite a martix that allows it to deal heavy damage to heavily resistant targets.<br><br>
        Recommended Equipment: x3 Vendicatore
        `,
        builtInDefensePointsData: {
            base: 15,
            level: [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10]
        },
        healthData: {
            base: 346e3,
            level: [0, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 16e3, 16e3, 16e3, 16e3]
        },
        baseDamageIncrease: .35,
        abilities: [{
            name: "Defense Breach",
            desc: `
            <span style="font-width: bolder; color: #fff;">Defense Breach</span> All weapons equipped will be able to bypass all types of defense systems like DoT and Blast. The shape also repairs durability when dealing damage (50%).<br><br>
            Duration: 4 seconds<br>
            Cooldown: 14 seconds
            `,
            iconSource: "./images/abilities/dismantle.png",
            lastingTime: 4e3,
            reload: 14e3
        }, {
            name: "Nuclear Rocket Shot",
            desc: `
            <span style="font-width: bolder; color: #fff;">Nuclear Rocket Shot</span> Fires a rocket that deals increased damage the further it travels.<br><br>
            The damage increase is exponential.<br><br>
            AoE Radius: 60PX<br>
            Damage Increase per 100PX: 7.5%<br>
            Max Rocket Damage: 250,000<br>
            Rocket Range: 4000PX<br>
            Duration: .75 seconds<br>
            Charges: 6<br>
            Cooldown (per charge): 2 seconds
            `,
            iconSource: "./images/weapons/landslide.png",
            charges: 6,
            damageData: {
                base: 1500,
                level: [0, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1500, 2e3, 2e3, 2e3, 2e3]
            },
            lastingTime: 500,
            reload: 2e3
        }],
        hardpoints: {
            light: 0,
            heavy: 3
        },
        color: "#00ffff",
        titan: true,
        moduleHardpoints: 4,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 305e3
        }
    }, {
        dontSell: true,
        tier: 4,
        name: "Eiffel",
        industryName: "Heptagon",
        indexRole: 1,
        speed: 0.0003,
        speedLevel: [0, 0, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0, 0.0001, 0, 0, 0.0001, 0, 0.0001],
        scale: 130,
        fieldOfViewMulti: 3.2,
        desc: ``,
        builtInDefensePointsData: {
            base: 5,
            level: [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 10, 10]
        },
        healthData: {
            base: 246e3,
            level: [0, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 8e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 16e3, 16e3, 16e3, 16e3]
        },
        abilities: [{
            name: "Cannonier",
            desc: `
            <span style="font-width: bolder; color: #fff;">Cannonier</span> The titan takes flight and activates its disabled two heavy weapons. It gains temporary fixed health, increased movement speed, and deals increased damage.<br><br>
            Damage Increase: 50%<br>
            Speed Increase: 75%<br>
            Additional Weapons Unlocked: 2<br>
            Duration: 10 seconds<br>
            Cooldown: 14 seconds
            `,
            additionalHealthData: {
                base: 250e3,
                level: [0, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 15e3, 15e3, 15e3, 15e3, 15e3, 15e3, 20e3, 20e3, 20e3, 25e3, 25e3]
            },
            iconSource: "./images/abilities/shapeshift.png",
            lastingTime: 10e3,
            reload: 14e3
        }, {
            name: "Debut",
            desc: `
            <span style="font-width: bolder; color: #fff;">Debut</span> The titan dashes and then increases it's movement speed for some time.<br><br>
            Movement Speed Increase: 100%<br>
            Duration: 6 seconds<br>
            Cooldown: 8 seconds
            `,
            iconSource: "./images/abilities/dash.png",
            lastingTime: 6e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 2,
            heavy: 3
        },
        color: "#6d9bc1",
        titan: true,
        moduleHardpoints: 4,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 305e3
        }
    }, {
        tier: 3,
        name: "Veronica Circle",
        speed: 0.0012,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0002, 0.0002, 0.0002, 0.0002, 0.0004],
        scale: 60,
        fieldOfViewMulti: 1.4,
        desc: ``,
        healthData: {
            base: 110400,
            level: [0, 5e3, 5e3, 7e3, 7e3, 7e3, 7e3, 8e3, 11e3, 14e3, 16e3, 16e3],
        },
        abilities: [{
            name: "Blink",
            desc: `
            <strong style="color: #fff">Blink</strong> The shape places a translocator and speeds up. The next activation of its ability would make it teleport to the translocator.<br><br>
            Defense Points: 100 (50% Resistance)<br>
            Movement Speed Increase: 100%<br>
            Duration: 10 seconds<br>
            Cooldown: 8 seconds
            `,
            iconSource: "./images/abilities/blink.png",
            lastingTime: 10e3,
            reload: 8e3
        }],
        hardpoints: {
            light: 4,
            heavy: 0
        },
        color: "#a020f0",
        moduleHardpoints: 3,
        costParts: true
    }, {
        dontSell: true,
        tier: 4,
        name: "Mauler",
        industryName: "Heptagon",
        indexRole: 0,
        speed: 0.0006,
        speedLevel: [0, 0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0.0001, 0, 0, 0.0001, 0, 0, 0.0001, 0.0001, 0.0001],
        scale: 120,
        fieldOfViewMulti: 3.2,
        desc: `
        Heptagon Industry's latest line of clsoe ranged brawling titans.
        This one is special in the fact that it uses the latest tech that allows it to inflict Deathmark effect on enemies.
        It also has the ability to convert damage taken into Damage Over Time (DOT).
        `,
        builtInDefensePointsData: {
            base: 25,
            level: [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 10, 10, 15, 15, 15]
        },
        healthData: {
            base: 480e3,
            level: [0, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3]
        },
        healingMulti: 1.5,
        abilities: [{
            name: "Hook",
            desc: `
            <span style="font-width: bolder; color: #fff;">Hook</span> The shape leaps forward into a chosen direction, converting all damage taken into DOT.<br><br>
            Charge Duration: 2 seconds<br>
            Charges: 2<br>
            Charge Usage Delay: 2 seconds<br>
            DOT Convertion Duration: 8 seconds<br>
            Cooldown per charge: 18 seconds
            `,
            iconSource: "./images/abilities/dash.png",
            charges: 2,
            lastingTime: 2e3,
            reload: 18e3
        }, {
            name: "Dark Light",
            desc: `
            <span style="font-width: bolder; color: #fff;">Dark Light</span> The shape opens up its inner core, unveiling a dark light that inflicts deathmark to enemies every .5 seconds.<br><br>
            Duration: 6 seconds<br>
            Cooldown: 14 seconds
            `,
            deathmarkData: {
                base: .075 / 2,
                level: [0, .005, .005, .005, .005, .005, .005, .01, .01, .01, .01, .01, .01, .01, .01, .02, .02, .02, .02, .02, .02, .02, .02, .02, .04].map(e => e / 2)
            },
            iconSource: "./images/abilities/matrix.png",
            lastingTime: 6e3,
            reload: 14e3
        }],
        dotResistance: .4,
        hardpoints: {
            light: 2,
            heavy: 1
        },
        color: "#303030",
        titan: true,
        moduleHardpoints: 4,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 305e3
        }
    }, {
        tier: 4,
        name: "Grayish Blue Triangle",
        speed: 0.0024,
        indexRole: 1,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0003, 0.0006],
        scale: 65,
        fieldOfViewMulti: 1.6,
        desc: ``,
        healthData: {
            base: 75e3,
            level: [0, 5e3, 5e3, 5e3, 7e3, 7e3, 7e3, 7e3, 10e3, 10e3, 10e3, 15e3]
        },
        abilities: [{
            name: "Mastermind",
            desc: ``,
            iconSource: "./images/abilities/self_heal.png",
            damageData: {
                base: 750,
                level: [0, 125, 125, 125, 125, 125, 250, 250, 500, 500, 500, 500]
            },
            lastingTime: 6e3,
            reload: 14e3
        }],
        hardpoints: {
            light: 5,
            heavy: 0
        },
        color: "#446879",
        moduleHardpoints: 3,
        costParts: true
    }, {
        tier: 4,
        name: "Orange Triangle",
        speed: 0.0022,
        indexRole: 3,
        speedLevel: [0, 0.0001, 0.0001, 0.0001, 0, 0.0001, 0, 0.0001, 0.0001, 0.0001, 0.0003, 0.0006],
        scale: 75,
        fieldOfViewMulti: 1.85,
        desc: ``,
        healthData: {
            base: 123e3,
            level: [0, 14e3, 14e3, 14e3, 16e3, 16e3, 18e3, 18e3, 20e3, 20e3, 20e3, 22e3],
        },
        abilities: [{
            name: "Annihilation Mode",
            desc: ``,
            iconSource: "./images/abilities/self_heal.png",
            healingPowerData: {
                base: 12e3,
                level: [0, 2e3, 2e3, 5e3, 7e3, 10e3, 12e3, 12e3, 12e3, 12e3, 12e3, 12e3]
            },
            lastingTime: 8e3,
            reload: 16e3
        }],
        hardpoints: {
            light: 3,
            heavy: 2
        },
        color: "#ffb400",
        moduleHardpoints: 4,
        costParts: true

    }];// 15000,55000,105000,175000,305000
    function defensePointsToResistance(defense) {
        return (100) / (100 + defense);
    }
    class weapon {
        constructor(data, ownerSID = null, slot = null) {
            this.isItem = true;
            this.tier = data.tier;
            this.shotsPerFire = data.shotsPerFire;
            this.firedTime = 0;
            this.owner = ownerSID;
            this.name = data.name;
            this.desc = data.desc;
            this.chargingDelay = data.chargingDelay;
            this.chargingMechanic = data.chargingMechanic;
            this.industryName = data.industryName || "Unregistered Weapon";
            this.ammoFired = 0;
            this.projType = data.projType;
            this.dmg = data.damageData ? data.damageData.base : data.dmg;
            this.fireRate = data.fireRate;
            this.slot = slot;
            this.ammo = this.maxammo = data.ammo;
            this.spread = data.spread;
            this.type = data.type;
            this.range = data.range;
            this.reload = data.reload;
            this.imageSource = data.imageSource;
            this.level = 1;
            this.motherShipCharge = data.motherShipCharge;
            this.continuousReload = data.continuousReload;
            this.ammoEachReloadTick = data.ammoEachReloadTick;
            this.aoeRange = data.aoeRange;
            this.overheatTime = data.overheatTime;
            this.dotDamage = data.dotData ? data.dotData.base : data.dotDamage;
            this.fireRateDecrease = data.fireRateDecreaseData ? data.fireRateDecreaseData.base : data.fireRateDecrease;
            this.defenseBypass = data.defenseBypassData ? data.defenseBypassData.base : data.defenseBypass;
            this.healBackOnDamage = data.healBackOnDamageData ? data.healBackOnDamageData.base : data.healBackOnDamage;
            if (data.fireRateDecrease) {
                this.reload -= data.fireRateDecrease;
            }
            if (data.shieldData || data.baseShielding) {
                if (data.baseShielding) data.shieldData = data.baseShielding;
                this.baseShielding = {
                    health: (data.shieldData.base || data.shieldData.health),
                    type: data.shieldData.type,
                    regen: data.shieldData.regen
                }
            }
            this.titan = data.titan || false;
            this.effectIncrease = data.effectIncreaseData ? data.effectIncreaseData.base : data.effectIncrease;
            this.effectIncreaseName = data.effectIncreaseData ? data.effectIncreaseData.effect : data.effectIncreaseName;
            this.sellPrice = 0;
            this.enhanceCost = (this.tier + 1) * 15e2;
            if (data.cost) {
                this.sellPrice += data.cost.sliver * .75;
                if (data.cost.gold && data.cost.gold > 0) {
                    this.sellPrice += 1250 * data.cost.gold;
                }
            }
        }
    }
    function addUltimateTextToWeapon(name) {
        return `
        ULTIMATE WEAPON VERSION<br>
        The rarest modification of the ${name}.
        Surpassing the original in all aspects,
        it is a desirable weapon for any player.
        `;
    }
    var defensePointsByPassTo100 = {
        base: 0.75,
        level: [0, 0.01, 0.01, 0.01, 0.01, 0.02, 0.02, 0.03, 0.03, 0.03, 0.04, 0.04]
    };
    var defensePointsByPassTo75 = {
        base: 0.50,
        level: [0, 0.01, 0.01, 0.01, 0.01, 0.02, 0.02, 0.03, 0.03, 0.03, 0.04, 0.04]
    };
    var weaponData = [{
        tier: 0,
        industryName: "Circle",
        spread: 3,
        name: "Punisher",
        type: "Light",
        projType: "normal",
        desc: `
        Multi-barreled machine gun with a high rate of fire. Great at close range.
        `,
        damageData: {
            base: 160,
            level: [0, 20, 20, 20, 20, 20, 30, 30, 30, 40, 40, 40],
        },
        motherShipCharge: 0.000125,
        imageSource: "./images/weapons/punisher.png",
        fireRate: 65,
        ammo: 220,
        reload: 10e3,
        range: 1200,
        cost: {
            sliver: 30e3,
            gold: 0
        }
    }, {
        tier: 1,
        industryName: "Circle",
        name: "Landslide",
        type: "Light",
        projType: "rocket",
        desc: `
        Close range rocket launcher with high rate of fire. 
        Rockets deal aoe damage and are effective againist groups of enemies. 
        Improved reloading mechanics makes this weapon reload while firing.
        `,
        motherShipCharge: 0.00046875,
        damageData: {
            base: 750,
            level: [0, 40, 43, 46, 50, 50, 50, 50, 82, 82, 102, 102],
        },
        ammoEachReloadTick: 1,
        continuousReload: true,
        imageSource: "./images/weapons/landslide.png",
        aoeRange: 60,
        fireRate: 50,
        ammo: 17,
        reload: 600,
        range: 600,
        cost: {
            sliver: 230e3,
            gold: 0
        }
    }, {
        tier: 0,
        industryName: "Circle",
        name: "Shocker",
        type: "Heavy",
        projType: "normal",
        desc: `
        Far ranged weapon used to target enemies at far distances.
        `,
        motherShipCharge: 0.05,
        damageData: {
            base: 5250,
            level: [0, 200, 220, 240, 260, 380, 400, 420, 520, 540, 560, 580],
        },
        imageSource: "./images/weapons/shocker.png",
        fireRate: 0,
        ammo: 1,
        reload: 9e3,
        range: 3200,
        cost: {
            sliver: 190e3,
            gold: 0
        }
    }, {
        tier: 1,
        industryName: "Circle",
        name: "Destroyer",
        type: "Heavy",
        spread: 5,
        projType: "normal",
        desc: `
        Large heavy multi-barreled machine gun. 
        Great at close range since bullets disperse due to high fire rate. 
        Each round shoots 2 projectiles.
        `,
        motherShipCharge: 0.000125,
        damageData: {
            base: 242,
            level: [0, 22, 22, 22, 22, 22, 44, 44, 44, 44, 44, 88],
        },
        shotsPerFire: 2,
        imageSource: "./images/weapons/destroyer.png",
        fireRate: 65,
        ammo: 220,
        reload: 10e3,
        range: 1400,
        cost: {
            sliver: 0,
            gold: 500
        }
    }, {
        tier: 1,
        industryName: "Circle",
        name: "Avalanche",
        type: "Heavy",
        projType: "rocket",
        desc: `
        Fast firing heavy rocket launcher. AOE Damage makes it a great weapon aganist grouped enemies.
        Improved reloading mechanics makes this weapon reload while firing.
        `,
        damageData: {
            base: 856,
            level: [0, 80, 100, 147, 160, 211, 222, 234, 255, 266, 288, 300],
        },
        motherShipCharge: 0.000023,
        ammoEachReloadTick: 4,
        continuousReload: true,
        imageSource: "./images/weapons/avalanche.png",
        aoeRange: 80,
        fireRate: 200,
        ammo: 16,
        reload: 2e3,
        range: 800,
        cost: {
            sliver: 0,
            gold: 750
        }
    }, {
        tier: 2,
        industryName: "Circle",
        name: "Hawk",
        type: "Light",
        desc: `
        Light laser weapon.
        Special targeting allows the weapon to target 3 enemies at once.
        Ignores mouse cursor and targets nearest 3 enemies.
        Weapon ignores walls and all shields.
        `,
        motherShipCharge: 0.00125,
        damageData: {
            base: 218,
            level: [0, 46, 51, 51, 55, 55, 79, 79, 89, 101, 114, 127],
        },
        imageSource: "./images/weapons/hawk.png",
        fireRate: 200,
        ammo: 30,
        reload: 5e3,
        range: 1000,
        cost: {
            sliver: 0,
            gold: 2e3
        }
    }, {
        tier: 2,
        industryName: "Circle",
        name: "Eagle",
        type: "Heavy",
        desc: `
        Heavy laser weapon.
        Special targeting allows the weapon to target 3 enemies at once.
        Ignores mouse cursor and targets nearest 3 enemies.
        Weapon ignores walls and all shields.
        `,
        motherShipCharge: 0.00125,
        damageData: {
            base: 327,
            level: [0, 69, 77, 77, 83, 83, 119, 119, 134, 152, 171, 191],
        },
        imageSource: "./images/weapons/eagle.png",
        fireRate: 100,
        ammo: 60,
        reload: 5e3,
        range: 1000,
        cost: {
            sliver: 0,
            gold: 2e3
        }
    }, {
        tier: 2,
        industryName: "Heptagon",
        name: "Viper",
        type: "Heavy",
        spread: 2,
        projType: "normal",
        desc: `
        Large heavy multi-barreled machine gun.
        Projectiles are coated with a small layer of enzymes that corrode metal.
        Each hit emits DOT effect damage that bypasses defense systems of enemies.
        `,
        motherShipCharge: 0.00067,
        damageData: {
            base: 455,
            level: [0, 46, 49, 55, 60, 66, 71, 80, 87, 96, 105, 117],
        },
        dotData: {
            base: 39,
            level: [0, 4, 4, 5, 5, 5, 7, 6, 8, 8, 9, 10],
        },
        imageSource: "./images/weapons/viper.png",
        fireRate: 100,
        ammo: 150,
        reload: 10e3,
        range: 1400,
        cost: {
            sliver: 0,
            gold: 3e3
        }
    }, {
        tier: 2,
        industryName: "Heptagon",
        name: "Atomizer",
        type: "Light",
        spread: 12,
        projType: "energy",
        desc: `
        Light energy machine gun.
        Unlimited ammo.
        Longer it fires, the slower and less accurate it becomes.
        `,
        overheatTime: 12e3,
        motherShipCharge: 0.0005,
        damageData: {
            base: 736 * 1.25,
            level: [0, 51, 56, 60, 65, 75, 76, 85, 104, 114, 123, 170].map(e => e * 1.25)
        },
        imageSource: "./images/weapons/atomizer.png",
        fireRate: 75,
        ammo: 1e300,
        reload: 0,
        range: 1200,
        cost: {
            sliver: 0,
            gold: 5e3
        }
    }, {
        tier: 2,
        industryName: "Heptagon",
        name: "Nucleon",
        spread: 12,
        type: "Heavy",
        projType: "energy",
        desc: `
        Heavy energy machine gun.
        Unlimited ammo.
        Longer it fires, the slower and less accurate it becomes.
        `,
        motherShipCharge: 0.0005,
        overheatTime: 12e3,
        damageData: {
            base: 1072 * 1.25,
            level: [0, 102, 112, 120, 130, 150, 152, 170, 188, 208, 226, 280].map(e => e * 1.25)
        },
        imageSource: "./images/weapons/nucleon.png",
        fireRate: 75,
        ammo: 1e300,
        reload: 0,
        range: 1200,
        cost: {
            sliver: 0,
            gold: 5e3
        }
    }, {
        tier: 2,
        industryName: "Heptagon",
        name: "Sting",
        type: "Light",
        projType: "normal",
        spread: 2,
        desc: `
        Large light multi-barreled machine gun.
        Projectiles are coated with a small layer of enzymes that corrode metal.
        Each hit emits DOT effect damage that bypasses defense systems of enemies.
        `,
        motherShipCharge: 0.00067,
        damageData: {
            base: 303,
            level: [0, 31, 33, 37, 40, 44, 47, 53, 58, 64, 70, 78],
        },
        dotData: {
            base: 26,
            level: [0, 3, 3, 4, 4, 4, 5, 4, 5, 5, 6, 7],
        },
        imageSource: "./images/weapons/sting.png",
        fireRate: 100,
        ammo: 150,
        reload: 10e3,
        range: 1400,
        cost: {
            sliver: 0,
            gold: 3e3
        }
    }, {
        tier: 2,
        industryName: "Circle",
        name: "Thunder",
        spread: 6,
        projType: "normal",
        type: "Heavy",
        desc: `
        Heavy shotgun.
        Shoots 16 projectiles per burst.
        Improved reloading mechanic makes this weapon reload while firing.
        `,
        motherShipCharge: 0.00075,
        damageData: {
            base: 8250,
            level: [0, 400, 400, 800, 800, 800, 800, 800, 1e3, 1e3, 1e3, 1e3]
        },
        imageSource: "./images/weapons/thunder.png",
        ammoEachReloadTick: 1,
        continuousReload: true,
        fireRate: 1e3,
        ammo: 5,
        reload: 2e3,
        range: 800,
        cost: {
            sliver: 0,
            gold: 4e3
        }
    }, {
        tier: 2,
        industryName: "Circle",
        name: "Storm",
        projType: "normal",
        type: "Light",
        spread: 6,
        desc: `
        Light shotgun.
        Shoots 16 projectiles per burst.
        Improved reloading mechanic makes this weapon reload while firing.
        `,
        motherShipCharge: 0.00075,
        damageData: {
            base: 4125,
            level: [0, 200, 200, 400, 400, 400, 400, 400, 500, 500, 500, 500]
        },
        imageSource: "./images/weapons/storm.png",
        ammoEachReloadTick: 1,
        continuousReload: true,
        fireRate: 1e3,
        ammo: 5,
        reload: 2e3,
        range: 800,
        cost: {
            sliver: 0,
            gold: 4e3
        }
    }, {
        tier: 2,
        industryName: "Pentagon",
        name: "Cinder",
        projType: "normal",
        type: "Heavy",
        desc: `
        Heavy AOE damage weapon.
        This weapon fires pulses of high temperature heat waves to damage enemies.
        Although the heat waves are high in temperature it isn't high enough to cause any DOT damage.
        Due to the speciality of this weapon, it can reload while firing.
        `,
        damageData: {
            base: 980,
            level: [0, 90, 135, 180, 180, 180, 225, 225, 225, 270, 270, 270]
        },
        motherShipCharge: 0.0028,
        imageSource: "./images/weapons/cinder.png",
        ammoEachReloadTick: 1,
        continuousReload: true,
        fireRate: 200,
        ammo: 12,
        reload: 1e3,
        range: 500,
        cost: {
            sliver: 0,
            gold: 3e3
        }
    }, {
        tier: 2,
        industryName: "Pentagon",
        name: "Blaze",
        spread: 2,
        type: "Light",
        projType: "energy",
        desc: `
        Light compact flamethower that's good at close range.
        Ignores blue energy shields.
        `,
        damageData: {
            base: 197,
            level: [0, 20, 22, 31, 23, 34, 31, 41, 25, 52, 44, 49]
        },
        motherShipCharge: 0.0003,
        imageSource: "./images/weapons/blaze.png",
        fireRate: 20,
        ammo: 200,
        reload: 5e3,
        range: 600,
        cost: {
            sliver: 0,
            gold: 3e3
        }
    }, {
        tier: 2,
        industryName: "Pentagon",
        name: "Ember",
        spread: 10,
        type: "Heavy",
        projType: "energy",
        desc: `
        Heavy compact flamethower that's good at close range.
        Ignores blue energy shields.
        `,
        damageData: {
            base: 334,
            level: [0, 34, 37, 39, 43, 53, 53, 58, 70, 75, 83, 88]
        },
        motherShipCharge: 0.0003,
        imageSource: "./images/weapons/ember.png",
        fireRate: 20,
        ammo: 200,
        reload: 5e3,
        range: 600,
        cost: {
            sliver: 0,
            gold: 3e3
        }
    }, {
        tier: 3,
        spread: 7,
        industryName: "Pentagon",
        name: "Slumber",
        type: "Light",
        projType: "normal",
        desc: `
        A light fast firing machine gun. Bullets gives effects that slow down enemies.
        `,
        damageData: {
            base: 408,
            level: [0, 34, 34, 39, 45, 45, 56, 56, 61, 68, 73, 89]
        },
        motherShipCharge: 0.001,
        imageSource: "./images/weapons/slumber.png",
        fireRate: 48,
        ammo: 40,
        reload: 5e3,
        range: 1200,
        cost: {
            sliver: 0,
            gold: 5e3
        }
    }, {
        tier: 3,
        spread: 7,
        industryName: "Pentagon",
        name: "Delay",
        type: "Heavy",
        projType: "normal",
        desc: `
        A heavy fast firing machine gun. Bullets gives effects that slow down enemies.
        `,
        damageData: {
            base: 818,
            level: [0, 67, 67, 77, 89, 89, 111, 111, 122, 134, 145, 178]
        },
        motherShipCharge: 0.001,
        imageSource: "./images/weapons/delay.png",
        fireRate: 48,
        ammo: 40,
        reload: 5e3,
        range: 1200,
        cost: {
            sliver: 0,
            gold: 5e3
        }
    }, {
        tier: 3,
        industryName: "Hexagon",
        name: "Rime",
        type: "Light",
        projType: "rocket",
        desc: `
        Light freezing rockets that deal damage.
        Each rocket deals freezing damage and gives the enemy freezing effect.
        Once the effect reaches X stacks, the enemy will be frozen for 1 second.
        `,
        damageData: {
            base: 605,
            level: [0, 60, 60, 60, 60, 60, 100, 150, 180, 200, 220, 250]
        },
        motherShipCharge: 0.00036,
        ammoEachReloadTick: 2,
        continuousReload: true,
        imageSource: "./images/weapons/rime.png",
        aoeRange: 50,
        fireRate: 100,
        ammo: 35,
        reload: 500,
        range: 800,
        cost: {
            sliver: 1e6,
            gold: 5e3
        }
    }, {
        tier: 3,
        industryName: "Hexagon",
        name: "Glacier",
        type: "Heavy",
        projType: "rocket",
        desc: `
        Heavy freezing rockets that deal damage.
        Each rocket deals freezing damage and gives the enemy freezing effect.
        Once the effect reaches X stacks, the enemy will be frozen for 1 second.
        `,
        damageData: {
            base: 905,
            level: [0, 90, 90, 90, 90, 90, 150, 225, 270, 300, 330, 375]
        },
        motherShipCharge: 0.00036,
        ammoEachReloadTick: 2,
        continuousReload: true,
        imageSource: "./images/weapons/glacier.png",
        aoeRange: 50,
        fireRate: 100,
        ammo: 35,
        reload: 500,
        range: 800,
        cost: {
            sliver: 1e6,
            gold: 5e3
        }
    }, {
        tier: 3,
        industryName: "Hexagon",
        name: "Devastator",
        projType: "normal",
        type: "Heavy",
        spread: 8,
        desc: `
        Heavy close ranged sonic shotgun that fires 10 projectiles per burst.
        Each sonic "shell" deals "permanent" gray damage.
        `,
        damageData: {
            base: 7200,
            level: [0, 444, 500, 655, 777, 900, 1099, 1211, 1322, 1444, 1544, 2777]
        },
        motherShipCharge: 0.0004,
        imageSource: "./images/weapons/devastator.png",
        ammoEachReloadTick: 1,
        continuousReload: true,
        fireRate: 500,
        ammo: 8,
        reload: 2e3,
        range: 500,
        cost: {
            sliver: 5e6,
            gold: 5e3
        }
    }, {
        tier: 3,
        industryName: "Hexagon",
        name: "Scatter",
        projType: "normal",
        type: "Light",
        spread: 8,
        desc: `
        Light close ranged sonic shotgun that fires 10 projectiles per burst.
        Each sonic "shell" deals "permanent" gray damage.
        `,
        damageData: {
            base: 4800,
            level: [0, 296, 333, 436, 518, 600, 732, 807, 881, 962, 1029, 1851]
        },
        motherShipCharge: 0.0004,
        imageSource: "./images/weapons/scatter.png",
        ammoEachReloadTick: 1,
        continuousReload: true,
        fireRate: 500,
        ammo: 8,
        reload: 2e3,
        range: 500,
        cost: {
            sliver: 5e6,
            gold: 5e3
        }
    }, {
        tier: 4,
        industryName: "Circle",
        name: "Evora",
        projType: "normal",
        type: "Light",
        spread: 5,
        desc: `
        Light sonic machine gun that fires 2 projectiles per burst.
        After 2 seconds of continuous fire, the weapon goes into increased firing state, and fires x1.5 faster.
        The sonic blasts that are shot only deal [GRAY DAMAGE].
        `,
        damageData: {
            base: 51,
            level: [0, 7, 7, 12, 12, 12, 12, 25, 25, 25, 32, 32]
        },
        shotsPerFire: 3,
        motherShipCharge: 0.00011,
        imageSource: "./images/weapons/evora.png",
        fireRate: 50,
        ammo: 150,
        reload: 4e3,
        range: 1200,
        cost: {
            sliver: 5e6,
            gold: 20e3,
            workshopPoints: 75e2
        }
    }, {
        tier: 4,
        industryName: "Circle",
        name: "Veyron",
        spread: 5,
        projType: "normal",
        type: "Heavy",
        desc: `
        Heavy sonic machine gun that fires 2 projectiles per burst.
        After 2 seconds of continuous fire, the weapon goes into increased firing state, and fires x1.5 faster.
        The sonic blasts that are shot only deal [GRAY DAMAGE].
        `,
        damageData: {
            base: 76,
            level: [0, 11, 11, 18, 18, 18, 18, 38, 38, 38, 48, 48]
        },
        shotsPerFire: 3,
        motherShipCharge: 0.00011,
        imageSource: "./images/weapons/veyron.png",
        fireRate: 50,
        ammo: 150,
        reload: 4e3,
        range: 1200,
        cost: {
            sliver: 50e6,
            gold: 20e3,
            workshopPoints: 75e2
        }
    }, {
        dontSell: true,
        tier: 3,
        industryName: "Circle",
        name: "Reaper",
        type: "Heavy",
        projType: "normal",
        desc: `
        Far ranged weapon used to target enemies at far distances.
        Bullets are coated with high layers of special material,
        that makes it able to do high damage to heavily protected targets
        because it bypass the defense systems.
        `,
        damageData: {
            base: 2300,
            level: [0, 200, 200, 200, 200, 290, 290, 290, 380, 380, 380, 380],
        },
        motherShipCharge: 0.00235,
        imageSource: "./images/weapons/reaper.png",
        fireRate: 200,
        ammo: 6,
        reload: 12e3,
        range: 3800,
        cost: {
            sliver: 20e6,
            gold: 5e3,
            workshopPoints: 5e3
        }
    }, {
        tier: 3,
        industryName: "Circle",
        name: "Flux",
        spread: 3,
        type: "Heavy",
        projType: "energy",
        desc: `
        The Flux is a formidable multi-barreled machine gun with an astonishingly high rate of fire.
        What sets this weapon apart is its unique damage amplification,
        which is intricately tied to the maximum health and tier of the targets it strikes (deals +150% more to titans).
        `,
        damageData: {
            base: 99,
            level: [0, 12, 12, 18, 18, 18, 18, 24, 24, 24, 36, 48]
        },
        motherShipCharge: 0.00032,
        imageSource: "./images/weapons/flux.png",
        fireRate: 50,
        ammo: 220,
        reload: 5e3,
        range: 1200,
        cost: {
            sliver: 5e6,
            gold: 5e3,
            workshopPoints: 5e3
        }
    }, {
        tier: 3,
        industryName: "Heptagon",
        name: "Incinerator",
        type: "Heavy",
        projType: "energy",
        desc: `
        A long-range incendiary heavy rocket launcher,
        each direct hit from its rockets accumulates a
        potent "blast effect." When the target's blast
        threshold is reached, it detonates,
        causing area-of-effect damage not only to itself but also to
        nearby allies of the target.
        `,
        damageData: {
            base: 1400,
            level: [0, 100, 100, 100, 100, 200, 200, 200, 300, 300, 300, 300],
        },
        effectIncreaseData: {
            base: 0.184,
            level: [0, 0.008, 0.008, 0.008, 0.008, 0.008, 0.008, 0.008, 0.008, 0.016, 0.016, 0.016]
        },
        motherShipCharge: 0.003125,
        ammoEachReloadTick: 1,
        continuousReload: true,
        imageSource: "./images/weapons/incinerator.png",
        aoeRange: 80,
        fireRate: 350,
        ammo: 8,
        reload: 1500,
        range: 1200,
        cost: {
            sliver: 5e6,
            gold: 5e3,
            workshopPoints: 2e3
        }
    }, {
        tier: 3,
        industryName: "Heptagon",
        name: "Scald",
        type: "Light",
        projType: "energy",
        desc: `
        A long-range incendiary light rocket launcher,
        each direct hit from its rockets accumulates a
        potent "blast effect." When the target's blast
        threshold is reached, it detonates,
        causing area-of-effect damage not only to itself but also to
        nearby allies of the target.
        `,
        damageData: {
            base: 933,
            level: [0, 67, 67, 67, 67, 133, 133, 133, 200, 200, 200, 200]
        },
        effectIncreaseData: {
            base: 0.102,
            level: [0, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.01, 0.01, 0.01]
        },
        motherShipCharge: 0.003125,
        ammoEachReloadTick: 1,
        continuousReload: true,
        imageSource: "./images/weapons/scald.png",
        aoeRange: 60,
        fireRate: 350,
        ammo: 8,
        reload: 1500,
        range: 1200,
        cost: {
            sliver: 5e6,
            gold: 5e3,
            workshopPoints: 2e3
        }
    }, {
        tier: 3,
        industryName: "Pentagon",
        name: "Toxin",
        type: "Light",
        projType: "energy",
        desc: `
        Light acid spraying weapon that emits DOT effect. 
        `,
        damageData: {
            base: 135,
            level: [0, 5, 10, 15, 20, 20, 25, 25, 30, 30, 35, 40]
        },
        dotData: {
            base: 34,
            level: [0, 2, 2, 2, 4, 4, 5, 9, 10, 11, 13, 15],
        },
        motherShipCharge: 0.00021,
        imageSource: "./images/weapons/toxin.png",
        fireRate: 50,
        ammo: 120,
        reload: 3e3,
        range: 700,
        cost: {
            sliver: 0,
            gold: 5e3
        }
    }, {
        tier: 3,
        industryName: "Pentagon",
        name: "Bane",
        type: "Heavy",
        projType: "energy",
        desc: `
        Heavy acid spraying weapon that emits DOT effect.
        `,
        damageData: {
            base: 203,
            level: [0, 8, 15, 23, 30, 30, 38, 38, 45, 45, 53, 60]
        },
        dotData: {
            base: 51,
            level: [0, 3, 3, 3, 6, 6, 8, 14, 15, 17, 20, 23]
        },
        motherShipCharge: 0.00021,
        imageSource: "./images/weapons/bane.png",
        fireRate: 50,
        ammo: 120,
        reload: 3e3,
        range: 700,
        cost: {
            sliver: 0,
            gold: 5e3
        }
    }, {
        tier: 3,
        industryName: "Hexagon",
        name: "Lance",
        type: "Light",
        projType: "energy",
        desc: `
        This is a lightweight plasma weapon that shoots energy bursts.
        It can fire continuously without needing to "reload".
        With each shot, it gets hotter, dealing more damage: 150% on the second shot, 200% on the third,
        and a massive 250% on the fourth. For safety, it cools down after every fourth shot and then starts over.
        `,
        damageData: {
            base: 1264,
            level: [0, 100, 100, 150, 150, 200, 200, 250, 250, 250, 300, 400],
        },
        fireRateDecreaseData: {
            base: 0,
            level: [0, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25]
        },
        motherShipCharge: 0.0125,
        imageSource: "./images/weapons/lance.png",
        fireRate: 0,
        ammo: 1,
        reload: 1e3,
        range: 2e3,
        cost: {
            sliver: 1e6,
            gold: 5e3,
            workshopPoints: 5e3
        }
    }, {
        tier: 3,
        industryName: "Hexagon",
        name: "Glaive",
        type: "Heavy",
        projType: "energy",
        desc: `
        This is a lightweight plasma weapon that shoots energy bursts.
        It can fire continuously without needing to "reload".
        With each shot, it gets hotter, dealing more damage: 150% on the second shot, 200% on the third,
        and a massive 250% on the fourth. For safety, it cools down after every fourth shot and then starts over.
        `,
        damageData: {
            base: 1896,
            level: [0, 150, 150, 225, 225, 300, 300, 375, 375, 375, 450, 600]
        },
        fireRateDecreaseData: {
            base: 0,
            level: [0, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25]
        },
        motherShipCharge: 0.0125,
        imageSource: "./images/weapons/glaive.png",
        fireRate: 0,
        ammo: 1,
        reload: 1e3,
        range: 2e3,
        cost: {
            sliver: 1e6,
            gold: 5e3,
            workshopPoints: 5e3
        }
    }, {
        tier: 1,
        name: "Ancile",
        industryName: "Pentagon",
        type: "Heavy",
        projType: "none",
        desc: `
        Weapon that provides a powerful blue energy shield.
        `,
        shieldData: {
            type: "energy",
            base: 47e3,
            level: [0, 3e3, 3e3, 4e3, 5e3, 5e3, 5e3, 6e3, 6e3, 7e3, 7e3, 8e3],
            regen: 0.15
        },
        imageSource: "./images/modules/fortifier.png",
        cost: {
            sliver: 0,
            gold: 500
        }
    }, {
        tier: 4,
        industryName: "Circle",
        spread: 5,
        name: "Tamer",
        type: "Light",
        projType: "energy",
        desc: `
        Fast firing rust light energy machine gun that
        applies rust effect on to enemies.
        Rust reduces the healing power of enemies (MAX 100% REDUCTION).
        `,
        damageData: {
            base: 667,
            level: [0, 27, 27, 34, 34, 34, 34, 51, 51, 51, 67, 67]
        },
        motherShipCharge: 0.001,
        imageSource: "./images/rust.png",
        fireRate: 48,
        ammo: 30,
        reload: 2e3,
        range: 1400,
        cost: {
            sliver: 15e6,
            gold: 15e3,
            workshopPoints: 10e3
        }
    }, {
        tier: 4,
        industryName: "Circle",
        name: "Trickster",
        spread: 5,
        type: "Heavy",
        projType: "energy",
        desc: `
        Fast firing rust heavy energy machine gun that
        applies rust effect on to enemies.
        Rust reduces the healing power of enemies (MAX 100% REDUCTION).
        `,
        damageData: {
            base: 1001,
            level: [0, 41, 41, 51, 51, 51, 51, 77, 77, 77, 101, 101]
        },
        motherShipCharge: 0.001,
        imageSource: "./images/weapons/trickster.png",
        fireRate: 48,
        ammo: 30,
        reload: 2e3,
        range: 1400,
        cost: {
            sliver: 45e6,
            gold: 15e3,
            workshopPoints: 10e3
        }
    }, {
        dontSell: true,
        tier: 3,
        industryName: "Heptagon",
        name: "Pantagruel",
        type: "Light",
        desc: `
        This weapon uses magnetic fields to create a sweeping arc of damage.
        What makes it stand out is that, as it deals damage,
        a portion of that damage is converted into healing.
        `,
        damageData: {
            base: 502,
            level: [0, 20, 20, 20, 30, 30, 30, 30, 40, 40, 40, 40],
        },//healBackOnDamage
        healBackOnDamageData: {
            base: .095,
            level: [0, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.015, 0.025, 0.025],
        },
        motherShipCharge: 0.00042,
        imageSource: "./images/modules/self_fix_unit.png",
        continuousReload: true,
        fireRate: 100,
        ammo: 60,
        ammoEachReloadTick: 20,
        reload: 4e3,
        range: 1000,
        cost: {
            sliver: 0,
            gold: 5e3
        }
    }, {
        dontSell: true,
        tier: 3,
        industryName: "Heptagon",
        name: "Gangantua",
        type: "Heavy",
        desc: `
        This weapon uses magnetic fields to create a sweeping arc of damage.
        What makes it stand out is that, as it deals damage,
        a portion of that damage is converted into healing.
        `,
        damageData: {
            base: 1004,
            level: [0, 40, 40, 40, 60, 60, 60, 60, 80, 80, 80, 80],
        },
        healBackOnDamageData: {
            base: .19,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.03, 0.05, 0.05],
        },
        motherShipCharge: 0.00042,
        imageSource: "./images/weapons/gangantua.png",
        continuousReload: true,
        fireRate: 100,
        ammo: 60,
        ammoEachReloadTick: 20,
        reload: 4e3,
        range: 1000,
        cost: {
            sliver: 0,
            gold: 5e3
        }
    }, {
        tier: 4,
        industryName: "Circle",
        name: "Deceiver",
        spread: 5,
        type: "Light",
        projType: "energy",
        desc: `
        Fast firing dot light energy machine gun that applies dot effect on to enemies.
        `,
        damageData: {
            base: 20,
            level: [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]
        },
        dotData: {
            base: 50,
            level: [0, 3, 3, 3, 3, 6, 6, 6, 9, 12, 12, 24]
        },
        motherShipCharge: 0.001,
        imageSource: "./images/weapons/deceiver.png",
        fireRate: 48,
        ammo: 30,
        reload: 2e3,
        range: 1400,
        cost: {
            sliver: 4e9,
            gold: 100e3,
            workshopPoints: 100e3
        }
    }, {
        tier: 4,
        industryName: "Circle",
        name: "Damper",
        spread: 5,
        type: "Heavy",
        projType: "energy",
        desc: `
        Fast firing dot heavy energy machine gun that applies dot effect on to enemies.
        `,
        damageData: {
            base: 20,
            level: [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]
        },
        dotData: {
            base: 75,
            level: [0, 5, 5, 5, 5, 9, 9, 9, 14, 18, 18, 36]
        },
        motherShipCharge: 0.001,
        imageSource: "./images/weapons/damper.png",
        fireRate: 48,
        ammo: 30,
        reload: 2e3,
        range: 1400,
        cost: {
            sliver: 4e9,
            gold: 100e3,
            workshopPoints: 100e3
        }
    }, {
        tier: 4,
        industryName: "Circle",
        name: "Brisant",
        spread: 15,
        type: "Heavy",
        projType: "normal",
        desc: `
        Heavy cluster shotgun that shoots projectiles,
        which split into multiple projectiles
        once they travel a certain distance.
        When the projectiles are grouped,
        they have a perfect hit rate and
        give enemies a [SLOWDOWN] effect. Once they split
        into 30 projectiles, a noticeable spread is seen.
        `,
        damageData: {
            base: 20537,
            level: [0, 511, 1026, 1285, 1544, 1799, 2058, 2304, 2567, 2567, 5137, 10274]
        },
        motherShipCharge: 0.0025,
        imageSource: "./images/weapons/brisant.png",
        fireRate: 1e3,
        ammo: 6,
        reload: 3700,
        range: 2e3,
        cost: {
            sliver: 15e9,
            gold: 200e3,
            workshopPoints: 100e3
        }
    }, {
        tier: 4,
        industryName: "Circle",
        name: "Shatter",
        spread: 15,
        type: "Light",
        projType: "normal",
        desc: `
        Light cluster shotgun that shoots projectiles,
        which split into multiple projectiles
        once they travel a certain distance.
        When the projectiles are grouped,
        they have a perfect hit rate and
        give enemies a [SLOWDOWN] effect. Once they split
        into 30 projectiles, a noticeable spread is seen.
        `,
        damageData: {
            base: 13691,
            level: [0, 341, 684, 857, 1028, 1199, 1372, 1536, 1711, 1711, 3425, 6849]
        },
        motherShipCharge: 0.0025,
        imageSource: "./images/weapons/shatter.png",
        fireRate: 1e3,
        ammo: 6,
        reload: 3700,
        range: 2e3,
        cost: {
            sliver: 15e9,
            gold: 200e3,
            workshopPoints: 100e3
        }
    }, {
        dontSell: true,
        tier: 2,
        industryName: "Heptagon",
        name: "Razor",
        spread: 7,
        type: "Light",
        projType: "normal",
        desc: `
        Fast firing light homing machinegun.
        Bullets start homing to the nearest
        target after they travel X distance.
        `,
        damageData: {
            base: 90,
            level: [0, 12, 24, 36, 36, 48, 48, 48, 60, 60, 60, 60]
        },
        shotsPerFire: 2,
        motherShipCharge: 0.0004,
        imageSource: "./images/weapons/razor.png",
        fireRate: 90,
        continuousReload: true,
        ammoEachReloadTick: 10,
        ammo: 90,
        reload: 2e3,
        range: 1500,
        cost: {
            sliver: 30e3,
            gold: 3e3
        }
    }, {
        dontSell: true,
        tier: 2,
        industryName: "Heptagon",
        name: "Smuta",
        spread: 7,
        type: "Heavy",
        projType: "normal",
        desc: `
        Fast firing heavy homing machinegun.
        Bullets start homing to the nearest
        target after they travel X distance.
        `,
        damageData: {
            base: 135,
            level: [0, 18, 36, 54, 54, 72, 72, 72, 90, 90, 90, 90]
        },
        shotsPerFire: 2,
        motherShipCharge: 0.0004,
        imageSource: "./images/weapons/smuta.png",
        fireRate: 90,
        continuousReload: true,
        ammoEachReloadTick: 10,
        ammo: 90,
        reload: 2e3,
        range: 1500,
        cost: {
            sliver: 30e3,
            gold: 3e3
        }
    }, {
        tier: 1,
        industryName: "Hexagon",
        name: "Taran",
        type: "Light",
        projType: "energy",
        desc: `
        Light semi-automatic fireball cannon. Fast fire rate and large ammo pool
        allows weapon this to do a huge amount of damage.
        `,
        damageData: {
            base: 475,
            level: [0, 111, 133, 155, 177, 222, 222, 244, 255, 333, 466, 544],
        },
        motherShipCharge: 0.00625,
        imageSource: "./images/weapons/taran.png",
        fireRate: [750, 150, 150, 150],
        ammo: 32,
        reload: 5e3,
        range: 1e3,
        aoeRange: 50,
        cost: {
            sliver: 0,
            gold: 750
        }
    }, {
        tier: 1,
        industryName: "Hexagon",
        name: "Redeemer",
        type: "Heavy",
        projType: "energy",
        desc: `
        Heavy semi-automatic fireball cannon. Fast fire rate and large ammo pool
        allows weapon this to do a huge amount of damage.
        `,
        damageData: {
            base: 713,
            level: [0, 167, 200, 233, 266, 333, 333, 366, 383, 500, 699, 816]
        },
        motherShipCharge: 0.00625,
        imageSource: "./images/weapons/redeemer.png",
        fireRate: [750, 150, 150, 150],
        ammo: 32,
        reload: 5e3,
        range: 1e3,
        aoeRange: 50,
        cost: {
            sliver: 100e3,
            gold: 750
        }
    }, {
        tier: 4,
        industryName: "Circle",
        name: "Labrys",
        type: "Light",
        projType: "energy",
        desc: `
        Light semi-automatic fireball cannon. Weapon emits blast effect, allowing it to deal a lot of damage.
        `,
        damageData: {
            base: 1800,
            level: [0, 75, 75, 75, 150, 150, 225, 225, 225, 225, 300, 300]
        },
        effectIncreaseData: {
            base: .017,
            level: [0, .0002, .0002, .0002, .0002, .0002, .0005, .0005, .0005, .0005, .0005, .0005]
        },
        motherShipCharge: 0.0015625,
        imageSource: "./images/weapons/labrys.png",
        fireRate: [480, 130, 130, 130, 130],
        ammo: 25,
        reload: 5e3,
        range: 2e3,
        aoeRange: 75,
        cost: {
            sliver: 15e9,
            gold: 150e3,
            workshopPoints: 50e3
        }
    }, {
        tier: 4,
        industryName: "Circle",
        name: "Cestus",
        type: "Heavy",
        projType: "energy",
        desc: `
        Heavy semi-automatic fireball cannon. Weapon emits blast effect, allowing it to deal a lot of damage.
        `,
        damageData: {
            base: 1200,
            level: [0, 100, 100, 100, 100, 150, 150, 200, 200, 200, 200, 200],
        },
        effectIncreaseData: {
            base: .017,
            level: [0, .0002, .0002, .0002, .0002, .0002, .0005, .0005, .0005, .0005, .0005, .0005]
        },
        motherShipCharge: 0.0015625,
        imageSource: "./images/weapons/cestus.png",
        fireRate: [480, 130, 130, 130, 130],
        ammo: 25,
        reload: 5e3,
        range: 2e3,
        aoeRange: 75,
        cost: {
            sliver: 15e9,
            gold: 150e3,
            workshopPoints: 75e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Heptagon",
        name: "Discordia",
        spread: 4,
        type: "Light",
        projType: "normal",
        desc: `
        Heptagon Industry's most wonderful creation.
        A improvement to the older models, Discordia is a light homing machine-gun that
        can rain bullets on enemies. After firing for 1 second, the weapon goes into a
        fast firing state and fires x2 faster. Improved homing system, it only targets enemies that
        can be damaged.
        `,
        damageData: {
            base: 90,
            level: [0, 13, 13, 13, 13, 13, 13, 13, 13, 27, 27, 39]
        },
        shotsPerFire: 2,
        motherShipCharge: 0.0002,
        imageSource: "./images/weapons/discordia.png",
        fireRate: 60,
        continuousReload: true,
        ammoEachReloadTick: 10,
        ammo: 90,
        reload: 1e3,
        range: 2000,
        cost: {
            sliver: 15e9,
            gold: 200e3,
            workshopPoints: 100e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Heptagon",
        name: "Tumultus",
        spread: 4,
        type: "Heavy",
        projType: "normal",
        desc: `
        Heptagon Industry's most wonderful creation.
        A improvement to the older models, Tumultus is a heavy homing machine-gun that
        can rain bullets on enemies. After firing for 1 second, the weapon goes into a
        fast firing state and fires x2 faster. Improved homing system, it only targets enemies that
        can be damaged.
        `,
        damageData: {
            base: 120,
            level: [0, 18, 18, 18, 18, 18, 18, 18, 18, 36, 36, 52]
        },
        shotsPerFire: 2,
        motherShipCharge: 0.0002,
        imageSource: "./images/weapons/tumultus.png",
        fireRate: 60,
        continuousReload: true,
        ammoEachReloadTick: 10,
        ammo: 90,
        reload: 1e3,
        range: 2000,
        cost: {
            sliver: 15e9,
            gold: 200e3,
            workshopPoints: 100e3
        }
    }, {
        spread: 15,
        dontSell: true,
        tier: 4,
        industryName: "Circle",
        name: "Vajra",
        type: "Light",
        projType: "energy",
        desc: `
        Light energy shotgun that fires 7 bullets.
        Large spread but high damage.
        Enemies get slowdown when they get hit.
        `,
        damageData: {
            base: 2875,
            level: [0, 631, 631, 631, 631, 631, 808, 1166, 1526, 1958, 2425, 2875]
        },
        motherShipCharge: 0.000357,
        imageSource: "./images/weapons/vajra.png",
        fireRate: 500,
        ammo: 15,
        reload: 8e3,
        range: 1500,
        cost: {
            sliver: 15e9,
            gold: 200e3,
            workshopPoints: 100e3
        }
    }, {
        spread: 15,
        dontSell: true,
        tier: 4,
        industryName: "Circle",
        name: "Maha Vajra",
        type: "Heavy",
        projType: "energy",
        desc: `
        Heavy energy shotgun that fires 7 bullets.
        Large spread but high damage.
        Enemies get slowdown when they get hit.
        `,
        damageData: {
            base: 4312,
            level: [0, 946, 946, 946, 946, 946, 1211, 1750, 2289, 2936, 3638, 4312]
        },
        motherShipCharge: 0.000357,
        imageSource: "./images/weapons/maha_vajra.png",
        fireRate: 500,
        ammo: 15,
        reload: 8e3,
        range: 1500,
        cost: {
            sliver: 15e9,
            gold: 200e3,
            workshopPoints: 100e3
        }
    }, {
        tier: 4,
        industryName: "Heptagon",
        name: "Fulgur",
        type: "Light",
        projType: "energy",
        desc: `
        Next generation of laser weapons, Fulgur is a light laser weapon that deals quick bursts of damage.
        It is ideal weapon to use aganist T5 shapes since it deals extra 225% more damage (+150% more to titans).
        `,
        damageData: {
            base: 796,
            level: [0, 49, 49, 81, 81, 81, 81, 162, 162, 105, 228, 325]
        },
        motherShipCharge: 0.0034,
        imageSource: "./images/weapons/fulgur.png",
        fireRate: 100,
        ammo: 10,
        reload: 8e3,
        range: 3800,
        cost: {
            sliver: 15e9,
            gold: 200e3,
            workshopPoints: 100e3
        }
    }, {
        tier: 4,
        industryName: "Heptagon",
        name: "Tonans",
        type: "Heavy",
        projType: "energy",
        desc: `
        Next generation of laser weapons, Tonans is a heavy laser weapon that deals quick bursts of damage.
        It is ideal weapon to use aganist T5 shapes since it deals extra 225% more damage (+150% more to titans).
        `,
        damageData: {
            base: 1194,
            level: [0, 74, 74, 122, 122, 122, 122, 243, 243, 157, 342, 487]
        },
        motherShipCharge: 0.0034,
        imageSource: "./images/weapons/tonans.png",
        fireRate: 100,
        ammo: 10,
        reload: 8e3,
        range: 3800,
        cost: {
            sliver: 15e9,
            gold: 200e3,
            workshopPoints: 100e3
        }
    }, {
        tier: 3,
        industryName: "Heptagon",
        name: "Talon",
        type: "Heavy",
        projType: "rocket",
        desc: `
        A heavy rocket weapon that shoots smart homing rockets that deal aoe damage.
        When enemies are directly hit,
        it applies rust (1%) and fragility (2.5%) effects to the enemies.
        Effects last for 10 seconds.
        `,
        damageData: {
            base: 1e3,
            level: [0, 200, 200, 200, 300, 350, 500, 550, 550, 550, 667, 888]
        },
        motherShipCharge: 0.005,
        aoeRange: 120,
        imageSource: "./images/weapons/talon.png",
        fireRate: 350,
        ammo: 24,
        reload: 5e3,
        range: 1800,
        cost: {
            sliver: 5e6,
            gold: 5e3,
            workshopPoints: 5e3
        }
    }, {
        tier: 3,
        industryName: "Heptagon",
        name: "Jaw",
        type: "Light",
        projType: "rocket",
        desc: `
        A light rocket weapon that shoots smart homing rockets that deal aoe damage.
        When enemies are directly hit,
        it applies rust (1%) and fragility (2.5%) effects to the enemies.
        Effects last for 10 seconds.
        `,
        damageData: {
            base: 667,
            level: [0, 133, 133, 133, 200, 233, 333, 367, 367, 367, 444, 592]
        },
        motherShipCharge: 0.005,
        aoeRange: 120,
        imageSource: "./images/weapons/jaw.png",
        fireRate: 350,
        ammo: 24,
        reload: 5e3,
        range: 1800,
        cost: {
            sliver: 5e6,
            gold: 5e3,
            workshopPoints: 5e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Circle",
        spread: 3,
        name: "Grief",
        type: "Light",
        projType: "normal",
        desc: `
        A light fast firing machine gun. After firing for 2 seconds, the weapon accelerates in fire rate and deals 80% gray damage instead of the normal 40%. This weapon also has a slight homing effect.
        `,
        damageData: {
            base: 128,
            level: [0, 17, 17, 17, 17, 17, 34, 34, 34, 34, 34, 34]
        },
        motherShipCharge: 0.00015,
        imageSource: "./images/weapons/grief.png",
        fireRate: 50,
        ammo: 400,
        reload: 8e3,
        range: 1e3,
        cost: {
            sliver: 15e9,
            gold: 200e3,
            workshopPoints: 100e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Circle",
        spread: 3,
        name: "Sorrow",
        type: "Heavy",
        projType: "normal",
        desc: `
        A heavy fast firing machine gun. After firing for 2 seconds, the weapon accelerates in fire rate and deals 80% gray damage instead of the normal 40%. This weapon also has a slight homing effect.
        `,
        damageData: {
            base: 192,
            level: [0, 26, 26, 26, 26, 26, 51, 51, 51, 51, 51, 51]
        },
        motherShipCharge: 0.00015,
        imageSource: "./images/weapons/sorrow.png",
        fireRate: 50,
        ammo: 400,
        reload: 8e3,
        range: 1e3,
        cost: {
            sliver: 15e9,
            gold: 200e3,
            workshopPoints: 100e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Circle",
        name: "Subduer",
        type: "Heavy",
        projType: "energy",
        desc: `The ultimate mixture of fire power, DoT, and rust. This weapon deals a lot of damage and applies rust and DoT to enemies.`,
        damageData: {
            base: 83 * 4,
            level: [0, 31, 47, 66, 77, 93, 108, 131, 150, 154, 171, 186].map(e => e * 4)
        },
        dotData: {
            base: 35 * 2,
            level: [0, 5, 5, 10, 10, 15, 15, 20, 20, 20, 25, 25].map(e => e * 2)
        },
        motherShipCharge: 0.0007,
        imageSource: "./images/weapons/subduer.png",
        fireRate: 35,
        ammo: 38,
        reload: 4e3,
        range: 1400,
        cost: {
            sliver: 60e6,
            gold: 300e3,
            workshopPoints: 100e3
        }
    }, {
        tier: 3,
        spread: 15,
        industryName: "Heptagon",
        name: "Vortex",
        type: "Light",
        projType: "rocket",
        desc: `
        Light rocket weapon that fires 7 homing rockets that deals immense damage to enemies. Its large AoE range allows it to easily hit more than one target at a time.
        `,
        damageData: {
            base: 15e3,
            level: [0, 500, 500, 500, 500, 1e3, 1e3, 1e3, 2e3, 2e3, 4e3, 5e3]
        },
        motherShipCharge: 0.001,
        aoeRange: 120,
        imageSource: "./images/weapons/vortex.png",
        fireRate: 500,
        ammo: 2,
        reload: 6e3,
        range: 3200,
        cost: {
            sliver: 5e6,
            gold: 5e3,
            workshopPoints: 5e3
        }
    }, {
        tier: 3,
        spread: 15,
        industryName: "Heptagon",
        name: "Thermite",
        type: "Heavy",
        projType: "rocket",
        desc: `
        Heavy rocket weapon that fires a total of 14 homing rockets that deals immense damage to enemies. Its large AoE range allows it to easily hit more than one target at a time.
        `,
        damageData: {
            base: 22500,
            level: [0, 750, 750, 750, 750, 1500, 1500, 1500, 3000, 3000, 6000, 7500]
        },
        motherShipCharge: 0.001,
        aoeRange: 120,
        imageSource: "./images/weapons/thermite.png",
        fireRate: 500,
        ammo: 2,
        reload: 6e3,
        range: 3200,
        cost: {
            sliver: 5e6,
            gold: 5e3,
            workshopPoints: 5e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Heptagon",
        name: "Leiming",
        type: "Light",
        projType: "energy",
        desc: `Super close ranged light laser arc weapon that deals a lot of damage in a short time. Every hit accumulates a lockdown effect that disables enemies from moving.`,
        damageData: {
            base: 716 * 2.5,
            level: [0, 120, 120, 148.8, 148.8, 148.8, 177.6, 177.6, 177.6, 177.6, 207.6, 237.6].map(e => e * 2.5)
        },
        motherShipCharge: 0.001,
        imageSource: "./images/weapons/leiming.png",
        fireRate: [450, 75, 75, 75, 75],
        ammo: 150,
        reload: 8e3,
        range: 450,
        cost: {
            sliver: 60e6,
            gold: 300e3,
            workshopPoints: 100e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Heptagon",
        name: "Fengbao",
        type: "Heavy",
        projType: "energy",
        desc: `Super close ranged heavy laser arc weapon that deals a lot of damage in a short time. Every hit accumulates a lockdown effect that disables enemies from moving.`,
        damageData: {
            base: 1074 * 3,
            level: [0, 180, 180, 223, 223, 223, 266, 266, 266, 266, 311, 356].map(e => e * 3)
        },
        motherShipCharge: 0.001,
        imageSource: "./images/weapons/fengbao.png",
        fireRate: [450, 75, 75, 75, 75],
        ammo: 150,
        reload: 8e3,
        range: 450,
        cost: {
            sliver: 60e6,
            gold: 300e3,
            workshopPoints: 100e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Pentagon",
        name: "Inferno",
        spread: 6.25,
        type: "Heavy",
        projType: "energy",
        desc: `New heavy flamerthrower that has unlimited ammo. New light flamerthrower that has unlimited ammo. After firing for a duration, the weapon overheats and is forced to cooldown.`,
        damageData: {
            base: 266,
            level: [0, 28, 30, 38, 42, 53, 53, 60, 69, 73, 82, 88]
        },
        shotsPerFire: 2,
        overheatTime: 12e3,
        motherShipCharge: 0.0005,
        imageSource: "./images/weapons/inferno.png",
        fireRate: 40,
        ammo: 1e300,
        reload: 0,
        range: 1e3,
        cost: {
            sliver: 60e6,
            gold: 300e3,
            workshopPoints: 100e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Pentagon",
        name: "Pyro",
        spread: 6.25,
        type: "Light",
        projType: "energy",
        desc: `New light flamerthrower that has unlimited ammo. After firing for a duration, the weapon overheats and is forced to cooldown.`,
        damageData: {
            base: 177,
            level: [0, 19, 20, 25, 28, 35, 35, 40, 46, 49, 55, 59]
        },
        shotsPerFire: 2,
        overheatTime: 12e3,
        motherShipCharge: 0.0005,
        imageSource: "./images/weapons/pyro.png",
        fireRate: 40,
        ammo: 1e300,
        reload: 0,
        range: 1e3,
        cost: {
            sliver: 60e6,
            gold: 300e3,
            workshopPoints: 100e3
        }
    }, {
        tier: 3,
        industryName: "Circle",
        name: "Blight",
        type: "Light",
        projType: "energy",
        desc: `A radiation gun which fires in short burst of 3 shots. Each shot following the first deals increased damaged up to 300%.`,
        damageData: {
            base: 1610,
            level: [0, 101, 101, 101, 151, 151, 151, 151, 151, 151, 161, 201]
        },
        motherShipCharge: 0.002,
        imageSource: "./images/weapons/blight.png",
        fireRate: [400, 125, 125],
        ammo: 9,
        reload: 4e3,
        range: 2e3,
        cost: {
            sliver: 5e6,
            gold: 3e3,
            workshopPoints: 1e3
        }
    }, {
        tier: 3,
        industryName: "Circle",
        name: "Decay",
        type: "Heavy",
        projType: "energy",
        desc: `A radiation gun which fires in short burst of 3 shots. Each shot following the first deals increased damaged up to 300%.`,
        damageData: {
            base: 2415,
            level: [0, 152, 152, 152, 227, 227, 227, 227, 227, 227, 242, 301]
        },
        motherShipCharge: 0.002,
        imageSource: "./images/weapons/decay.png",
        fireRate: [400, 75, 75],
        ammo: 9,
        reload: 3e3,
        range: 2e3,
        cost: {
            sliver: 5e6,
            gold: 3e3,
            workshopPoints: 1e3
        }
    }, {
        dontShow: true,
        dontSell: true,
        tier: 4,
        industryName: "Circle",
        spread: 4.5,
        name: "Ultimate Punisher",
        type: "Light",
        projType: "normal",
        desc: `
        ${addUltimateTextToWeapon("Punisher")}<br><br>
        Multi-barreled machine gun with a high rate of fire. Great at close range. Projectiles fired deal structural damage.
        `,
        damageData: {
            base: 71,
            level: [0, 9, 9, 17, 17, 33, 33, 41, 41, 56, 56, 66]
        },
        defenseBypass: 1,
        shotsPerFire: 2,
        motherShipCharge: 0.0001,
        imageSource: "./images/weapons/ultimate_punisher.png",
        fireRate: 70,
        ammo: 200,
        reload: 8e3,
        range: 2e3,
        cost: {
            sliver: 50e6,
            gold: 100e3,
            workshopPoints: 100e3
        }
    }, {
        dontShow: true,
        dontSell: true,
        tier: 4,
        industryName: "Circle",
        spread: 4.5,
        name: "Ultimate Destroyer",
        type: "Heavy",
        projType: "normal",
        desc: `
        ${addUltimateTextToWeapon("Destroyer")}<br><br>
        Large heavy multi-barreled machine gun. 
        Great at close range since bullets disperse due to high fire rate. 
        Each round shoots 4 projectiles. Projectiles fired deal structural damage.
        `,
        damageData: {
            base: 51,
            level: [0, 8, 8, 11, 11, 26, 26, 31, 31, 38, 38, 51]
        },
        shotsPerFire: 4,
        defenseBypass: 1,
        motherShipCharge: 0.00014,
        imageSource: "./images/weapons/ultimate_destroyer.png",
        fireRate: 70,
        ammo: 200,
        reload: 8e3,
        range: 2e3,
        cost: {
            sliver: 50e6,
            gold: 100e3,
            workshopPoints: 100e3
        }
    }, {
        dontSell: true,
        tier: 4,
        spread: 11,
        industryName: "Octagon",
        name: "Hammer",
        type: "Heavy",
        projType: "rocket",
        desc: `A heavy shotgun that fires quickly. The projectiles fired emits blast effect.`,
        damageData: {
            base: 2300,
            level: [0, 230, 230, 230, 230, 460, 460, 690, 690, 690, 690, 920]
        },
        effectIncreaseData: {
            base: .0149,
            level: [0, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0006, 0.0006, 0.0006, 0.0006, 0.001]
        },
        motherShipCharge: 0.00025,
        imageSource: "./images/weapons/hammer.png",
        fireRate: 200,
        ammo: 12,
        reload: 5e3,
        range: 800,
        aoeRange: 75,
        cost: {
            sliver: 15e9,
            gold: 150e3,
            workshopPoints: 50e3
        }
    }, {
        dontSell: true,
        tier: 4,
        spread: 11,
        industryName: "Octagon",
        name: "Mace",
        type: "Light",
        projType: "rocket",
        desc: `A light shotgun that fires quickly. The projectiles fired emits blast effect.`,
        damageData: {
            base: 1534,
            level: [0, 154, 154, 154, 154, 306, 306, 460, 460, 460, 460, 614]
        },
        effectIncreaseData: {
            base: .0149,
            level: [0, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0006, 0.0006, 0.0006, 0.0006, 0.001]
        },
        motherShipCharge: 0.00025,
        imageSource: "./images/weapons/mace.png",
        fireRate: 200,
        ammo: 12,
        reload: 5e3,
        range: 800,
        aoeRange: 75,
        cost: {
            sliver: 15e9,
            gold: 150e3,
            workshopPoints: 50e3
        }
    }, {
        tier: 0,
        industryName: "Circle",
        spread: 3,
        name: "Retaliator",
        type: "Light",
        projType: "normal",
        titan: true,
        desc: `A light titan machinegun that fires many projectiles in short bursts.`,
        damageData: {
            base: 655,
            level: [0, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 30, 30, 30, 30, 30, 30, 40, 40, 40, 40, 40]
        },
        defenseBypassData: { ...defensePointsByPassTo75 },
        motherShipCharge: 0.000125,
        imageSource: "./images/weapons/punisher.png",
        fireRate: 65,
        ammo: 220,
        reload: 10e3,
        range: 1600,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 5e3
        }
    }, {
        tier: 0,
        industryName: "Circle",
        spread: 3,
        name: "Vengeance",
        type: "Heavy",
        projType: "normal",
        titan: true,
        desc: `A heavy titan machinegun that fires many projectiles in short bursts.`,
        damageData: {
            base: 983,
            level: [0, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 40, 40, 40, 40, 40, 45, 45, 45, 45, 45, 45, 60, 60]
        },
        defenseBypassData: { ...defensePointsByPassTo100 },
        motherShipCharge: 0.000125,
        imageSource: "./images/weapons/destroyer.png",
        fireRate: 65,
        ammo: 220,
        reload: 10e3,
        range: 1600,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 5e3
        }
    }, {
        tier: 1,
        industryName: "Circle",
        name: "Rupture",
        type: "Light",
        projType: "rocket",
        desc: `A light titan rocket weapon that fires many rockets quickly.`,
        damageData: {
            base: 1500,
            level: [0, 50, 50, 50, 75, 75, 75, 75, 75, 150, 150, 150, 150, 200, 200, 200, 200, 200, 200, 200, 200, 250, 250, 250, 350]
        },
        defenseBypassData: { ...defensePointsByPassTo75 },
        motherShipCharge: 0.00003,
        ammoEachReloadTick: 4,
        continuousReload: true,
        titan: true,
        imageSource: "./images/weapons/landslide.png",
        aoeRange: 160,
        fireRate: 100,
        ammo: 32,
        reload: 1500,
        range: 800,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 25e3
        }
    }, {
        tier: 1,
        industryName: "Circle",
        name: "Orkan",
        type: "Heavy",
        projType: "rocket",
        desc: `A heavy titan rocket weapon that fires many rockets quickly.`,
        damageData: {
            base: 2250,
            level: [0, 75, 75, 75, 113, 113, 113, 113, 113, 225, 225, 225, 225, 300, 300, 300, 300, 300, 300, 300, 300, 375, 375, 375, 525]
        },
        defenseBypassData: { ...defensePointsByPassTo100 },
        motherShipCharge: 0.00003,
        ammoEachReloadTick: 4,
        continuousReload: true,
        titan: true,
        imageSource: "./images/weapons/avalanche.png",
        aoeRange: 160,
        fireRate: 100,
        ammo: 32,
        reload: 1500,
        range: 800,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 25e3
        }
    }, {
        dontSell: true,
        tier: 3,
        industryName: "Circle",
        name: "Disintegrator",
        spread: 5,
        projType: "normal",
        type: "Heavy",
        desc: `
        A heavy titan sonic machine gun that fires 2 projectiles per burst.
        After 2 seconds of continuous fire, the weapon goes into increased firing state, and fires x1.5 faster.
        The sonic blasts that are shot only deal [GRAY DAMAGE].
        `,
        damageData: {
            base: 1116,
            level: [0, 6, 6, 6, 6, 6, 6, 12, 12, 25, 12, 12, 12, 12, 25, 25, 25, 25, 25, 35, 35, 35, 35, 35, 35]
        },
        titan: true,
        shotsPerFire: 2,
        motherShipCharge: 0.00011,
        defenseBypassData: { ...defensePointsByPassTo100 },
        imageSource: "./images/weapons/veyron.png",
        fireRate: 50,
        ammo: 125,
        reload: 8e3,
        range: 1200,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 105e3
        }
    }, {
        dontSell: true,
        tier: 3,
        industryName: "Circle",
        name: "Havoc",
        spread: 5,
        projType: "normal",
        type: "Light",
        desc: `
        A light titan sonic machine gun that fires 2 projectiles per burst.
        After 2 seconds of continuous fire, the weapon goes into increased firing state, and fires x1.5 faster.
        The sonic blasts that are shot only deal [GRAY DAMAGE].
        `,
        damageData: {
            base: 744,
            level: [0, 4, 4, 4, 4, 4, 4, 8, 8, 17, 8, 8, 8, 8, 17, 17, 17, 17, 17, 23, 23, 23, 23, 23, 23]
        },
        titan: true,
        shotsPerFire: 2,
        motherShipCharge: 0.00011,
        defenseBypassData: { ...defensePointsByPassTo75 },
        imageSource: "./images/weapons/evora.png",
        fireRate: 50,
        ammo: 125,
        reload: 8e3,
        range: 1200,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 105e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Pentagon",
        name: "Discharger",
        spread: 3,
        type: "Heavy",
        projType: "energy",
        desc: `A heavy titan flamethrower that could fire unlimited ammo. After firing for a extended period of time, the weapon is forced to cooldown for safety purposes.`,
        damageData: {
            base: 1275,
            level: [0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50]
        },
        titan: true,
        shotsPerFire: 2,
        overheatTime: 10e3,
        motherShipCharge: 0.000175,
        defenseBypassData: { ...defensePointsByPassTo100 },
        imageSource: "./images/weapons/inferno.png",
        fireRate: 20,
        ammo: 1e300,
        reload: 0,
        range: 1e3,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 205e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Pentagon",
        name: "Igniter",
        spread: 3,
        type: "Light",
        projType: "energy",
        desc: `A light titan flamethrower that could fire unlimited ammo. After firing for a extended period of time, the weapon is forced to cooldown for safety purposes.`,
        damageData: {
            base: 850,
            level: [0, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33]
        },
        titan: true,
        shotsPerFire: 2,
        overheatTime: 10e3,
        motherShipCharge: 0.000175,
        defenseBypassData: { ...defensePointsByPassTo75 },
        imageSource: "./images/weapons/pyro.png",
        fireRate: 20,
        ammo: 1e300,
        reload: 0,
        range: 1e3,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 205e3
        }
    }, {
        tier: 4,
        industryName: "Heptagon",
        name: "Athos",
        type: "Light",
        desc: `Light laser weapon that fires on single targets. It has a life-steal effect that makes it so that 30% of the damage done on enemies is repaired.`,
        damageData: {
            base: 941 * 3.5,
            level: [0, 38, 38, 38, 57, 57, 57, 57, 75, 75, 75, 75].map(e => e * 1.5),
        },
        healBackOnDamage: .6,
        motherShipCharge: 0.0005,
        imageSource: "./images/weapons/athos.png",
        continuousReload: true,
        fireRate: 75,
        ammo: 120,
        ammoEachReloadTick: 20,
        reload: 3e3,
        range: 1200,
        cost: {
            sliver: 15e9,
            gold: 150e3,
            workshopPoints: 50e3
        }
    }, {
        tier: 4,
        industryName: "Heptagon",
        name: "Aramis",
        type: "Heavy",
        desc: `Heavy laser weapon that fires on single targets. It has a life-steal effect that makes it so that 60% of the damage done on enemies is repaired.`,
        damageData: {
            base: 1412 * 4,
            level: [0, 57, 57, 57, 86, 86, 86, 86, 113, 113, 113, 113].map(e => e * 2),
        },
        healBackOnDamage: .9,
        motherShipCharge: 0.0005,
        imageSource: "./images/weapons/aramis.png",
        continuousReload: true,
        fireRate: 75,
        ammo: 120,
        ammoEachReloadTick: 20,
        range: 1200,
        cost: {
            sliver: 15e9,
            gold: 150e3,
            workshopPoints: 50e3
        }
    }, {
        dontSell: true,
        tier: 2,
        industryName: "Pentagon",
        name: "Striker",
        type: "Heavy",
        projType: "energy",
        desc: ``,
        damageData: {
            base: 10e3,
            level: [0, 313, 313, 563, 563, 563, 563, 563, 813, 813, 813, 813, 1063, 1063, 1063, 1063, 1063, 1313, 1313, 1313, 1813, 1813, 1813, 3063, 3063]
        },
        titan: true,
        chargingMechanic: true,
        chargingDelay: 2e3,
        motherShipCharge: 0.0007,
        defenseBypassData: { ...defensePointsByPassTo100 },
        imageSource: "./images/weapons/glaive.png",
        fireRate: 0,
        ammo: 1,
        reload: 6e3,
        range: 4e3,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 75e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Circle",
        name: "Vendicatore",
        type: "Heavy",
        projType: "normal",
        desc: ``,
        damageData: {
            base: 10e3,
            level: [0, 400, 400, 500, 500, 600, 600, 600, 750, 750, 850, 850, 1e3, 1e3, 1200, 1200, 1200, 1350, 1350, 1350, 1800, 1800, 1800, 2500, 3e3]
        },
        titan: true,
        motherShipCharge: 0.0014,
        defenseBypassData: { ...defensePointsByPassTo100 },
        imageSource: "./images/weapons/reaper.png",
        fireRate: 500,
        ammo: 6,
        reload: 8e3,
        range: 4e3,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 205e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Heptagon",
        name: "Razdor",
        spread: 4,
        type: "Heavy",
        projType: "normal",
        desc: ``,
        damageData: {
            base: 1118,
            level: [0, 22, 22, 22, 22, 27, 27, 27, 27, 27, 27, 34, 34, 34, 34, 34, 34, 34, 34, 40, 40, 40, 46, 46, 46]
        },
        titan: true,
        shotsPerFire: 2,
        motherShipCharge: 0.0002,
        defenseBypassData: { ...defensePointsByPassTo100 },
        imageSource: "./images/weapons/tumultus.png",
        fireRate: 130,
        continuousReload: true,
        ammoEachReloadTick: 5,
        ammo: 100,
        reload: 1e3,
        range: 3e3,
        cost: {
            sliver: 0,
            gold: 50e3,
            workshopPoints: 205e3
        }
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Heptagon",
        name: "Kramola",
        spread: 4,
        type: "Light",
        projType: "normal",
        desc: ``,
        damageData: {
            base: 797,
            level: [0, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 24, 24, 24, 24, 24, 24, 24, 24, 28, 28, 28, 32, 32, 32]
        },
        titan: true,
        shotsPerFire: 2,
        motherShipCharge: 0.0002,
        defenseBypassData: { ...defensePointsByPassTo75 },
        imageSource: "./images/weapons/discordia.png",
        fireRate: 130,
        continuousReload: true,
        ammoEachReloadTick: 5,
        ammo: 100,
        reload: 1e3,
        range: 3e3,
        cost: {
            sliver: 0,
            gold: 50e3,
            workshopPoints: 205e3
        }
    }, {
        tier: 3,
        industryName: "Circle",
        name: "Halo",
        spread: 12,
        type: "Light",
        projType: "energy",
        desc: `Light energy lockdown shotgun. Every direct hit would gain a lockdown accumulation effect, which would result in a lockdown effect after reaching 100%.`,
        damageData: {
            base: 5e3,
            level: [0, 312, 438, 438, 562, 562, 688, 688, 688, 812, 812, 938]
        },
        effectIncreaseData: {
            base: .00125,
            level: [0, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125]
        },
        motherShipCharge: 0.0007,
        imageSource: "./images/weapons/halo.png",
        fireRate: 300,
        continuousReload: true,
        ammoEachReloadTick: 1,
        ammo: 10,
        reload: 1800,
        range: 1500,
        cost: {
            sliver: 10e6,
            gold: 6e3,
            workshopPoints: 1e3
        }
    }, {
        tier: 3,
        industryName: "Circle",
        name: "Glory",
        spread: 12,
        type: "Heavy",
        projType: "energy",
        desc: `Heavy energy lockdown shotgun. Every direct hit would gain a lockdown accumulation effect, which would result in a lockdown effect after reaching 100%.`,
        damageData: {
            base: 7500,
            level: [0, 468, 657, 657, 843, 843, 1032, 1032, 1032, 1218, 1218, 1407]
        },
        effectIncreaseData: {
            base: .00125,
            level: [0, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125]
        },
        motherShipCharge: 0.0007,
        imageSource: "./images/weapons/glory.png",
        fireRate: 300,
        continuousReload: true,
        ammoEachReloadTick: 1,
        ammo: 10,
        reload: 1800,
        range: 1500,
        cost: {
            sliver: 10e6,
            gold: 6e3,
            workshopPoints: 1e3
        }
    }, {
        dontShow: true,
        dontSell: true,
        tier: 4,
        industryName: "Circle",
        name: "Ultimate Halo",
        spread: 12,
        type: "Light",
        projType: "energy",
        desc: `${addUltimateTextToWeapon("Halo")}<br><br>Light energy lockdown shotgun. Every direct hit would gain a lockdown accumulation effect, which would result in a lockdown effect after reaching 100%.`,
        damageData: {
            base: 3625,
            level: [0, 351, 493, 493, 632, 632, 774, 774, 774, 913, 913, 1055]
        },
        defenseBypass: 1,
        effectIncreaseData: {
            base: .05,
            level: [0, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125]
        },
        motherShipCharge: 0.0001,
        imageSource: "./images/weapons/ultimate_halo.png",
        fireRate: 150,
        continuousReload: true,
        ammoEachReloadTick: 2,
        ammo: 10,
        reload: 1e3,
        range: 1500,
        cost: {
            sliver: 1e9,
            gold: 50e3,
            workshopPoints: 100e3
        }
    }, {
        dontShow: true,
        dontSell: true,
        tier: 4,
        industryName: "Circle",
        name: "Ultimate Glory",
        spread: 12,
        type: "Heavy",
        projType: "energy",
        desc: `${addUltimateTextToWeapon("Glory")}<br><br>Light energy lockdown shotgun. Every direct hit would gain a lockdown accumulation effect, which would result in a lockdown effect after reaching 100%.`,
        damageData: {
            base: 6438,
            level: [0, 527, 740, 740, 948, 948, 1161, 1161, 1161, 1370, 1370, 1583]
        },
        defenseBypass: 1,
        effectIncreaseData: {
            base: .05,
            level: [0, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125, .00125]
        },
        motherShipCharge: 0.0001,
        imageSource: "./images/weapons/ultimate_glory.png",
        fireRate: 150,
        continuousReload: true,
        ammoEachReloadTick: 2,
        ammo: 10,
        reload: 1e3,
        range: 1500,
        cost: {
            sliver: 1e9,
            gold: 50e3,
            workshopPoints: 100e3
        }
    }, {
        tier: 3,
        industryName: "Circle",
        name: "Spark",
        type: "Light",
        projType: "energy",
        desc: `A light laser weapon that deals increased damage the closer the enemy is. At <=350 PX, the weapon deals 100-200% damage, and at 350+ the weapon deals 5-100% damage.`,
        damageData: {
            base: 415,
            level: [0, 45, 45, 45, 65, 65, 65, 65, 65, 65, 95, 125]
        },
        motherShipCharge: 0.001,
        imageSource: "./images/weapons/spark.png",
        fireRate: 25,
        ammo: 100,
        reload: 6e3,
        range: 1500,
        cost: {
            sliver: 10e6,
            gold: 5e3,
            workshopPoints: 1e3
        }
    }, {
        tier: 3,
        industryName: "Circle",
        name: "Calamity",
        type: "Heavy",
        projType: "energy",
        desc: `A heavy laser weapon that deals increased damage the closer the enemy is. At <=350 PX, the weapon deals 100-200% damage, and at 350+ the weapon deals 5-100% damage.`,
        damageData: {
            base: 685,
            level: [0, 74, 74, 74, 107, 107, 107, 107, 107, 107, 157, 206]
        },
        motherShipCharge: 0.001,
        imageSource: "./images/weapons/calamity.png",
        fireRate: 25,
        ammo: 100,
        reload: 6e3,
        range: 1500,
        cost: {
            sliver: 10e6,
            gold: 5e3,
            workshopPoints: 1e3
        }
    }, {
        spread: 45,
        dontSell: true,
        tier: 4,
        industryName: "Pentagon",
        name: "Anguisher",
        spread: 3,
        type: "Heavy",
        projType: "normal",
        desc: `THERE'S A STAR MAN WAITING IN THE SKY HE LIKE TO COME AND SEE US BUT HE THINK HE'LL BLOW OUR MIND THERE'S A STAR MANNNN.`,
        damageData: {
            base: 35500,
            level: [0, 450, 450, 450, 450, 900, 900, 900, 900, 900, 900, 900, 900, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 3600, 3600, 3600, 3600]
        },
        dotData: {
            base: 5000,
            level: [0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 150, 150, 150, 150, 150]
        },
        titan: true,
        motherShipCharge: 0.000175,
        defenseBypassData: { ...defensePointsByPassTo100 },
        imageSource: "./images/weapons/inferno.png",
        fireRate: [750, 250],
        ammo: 8,
        reload: 4e3,
        range: 1400,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 205e3
        }
    }, {
        spread: 45,
        dontSell: true,
        tier: 4,
        industryName: "Pentagon",
        name: "Ruiner",
        spread: 3,
        type: "Light",
        projType: "normal",
        desc: `.`,
        damageData: {
            base: 35500 * .75,
            level: [0, 450, 450, 450, 450, 900, 900, 900, 900, 900, 900, 900, 900, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 3600, 3600, 3600, 3600].map(e => e * .75)
        },
        dotData: {
            base: 5000 * .75,
            level: [0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 150, 150, 150, 150, 150].map(e => e * .75)
        },
        titan: true,
        motherShipCharge: 0.000175,
        defenseBypassData: { ...defensePointsByPassTo75 },
        imageSource: "./images/weapons/spark.png",
        fireRate: [750, 250],
        ammo: 8,
        reload: 4e3,
        range: 1400,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 205e3
        }
    }, {
        tier: 4,
        industryName: "Hexagon",
        name: "Screamer",
        projType: "normal",
        type: "Heavy",
        spread: 8,
        desc: ``,
        damageData: {
            base: 4800,
            level: [0, 896, 933, 1036, 1118, 1200, 1332, 1407, 1581, 1662, 1729, 2051]
        },
        motherShipCharge: 0.0003,
        imageSource: "./images/weapons/scatter.png",
        fireRate: [450, 50],
        ammo: 16,
        reload: 4600,
        range: 1700,
        cost: {
            sliver: 5e6,
            gold: 5e3
        }
    }, {
        tier: 4,
        industryName: "Hexagon",
        name: "Growler",
        projType: "normal",
        type: "Light",
        spread: 8,
        desc: ``,
        damageData: {
            base: 4800 * .75,
            level: [0, 896, 933, 1036, 1118, 1200, 1332, 1407, 1581, 1662, 1729, 2051].map(e => e * .75)
        },
        motherShipCharge: 0.0003,
        imageSource: "./images/weapons/scatter.png",
        fireRate: [450, 50],
        ammo: 16,
        reload: 4600,
        range: 1700,
        cost: {
            sliver: 5e6,
            gold: 5e3
        }
    }, {
        tier: 4,
        industryName: "Pentagon",
        name: "Volt",
        type: "Light",
        projType: "normal",
        desc: ``,
        damageData: {
            base: 7e3,
            level: [0, 500, 500, 500, 1e3, 1e3, 2e3, 2e3, 3e3, 4e3, 5e3, 7e3]
        },
        chargingMechanic: true,
        chargingDelay: 2e3,
        motherShipCharge: 0.0017,
        defenseBypass: 1,
        imageSource: "./images/weapons/lance.png",
        fireRate: 0,
        ammo: 1,
        reload: 8e3,
        range: 3e3,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 75e3
        }
    }, {
        tier: 4,
        industryName: "Pentagon",
        name: "Gauss",
        type: "Heavy",
        projType: "normal",
        desc: ``,
        damageData: {
            base: 7e3 * 1.5,
            level: [0, 500, 500, 500, 1e3, 1e3, 2e3, 2e3, 3e3, 4e3, 5e3, 7e3].map(e => e * 1.5)
        },
        chargingMechanic: true,
        chargingDelay: 2e3,
        motherShipCharge: 0.0017,
        defenseBypass: 1,
        imageSource: "./images/weapons/glaive.png",
        fireRate: 0,
        ammo: 1,
        reload: 8e3,
        range: 3e3,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 175e3
        }
    }];
    //5000,25000,75000,105000,205000
    class module {
        constructor(data, ownerSID = null, slot = null) {
            this.name = data.name;
            this.owner = ownerSID;
            this.slot = slot;
            this.desc = data.desc;
            this.tier = data.tier;
            this.imageSource = data.imageSource;
            this.level = 1;
            this.titan = data.titan || false;
            this.healthIncrease = data.healthIncrease;
            if (data.healthIncreaseData) {
                this.healthIncrease = data.healthIncreaseData.base;
            }
            this.grayDamageFixRepair = data.grayDamageFixRepair;
            if (data.grayDamageFixRepairData) {
                this.grayDamageFixRepair = data.grayDamageFixRepairData.base;
            }
            this.selfFixRepair = data.selfFixRepair;
            if (data.selfFixRepairData) {
                this.selfFixRepair = data.selfFixRepairData.base;
            }
            this.dmgIncrease = data.dmgIncrease;
            if (data.dmgIncreaseData) {
                this.dmgIncrease = data.dmgIncreaseData.base;
            }
            this.immunePercent = data.immunePercent;
            if (data.immunePercentData) {
                this.immunePercent = data.immunePercentData.base;
            }
            this.lastingTime = data.lastingTime;
            if (data.lastingTimeData) {
                this.lastingTime = data.lastingTimeData.base;
            }
            this.shieldRegen = data.shieldRegen;
            if (data.shieldRegenData) {
                this.shieldRegen = data.shieldRegenData.base;
            }
            this.durabilityLostAmp = data.durabilityLostAmp;
            if (data.durabilityLostAmpData) {
                this.durabilityLostAmp = data.durabilityLostAmpData.base;
            }
            this.increasedDefensePoints = data.increasedDefensePoints;
            if (data.increasedDefensePointsData) {
                this.increasedDefensePoints = data.increasedDefensePointsData.base;
            }
            this.shieldHealth = data.shieldHealth;
            if (data.shieldHealthData) {
                this.shieldHealth = data.shieldHealthData.base;
            }
            this.defensePointsIncrease = data.defensePointsIncrease;
            if (data.defensePointsIncreaseData) {
                this.defensePointsIncrease = data.defensePointsIncreaseData.base;
            }
            this.titanCharge = data.titanCharge;
            if (data.titanChargeData) {
                this.titanCharge = data.titanChargeData.base;
            }
            this.grayDamageDecrease = data.grayDamageDecrease;
            if (data.grayDamageDecreaseData) {
                this.grayDamageDecrease = data.grayDamageDecreaseData.base;
            }
            this.antiControl = data.antiControl;
            if (data.antiControlData) {
                this.antiControl = data.antiControlData.base;
            }
            this.nuclearAmp = data.nuclearAmp;
            if (data.nuclearAmpData) {
                this.nuclearAmp = data.nuclearAmpData.base;
            }
        }
    }
    var moduleData = [{
        tier: 0,
        name: "Armor Plating",
        desc: `
        Increases shape's durability.
        `,
        healthIncreaseData: {
            base: 0.02,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.01]
        },
        imageSource: "./images/modules/armor_plating.png",
        cost: {
            sliver: 500e3,
            gold: 0
        }
    }, {
        tier: 1,
        name: "Heavy Armor Plating",
        desc: `
        Heavy armor kit, allows for even more protection to your shapes.
        `,
        healthIncreaseData: {
            base: 0.08,
            level: [0, 0.02, 0.02, 0.02, 0.02, 0.02]
        },
        imageSource: "./images/modules/heavy_armor_plating.png",
        cost: {
            sliver: 0,
            gold: 1e3
        }
    }, {
        tier: 2,
        name: "Self Fix Unit",
        desc: `
        Repairs a portion of a shape's maximum durability each second.
        `,
        selfFixRepairData: {
            base: 756,
            level: [0, 378, 378, 378, 1092, 1092]
        },
        imageSource: "./images/modules/self_fix_unit.png",
        cost: {
            sliver: 0,
            gold: 1500
        }
    }, {
        tier: 0,
        name: "Nuclear Reactor",
        desc: `
        Increases shape's weapon damage output.
        `,
        dmgIncreaseData: {
            base: 0.02,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.01]
        },
        imageSource: "./images/modules/nuclear_reactor.png",
        cost: {
            sliver: 500e3,
            gold: 0
        }
    }, {
        tier: 1,
        name: "Thermonuclear Reactor",
        desc: `
        Thermonuclear Reactor, increases weapon damage output even more.
        `,
        dmgIncreaseData: {
            base: 0.06,
            level: [0, 0.02, 0.02, 0.02, 0.02, 0.04]
        },
        imageSource: "./images/modules/thermonuclear_reactor.png",
        cost: {
            sliver: 0,
            gold: 1e3
        }
    }, {
        tier: 3,
        name: "Balance Unit",
        desc: `
        Increases shape's durability and weapon damage output.
        `,
        healthIncreaseData: {
            base: 0.05,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.03]
        },
        dmgIncreaseData: {
            base: 0.04,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.02]
        },
        imageSource: "./images/modules/balance_unit.png",
        cost: {
            sliver: 0,
            gold: 5e3
        }
    }, {
        tier: 3,
        name: "Last Stand",
        desc: `
        One the shape enters low durability, it gains a huge amount of defense points for X seconds.
        This module only can be used once per battle. The more modules to equip, the quicker you'll gain the defense points.
        `,
        immunePercentData: {
            base: 0.05,
            level: [0, 0.05, 0.05, 0.05, 0.05, 0.05]
        },
        lastingTimeData: {
            base: 2e3,
            level: [0, 500, 500, 500, 500, 500]
        },
        imageSource: "./images/modules/last_stand.png",
        cost: {
            sliver: 25e6,
            gold: 5e3
        }
    }, {
        tier: 2,
        name: "Fortifier",
        desc: `
        Increases the regen speed and durability of shields.
        `,
        shieldHealthData: {
            base: 0.05,
            level: [0, 0.05, 0.05, 0.05, 0.05, 0.05]
        },
        shieldRegenData: {
            base: 0.1,
            level: [0, 0.02, 0.02, 0.02, 0.02, 0.02]
        },
        imageSource: "./images/modules/fortifier.png",
        cost: {
            sliver: 500e3,
            gold: 2e3
        }
    }, {
        tier: 3,
        name: "Damage Controller",
        desc: `
        Increases shape health and decreases gray damage taken.
        `,
        healthIncreaseData: {
            base: 0.03,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.01]
        },
        grayDamageDecreaseData: {
            base: 0.04,
            level: [0, 0.02, 0.02, 0.02, 0.02, 0.03]
        },
        imageSource: "./images/modules/damage_controller.png",
        cost: {
            sliver: 25e6,
            gold: 5e3
        }
    }, {
        tier: 3,
        name: "Repair Amplifier",
        desc: `
        When receiving damage, your shape gains a 0.03% bonus to regeneration for the entire battle.
        When the maximum bonuses are reached, the robot gains increased defense points and restores a percentage of gray damage.
        When installing several such modules, the speed of receiving bonuses increases, but not their maximum value.<br><br>
        MAX STACKS: 60
        `,
        durabilityLostAmpData: {
            base: 0.08,
            level: [0, -0.01, -0.01, -0.01, -0.01, -0.01]
        },
        increasedDefensePointsData: {
            base: 20,
            level: [0, 1, 1, 1, 1, 1]
        },
        imageSource: "./images/modules/repair_amplifier.png",
        cost: {
            sliver: 25e6,
            gold: 5e3,
            workshopPoints: 10e3
        }
    }, {
        tier: 3,
        name: "Anti Control",
        desc: `
        Reduces the duration of negative effects.
        When installing several such modules, the bonus won't stack.
        `,
        antiControlData: {
            base: .25,
            level: [0, 0.05, 0.05, 0.05, 0.05, 0.05]
        },
        imageSource: "./images/modules/anticontrol.png",
        cost: {
            sliver: 25e6,
            gold: 5e3,
            workshopPoints: 10e3
        }
    }, {
        tier: 3,
        name: "Nuclear Amplifier",
        desc: `
        For every 25,000 damage inflicted on the enemy,
        your shape receives a small damage boost for the entire battle.
        Upon reaching the maximum possible bonuses,
        the robot recovers part of its durability (one second duration).
        Several modules increase how fast a robot gets bonuses,
        but not their maximum limit.
        `,
        nuclearAmpData: {
            base: .003,
            level: [0, 0.001, 0.001, 0.001, 0.001, 0.001]
        },
        selfFixRepairData: {
            base: 50e3,
            level: [0, 10e3, 10e3, 10e3, 10e3, 10e3]
        },
        imageSource: "./images/modules/nuclear_amplifier.png",
        cost: {
            sliver: 25e6,
            gold: 5e3,
            workshopPoints: 10e3
        }
    }, {
        dontSell: true,
        tier: 3,
        name: "Immune Amplifier",
        desc: `
        For every 30,000 damage received, the shape gets a small bonus to increase
        its max durability for the entire battle. Upon reaching 20 bonuses, the shape becomes
        immune to [FREEZE]; upon reaching 40 possible bonuses, the shape becomes immune to [SLOWDOWN];
        upon reaching the max 60 bonuses, the shape becomes immune to [RUST].<br><br>
        When installing several such modules, the speed of receiving bonuses increases, but not their maximum amount
        `,
        healthIncreaseData: {
            base: .005,
            level: [0, .005, .01, .01, .01, .01]
        },
        imageSource: "./images/modules/immune_amplifier.png",
        cost: {
            sliver: 25e6,
            gold: 5e3,
            workshopPoints: 10e3
        }
    }, {
        dontSell: true,
        tier: 4,
        name: "Defense Amplifier",
        desc: `
        For every 40,000 health repaired, the shape gains a small increase in power to its defense system.
        Once it reaches, the total 60 stacks, the shape becomes immune to defense mitigation for some time.
        `,
        imageSource: "./images/modules/defense_amplifier.png",
        defensePointsIncreaseData: {
            base: 1,
            level: [0, .2, .2, .2, .2, .2]
        },
        cost: {
            sliver: 15e9,
            gold: 100e3,
            workshopPoints: 50e3
        }
    }, {
        tier: 0,
        name: "Titan Armor Kit",
        desc: `
        Increases titan's durability.
        `,
        titan: true,
        healthIncreaseData: {
            base: 0.01,
            level: [0, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005]
        },
        imageSource: "./images/modules/armor_plating.png",
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 2500
        }
    }, {
        tier: 1,
        name: "Titan Heavy Armor Kit",
        desc: `
        Increases titan's durability greatly.
        `,
        titan: true,
        healthIncreaseData: {
            base: 0.03,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005]
        },
        imageSource: "./images/modules/heavy_armor_plating.png",
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 7e3
        }
    }, {
        tier: 0,
        name: "Singular Reactor",
        desc: `
        Increases titan's weapon damage output.
        `,
        titan: true,
        dmgIncreaseData: {
            base: 0.01,
            level: [0, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005]
        },
        imageSource: "./images/modules/nuclear_reactor.png",
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 2500
        }
    }, {
        tier: 1,
        name: "Antimatter Reactor",
        desc: `
        Increases titan's weapon damage output greatly.
        `,
        titan: true,
        dmgIncreaseData: {
            base: 0.03,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005]
        },
        imageSource: "./images/modules/thermonuclear_reactor.png",
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 7e3
        }
    }, {
        dontSell: true,
        tier: 3,
        name: "Grand Balance Reactor",
        desc: `
        Increases titan's durability and weapon damage output.
        `,
        healthIncreaseData: {
            base: 0.01,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005]
        },
        dmgIncreaseData: {
            base: 0.01,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005]
        },
        titan: true,
        imageSource: "./images/modules/balance_unit.png",
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 35e3
        }
    }, {
        tier: 2,
        name: "Titan Self-Fix Unit",
        desc: `
        Repairs a portion of a titan's maximum durability each second.
        `,
        titan: true,
        selfFixRepairData: {
            base: 500,
            level: [0, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250]
        },
        imageSource: "./images/modules/self_fix_unit.png",
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 15e3
        }
    }, {
        tier: 3,
        name: "Titan Anti Control",
        desc: `
        Reduces the duration of negative effects and increases the titan's durability.
        When installing several such modules, the bonus of effect duration reduction won't stack.
        `,
        healthIncreaseData: {
            base: 0.01,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005]
        },
        antiControlData: {
            base: .5,
            level: [0, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.02]
        },
        imageSource: "./images/modules/anticontrol.png",
        titan: true,
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 15e3
        }
    }, {
        tier: 4,
        name: "Titan Repair Amplifier",
        desc: ``,
        durabilityLostAmpData: {
            base: 0.09,
            level: [0, 0, 0, 0, 0, -.01, 0, 0, 0, 0, 0, 0, 0, -.01, 0, 0, 0, 0, 0, 0, 0, 0, -.01, 0, 0]
        },
        grayDamageFixRepairData: {
            base: 12500,
            level: [0, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500]
        },
        selfFixRepairData: {
            base: 25e3,
            level: [0, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3]
        },
        titan: true,
        imageSource: "./images/modules/repair_amplifier.png",
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 95e3
        }
    }, {
        tier: 2,
        name: "Titan Charger",
        desc: `Allows to start a battle with titan already charged a little.`,
        titanChargeData: {
            base: 0.05,
            level: [0, .005, .005, .005, .005, .005, .005, .005, .005, .01, .01, .01, .01, .01, .01, .01, .01, .02, .02, .02, .02, .02, .02, .03, .03]
        },
        titan: true,
        imageSource: "./images/modules/titan_charger.png",
        cost: {
            sliver: 0,
            gold: 0,
            workshopPoints: 15e3
        }
    }];//2500, 7000, 15000, 35000, 95e3
    for (let i = 0; i < shapeData.length; i++) {
        let data = shapeData[i];
        if (data && !data.titan) {
            data.titan = false;
        }
    }
    for (let i = 0; i < moduleData.length; i++) {
        let data = moduleData[i];
        if (data && !data.titan) {
            data.titan = false;
        }
    }
    for (let i = 0; i < weaponData.length; i++) {
        let data = weaponData[i];
        if (data && !data.titan) {
            data.titan = false;
        }
    }
    function makeNewSpecialEdition(name, {
        health,
        builtInDefensePoints,
        topDesc,
        newDesc,
        hardpoints,
        borderColor,
        tier,
        reflectorData,
        moduleSlots,
        abilities,
        revive,
        cantGet,
        healingAuraData,
        fieldOfViewMulti,
        speed,
        hullIntegrity,
        shieldData,
        moduleHardpoints,
        dotResistance,
        indexRole,
        additionalHealthData,
        scale
    }, type, specialOf, source) {
        if (type == "shape") {
            let shape = shapeData.find(e => e.name == name);
            let newshape = JSON.parse(JSON.stringify(shape));
            newshape.name = `${specialOf} ${name}`;
            newshape.specialOf = source;
            if (indexRole != undefined) newshape.indexRole = indexRole;
            newshape.desc = newshape.desc.replace(name, `${specialOf} ${name}`);
            newshape.desc = `
            ${topDesc || "Limited Edition Shape with increased stat bonuses."}
            <br><br>
            ` + (newDesc || newshape.desc);
            if (tier) newshape.tier = tier;
            newshape.healthData.base *= health;
            if (scale) newshape.scale = scale;
            if (reflectorData) newshape.reflectorData = reflectorData;
            if (!cantGet) newshape.dontSell = true;
            newshape.dontShow = true;
            if (additionalHealthData) newshape.additionalHealthData = additionalHealthData;
            if (dotResistance) newshape.dotResistance = dotResistance;
            if (hullIntegrity) newshape.hullIntegrity = hullIntegrity;
            if (fieldOfViewMulti) newshape.fieldOfViewMulti = fieldOfViewMulti;
            if (healingAuraData) newshape.healingAuraData = healingAuraData;
            if (revive) newshape.revive = revive;
            if (abilities) newshape.abilities = abilities;
            if (builtInDefensePoints) newshape.builtInDefensePoints = builtInDefensePoints;
            if (hardpoints) newshape.hardpoints = hardpoints;
            if (borderColor) newshape.borderColor = borderColor;
            if (moduleSlots) newshape.moduleHardpoints = moduleSlots;
            if (shieldData) newshape.shieldData = shieldData;
            if (moduleHardpoints) newshape.moduleHardpoints = moduleHardpoints;
            for (let i = 0; i < newshape.healthData.level.length; i++) {
                newshape.healthData.level[i] *= health;
            }
            if (speed) {
                for (let i = 0; i < newshape.speedLevel.length; i++) {
                    newshape.speedLevel[i] *= speed;
                }
            }
            shapeData.push(newshape);
        }
    }
    makeNewSpecialEdition("Orange Circle", {
        health: 1.3,
        reflectorData: {
            resistance: .5,
            return: .4
        },
        moduleSlots: 5,
        cantGet: true
    }, "shape", "Pumpkin", "./images/special_addtiction/pumpkin_orange_circle.png");
    makeNewSpecialEdition("Green Circle", {
        cantGet: true,
        health: 1.5,
        indexRole: 3,
        topDesc: `
        ULTIMATE SHAPE VERSION<br>
        The rarest modification of the Green Circle.
        Surpassing the original in all aspects,
        it is a desirable shape for any player.
        `,
        newDesc: `
        Armored shape with the ability to heal itself when damaged.
        <br><br>
        Recommended Equipment: x3 Veyron 
        `,
        revive: .75,
        builtInDefensePoints: 50,
        hardpoints: {
            light: 0,
            heavy: 3
        },
        abilities: [{
            name: "Ultimate Mending",
            desc: `
            <span style="font-width: bolder; color: #fff;">Ultimate Mending</span>
            The shape increases its healing power and moves faster.<br><br>
            Duration: 6 seconds<br>
            Speed Increase: 150%<br>
            Healing Power: 15%<br>
            Healing Rate: .5 seconds<br>
            Healing Aura Power Increase: x5<br>
            Healing Aura Rate Increase: x4<br>
            Gray Damage Repair: 15%<br>
            Cooldown: 12 seconds
            `,
            iconSource: "./images/abilities/self_heal.png",
            lastingTime: 6e3,
            reload: 12e3
        }],
        healingAuraData: {
            base: 3700,
            level: [0, 250, 250, 275, 300, 325, 325, 350, 350, 350, 500, 500]
        },
        moduleSlots: 4,
        tier: 4,
        borderColor: "#ffff00"
    }, "shape", "Ultimate");
    makeNewSpecialEdition("Tan Pentagon", {
        health: 1.45,
        cantGet: true,
        tier: 4,
        builtInDefensePoints: 75,
        hardpoints: {
            light: 6,
            heavy: 0
        },
        topDesc: `
        ULTIMATE SHAPE VERSION<br>
        The rarest modification of the Tan Pentagon.
        Surpassing the original in all aspects,
        it is a desirable shape for any player.
        `,
        newDesc: `
        Tan Pentagon is a dangerous shape that can
        turn enemies fire power aganist them.
        <br><br>
        Recommended Equipment: x6 Evora
        `,
        abilities: [{
            name: "Retribution",
            desc: `
            <span style="font-width: bolder; color: #fff;">Retribution</span>
            The shape activates a purple shield and its built-in weapons. Damage aborbed by the shield will increase the effectiveness of the built-in weapons.<br><br>
            Duration: 12 seconds<br>
            Max Increase: 100%<br>
            Ability Range: 1600PX<br>
            Ability Fire Rate: .025 seconds<br>
            Cooldown: 10 seconds
            `,
            iconSource: "./images/abilities/retribution.png",
            damageData: {
                base: 1014,
                level: [0, 108, 108, 138, 138, 138, 186, 186, 186, 234, 234, 234]
            },
            lastingTime: 12e3,
            reload: 10e3
        }],
        borderColor: "#ffff00"
    }, "shape", "Ultimate");
    makeNewSpecialEdition("Teal Circle", {
        health: 1,
        speed: 1.25,
        tier: 4,
        fieldOfViewMulti: 1.75,
        topDesc: `
        ULTIMATE SHAPE VERSION<br>
        The rarest modification of the Teal Circle.
        Surpassing the original in all aspects,
        it is a desirable shape for any player.
        `,
        newDesc: `
        Improved version of Teal Circle, Ultimate Teal Circle can do everything Teal Circle can do but better.<br><br>
        The shape also takes 25% less gray damage from all sources.<br><br>
        Recommended Equipment: x3 Veyron / x3 Tumultus
        `,
        hullIntegrity: .25,
        abilities: [{
            name: "Reflector",
            desc: `
            <span style="font-width: bolder; color: #fff;">Reflector</span>
            The shape activates its powerful defense system and instantly repairs some durability.<br><br>
            Duration: Based on shape level<br>
            Reflector Blocked: based on shape level<br>
            Reflector Returned: 75%<br>
            Durability Repaired: 25%<br>
            Cooldown: 8 seconds
            `,
            defensePointToReflector: true,
            abilityDefensePointsData: {
                base: 50,
                level: [0, 5, 5, 10, 10, 15, 15, 20, 20, 25, 25, 50]
            },
            lastingTimeData: {
                base: 5e3,
                level: [0, 250, 250, 250, 250, 500, 500, 500, 500, 1e3, 1e3, 2e3]
            },
            iconSource: "./images/modules/heavy_armor_plating.png",
            reload: 8e3
        }],
        hardpoints: {
            light: 0,
            heavy: 4
        },
        borderColor: "#ffff00"
    }, "shape", "Ultimate");
    makeNewSpecialEdition("Tan Circle", {
        health: 1.25,
        tier: 4,
        topDesc: `
        Special limited version of Tan Circle. This version has increased health and defense points.
        `,
        builtInDefensePoints: 25,
        borderColor: "#00f"
    }, "shape", "Blue-Outlined");
    makeNewSpecialEdition("Gray Circle", {
        tier: 4,
        health: 1.8,
        builtInDefensePoints: 100,
        hardpoints: {
            light: 0,
            heavy: 2
        },
        topDesc: `
        ULTIMATE SHAPE VERSION<br>
        The rarest modification of the Gray Circle.
        Surpassing the original in all aspects,
        it is a desirable shape for any player.
        `,
        newDesc: `
        Training shape for mastering the basics of combat.<br><br>
        <strong style="color: #fff">Forcefield</strong> Another type of defense which reduces damage taken. It cannot be mitigated by defense mitigation effect weapon but may be reduced. Forcefield is based on durability but not considered as a shield.<br><br>
        Damage Reduction: 90% (MAX) to 0% (MIN)<br>
        Durability: 200,000<br>
        Regeneration Time: 5 seconds
        <br><br>
        Recommended Equipment: x2 Veyron
        `,
        reflectorData: {
            resistance: .25,
            return: .1
        },
        builtInDefensePoints: 25,
        moduleHardpoints: 3,
        hullIntegrity: .5,
        borderColor: "#ffff00"
    }, "shape", "Ultimate");
    makeNewSpecialEdition("Brown Pentagon", {
        tier: 4,
        health: 1.45,
        scale: 95,
        topDesc: `
        ULTIMATE SHAPE VERSION<br>
        The rarest modification of the Brown Pentagon.
        Surpassing the original in all aspects,
        it is a desirable shape for any player.
        `,
        newDesc: `
        A well protected shape that can swtich between modes to increase its mobility or defense.<br><br>
        The shape has a built-in immunity to defense mitigation.
        `,
        shieldData: {
            type: "yellow",
            base: 57e3,
            level: [0, 800, 800, 1600, 1600, 1600, 1600, 3e3, 3e3, 4e3, 8e3, 16e3],
            regen: 0.05
        },
        additionalHealthData: {
            base: 20e3,
            level: [0, 1600, 1600, 3200, 3200, 3200, 3200, 6e3, 6e3, 8e3, 12e3, 22e3].map(e => 2 * e)
        },
        abilities: [{
            name: "Shapeshift",
            desc: `
            <span style="font-width: bolder; color: #fff;">Shapeshift</span> The shape, upon activating the ability, switches between modes.<br><br>
            <span style="font-width: bolder; color: #fff;">Travel Mode</span>: Robot activates its energy shield, drops its 2 heavy weapons, and moves faster.<br><br>
            <span style="font-width: bolder; color: #fff;">Tank Mode</span>: Robot disables its energy shield, activates its 2 heavy weapons, moves slower, and activates a defense system. During Tank Mode, the energy shield regens faster (1000%).<br><br>
            Default Mode: Travel Mode<br>
            Cooldown: 1 second
            `,
            iconSource: "./images/abilities/shapeshift.png",
            abilityDefensePointsData: {
                base: 150,
                level: [0, 5, 5, 5, 5, 5, 15, 15, 15, 20, 30, 30]
            },
            reload: 1e3
        }],
        moduleHardpoints: 4,
        hullIntegrity: .35,
        borderColor: "#ffff00"
    }, "shape", "Ultimate");
    makeNewSpecialEdition("Brown Circle", {
        tier: 4,
        health: 2,
        topDesc: `
        ULTIMATE SHAPE VERSION<br>
        The rarest modification of the Brown Circle.
        Surpassing the original in all aspects,
        it is a desirable shape for any player.
        `,
        newDesc: `
        Brown Circle is equipped with flight tech.<br><br>
        Recommended Equipment: x2 Veyron + x2 Evora
        `,
        abilities: [{
            name: "Dragon Flight",
            desc: `
            <span style="font-width: bolder; color: #fff;">Dragon Flight</span>
            The shape flies up, ignoring all buildings while moving and activates a power built-in weapon.<br><br>
            <strong style="color: #fff">Forcefield</strong> Another type of defense which reduces damage taken. It cannot be mitigated by defense mitigation effect weapon but may be reduced. Forcefield is based on durability but not considered as a shield.<br><br>
            Damage Reduction: 99% (MAX) to 90% (MIN)<br>
            Durability: X2 of Max Health<br>
            Regeneration Time: 10 seconds<br><br>
            Duration: 10 seconds<br>
            Speed Increase: 200%<br>
            Defense Mitigation: 75%<br>
            Cooldown: 12 seconds
            `,
            damageData: {
                base: 155,
                level: [0, 35, 43, 50, 58, 58, 65, 68, 73, 75, 80, 83]
            },
            dotData: {
                base: 15,
                level: [0, 13, 13, 13, 13, 13, 13, 25, 25, 25, 25, 50].map(e => e * 1.25)
            },
            projPerShot: 4,
            fireRate: 50,
            effectIncreaseData: {
                base: .005,
                level: [0, 0, .001, .001, .001, .001, .001, .001, .001, .001, .001, .001]
            },
            lastingTime: 10e3,
            iconSource: "./images/abilities/dragon_flight.png",
            reload: 12e3
        }],
        moduleHardpoints: 3,
        borderColor: "#ffff00"
    }, "shape", "Ultimate");
    makeNewSpecialEdition("Green Triangle", {
        tier: 4,
        health: 1.8,
        topDesc: `
        ULTIMATE SHAPE VERSION<br>
        The rarest modification of the Green Triangle.
        Surpassing the original in all aspects,
        it is a desirable shape for any player.
        `,
        additionalHealthData: {
            base: 10e3,
            level: [0, 500, 500, 1e3, 1e3, 1e3, 1e3, 2e3, 2e3, 3e3, 3e3, 5e3]
        },
        abilities: [{
            name: "Support",
            desc: `
            <span style="font-width: bolder; color: #fff;">Support</span> The shape speeds up and gets increased defense points. During the ability, it emits waves of healing that repair all allies and itself.<br><br>
            During the ability: defense points are unmitigable<br><br>
            Defense Points: 400 (80% Resistance)<br>
            Speed Increase: 125%<br>
            Healing Pulses: 48<br>
            Pulse Range: 500PX<br>
            Ability Duration: 12 seconds<br>
            Cooldown: 12 seconds
            `,
            iconSource: "./images/abilities/self_heal.png",
            healingPowerData: {
                base: 7e3,
                level: [0, 2e3, 2e3, 3e3, 3e3, 3e3, 5e3, 5e3, 5e3, 5e3, 7e3, 8e3]
            },
            lastingTime: 12e3,
            reload: 12e3
        }],
        moduleHardpoints: 3,
        hardpoints: {
            light: 2,
            heavy: 1
        },
        borderColor: "#ffff00"
    }, "shape", "Ultimate");
    makeNewSpecialEdition("Tan Circle", {
        health: 1.4,
        fieldOfViewMulti: 1.75,
        topDesc: `
        ULTIMATE SHAPE VERSION<br>
        The rarest modification of the Tan Circle.
        Surpassing the original in all aspects,
        it is a desirable shape for any player.
        `,
        abilities: [{
            name: "Stampede",
            desc: `
            <span style="font-width: bolder; color: #fff;">Stampede</span>
            The shape speeds up and activates its defense system that turns all damage to DoT. During the ability, the shape becomes harder to control and activates a magnetic field.<br><br>The magentic field has Defense Breach.<br><br>
            DoT Duration (per stack): 7 seconds<br>
            Magnetic Field Range: 400PX<br>
            Speed Increase: +200%<br>
            Charges: 3<br>
            Duration: 5 seconds<br>
            Cooldown (per charge): 16 seconds
            `,
            iconSource: "./images/abilities/stampede.png",
            damageData: {
                base: 440,
                level: [0, 270, 600, 660, 720, 780, 840, 900, 960, 1020, 1080, 1140],
            },
            charges: 3,
            lastingTime: 5e3,
            reload: 16e3
        }],
        dotResistance: .333,
        moduleHardpoints: 4,
        borderColor: "#ffff00"
    }, "shape", "Ultimate");
    makeNewSpecialEdition("Purple Hexagon", {
        tier: 4,
        health: 1.75,
        cantGet: true,
        speed: 1.8,
        scale: 65,
        topDesc: `
        ULTIMATE SHAPE VERSION<br>
        The rarest modification of the Purple Hexagon.
        Surpassing the original in all aspects,
        it is a desirable shape for any player.
        `,
        abilities: [{
            name: "Stealth Dash",
            desc: `
            <span style="font-width: bolder; color: #fff;">Stealth Dash</span>
            The shape leaps forward in a chosen direction. During that, the shape activates stealth that lasts during and after the dash.<br><br>
            Max Charges: 3<br>
            Usage Interval: 3 seconds<br>
            Cooldown (per charge): 18 seconds
            `,
            iconSource: "./images/abilities/stealth_dash.png",
            charges: 3,
            lastingTime: 3e3,
            reload: 18e3
        }],
        hardpoints: {
            heavy: 3,
            light: 0
        },
        builtInDefensePoints: 100,
        moduleHardpoints: 4,
        hullIntegrity: .25,
        borderColor: "#ffff00"
    }, "shape", "Ultimate");
    var activeModuleData = [{
        tier: 0,
        name: "Repair Unit",
        desc: "Repairs a part of the shape's durability.",
        imageSource: "./images/abilities/self_heal.png",
        repairUnitPower: {
            type: "percent",
            power: 0.05,
            rate: 1e3
        },
        lastTime: 5e3,
        cost: 200,
        reload: 14e3
    }, {
        tier: 2,
        name: "Advanced Repair Unit",
        desc: "Repairs a large part of the shape's durability.",
        imageSource: "./images/modules/self_fix_unit.png",
        repairUnitPower: {
            type: "percent",
            power: 0.1,
            rate: 1e3
        },
        lastTime: 4e3,
        cost: 400,
        reload: 14e3
    }, {
        tier: 3,
        name: "Phase Shift",
        desc: "When activated, the shape activates a phase shift effect similar to the ability of [Yellow Hexagon]",
        imageSource: "./images/abilities/phase_shift.png",
        lastTime: 4e3,
        cost: 800,
        reload: 16e3
    }, {
        tier: 4,
        name: "Unstable Conduit",
        desc: "When activated, Unstable Conduit gives you the effects of one of the conduits.",
        imageSource: "./images/abilities/shapeshift.png",
        cost: 4e3,
        reload: 8e3
    }, {
        tier: 3,
        name: "Nuclear Intensifier",
        desc: "Increases the shape's damage output for a period of time.",
        imageSource: "./images/modules/nuclear_reactor.png",
        dmgIncrease: .4,
        lastTime: 6e3,
        cost: 800,
        reload: 14e3
    }, {
        tier: 3,
        name: "Shield Breaker",
        desc: "When activated: allows the shape's built-in weapons to bypass all shields (not physical ones).",
        imageSource: "./images/icons/shield_break.png",
        lastTime: 10e3,
        cost: 800,
        reload: 15e3
    }, {
        tier: 3,
        name: "Repairing Conduit",
        desc: "When activated, the shape repairs it's durability and gray damage.",
        imageSource: "./images/weapons/gangantua.png",
        instantFixPercent: .25,
        repairUnitPower: {
            type: "percent",
            power: 0.1,
            rate: 500
        },
        lastTime: 6e3,
        cost: 1e3,
        reload: 12e3
    }, {
        tier: 3,
        name: "Nuclear Conduit",
        imageSource: "./images/modules/nuclear_reactor.png",
        desc: "When activated, the shape gains increased weapon damage and defense breach effect.",
        dmgIncrease: .35,
        lastTime: 4e3,
        cost: 1e3,
        reload: 14e3,
    }];
    function checkIfDev() {
        if (window.isDev) {
            shapeData.forEach(e => {
                if (e.dontSell || e.name.includes("Ultimate")) {
                    e.dontSell = false;
                    e.dontShow = false;
                }
            });
            weaponData.forEach(e => {
                if (e.dontSell) {
                    e.dontSell = false;
                    e.dontShow = false;
                }
            });
            moduleData.forEach(e => {
                if (e.dontSell) {
                    e.dontSell = false;
                }
            });
            dronesData.forEach(e => {
                if (e.dontSell) {
                    e.dontSell = false;
                }
            });
        }
    }
    function abbreviateNumber(value) {
        if (value >= 1e12) {
            return (value / 1e12).toFixed(1) + "T";
        } else if (value >= 1e9) {
            return (value / 1e9).toFixed(1) + "B";
        } else if (value >= 1e6) {
            return (value / 1e6).toFixed(1) + "M";
        } else if (value >= 1e3) {
            return (value / 1e3).toFixed(1) + "K";
        }
        return value;
    }
    var gameModeData = [{
        name: "Quick Match",
        desc: `
        You will be randomly matched in one of the following modes:<br>
        Classic<br>
        One vs. All<br>
        FFA
        `,
        level: 15,
        backgroundImage: "",
        ids: [2, 4]
    }, {
        name: "Classic",
        id: 2,
        level: 1,
        backgroundImage: "",
        desc: `
        Beacon Capture. Each captured beacon gives points to your team.
        The team that fills their half of the bar wins. The destruction of all enemy
        shapes will also count as a win.
        `
    }, {
        name: "Team Deathmatch",
        id: 9,
        level: 7,
        backgroundImage: "",
        desc: `
        A simple team gamemode but without beacons.
        Fight and destroy all enemy shapes with your team.
        `
    }, {
        name: "FFA",
        id: 4,
        level: 15,
        backgroundImage: "",
        desc: `
        In FFA mode, 10 players, including you,
        fight in an arena. The goal is to be the
        last one standing by defeating everyone else!
        `
    }, {
        name: "Gladiator",
        id: 7,
        level: 15,
        backgroundImage: "",
        desc: `
        In this game mode, you fight with 6 other shapes simultaneously in a enclosed arena.
        `
    }, {
        name: "Extermination",
        id: 0,
        level: 10,
        backgroundImage: "",
        desc: `
        Fight hordes of enemies in enclosed maps.
        Gain rewards for doing missions.
        `
    }, {
        name: "Test / Playground",
        id: 6,
        level: 5,
        backgroundImage: "",
        desc: `
        Pentagon, the one of the biggest shape production companies, bought many acres of
        land to test run their lastest weapons and shapes.
        They also allow other loyal customers to use the
        land for the same purpose.
        `
    }];
    /*sliver: 0,
    gold: 0,
    keys: 0,
    workshopPoints: 0,
    oxp: 0*/
    function formatRewards(rewards) {
        let formattedRewards = "Rewards:<br>";

        for (let [key, value] of Object.entries(rewards)) {
            let formattedKey = key.charAt(0).toUpperCase() + key.slice(1).toLowerCase();
            let formattedValue = styleNumberWithCommas(value);
            formattedRewards += `${key == "workshopPoints" ? "Workshop Points" : formattedKey}: ${formattedValue}<br>`;
        }

        return formattedRewards.trim();
    }
    var exterminationLevels = [{
        description: `Get 15 kills in 1 minute.`,
        timeLimit: 60 * 1e3,
        spawnData: {
            rate: 2e3,
            amount: 2,
            enemies: ["Burner Circle"]
        },
        goal: { kills: 15 },
        rewards: { sliver: 50e3, gold: 15 },
        map: { x: 2400, y: 2400 }
    }, {
        description: `Get 25 kills in 1 minute.`,
        timeLimit: 60 * 1e3,
        spawnData: {
            rate: 2e3,
            amount: 2,
            enemies: ["Burner Circle"]
        },
        goal: { kills: 25 },
        rewards: { sliver: 75e3, gold: 30 },
        map: { x: 2400, y: 2400 }
    }, {
        description: `Get 45 kills in 1 minute.`,
        timeLimit: 60 * 1e3,
        spawnData: {
            rate: 6e3,
            amount: 8,
            enemies: ["Burner Circle"]
        },
        goal: { kills: 45 },
        rewards: { sliver: 200e3, gold: 125 },
        map: { x: 3e3, y: 3e3 }
    }, {
        description: `Difficulty increased drastically. Get 75 kills in 1 minute.`,
        timeLimit: 60 * 1e3,
        spawnData: {
            rate: 2e3,
            amount: 8,
            enemies: ["Burner Circle"]
        },
        goal: { kills: 75 },
        rewards: { sliver: 500e3, gold: 350 },
        map: { x: 4e3, y: 4e3 }
    }, {
        description: `Difficulty increased drastically. Get 150 kills in 2 minutes and 30 seconds.`,
        timeLimit: 60 * 1e3 * 2.5,
        spawnData: {
            rate: 4e3,
            amount: 8,
            enemies: ["Burner Circle", "Reaper Circle"]
        },
        goal: { kills: 150 },
        rewards: { sliver: 2e6, gold: 750 },
        map: { x: 5e3, y: 5e3 }
    }, {
        description: `Get 165 kills in 1 minute and 30 seconds.`,
        timeLimit: 60 * 1e3 * 1.5,
        spawnData: {
            rate: 3e3,
            amount: 12,
            enemies: ["Burner Circle", "Reaper Circle"]
        },
        goal: { kills: 165 },
        rewards: { sliver: 8e6, gold: 1250 },
        map: { x: 5e3, y: 5e3 }
    }, {
        description: `Difficulty increased drastically. Get 305 kills in 2 minutes.`,
        timeLimit: 60 * 1e3 * 2,
        spawnData: {
            rate: 2e3,
            amount: 12,
            enemies: ["Burner Circle", "Reaper Circle"]
        },
        goal: { kills: 305 },
        rewards: { sliver: 30e6, gold: 4500 },
        map: { x: 5e3, y: 5e3 }
    }, {
        description: `Difficulty increased drastically. Get 355 kills in 15 seconds.`,
        timeLimit: 15 * 1e3,
        spawnData: {
            rate: 1e3,
            amount: 25,
            enemies: ["Burner Circle"]
        },
        goal: { kills: 355 },
        rewards: { sliver: 50e6, gold: 6500 },
        map: { x: 1e3, y: 1e3 }
    }, {
        description: `Difficulty increased drastically. Get 205 kills in 3 minutes.`,
        timeLimit: 60 * 1e3 * 3,
        spawnData: {
            rate: 8e3,
            amount: 25,
            enemies: ["Burner Circle", "Reaper Circle", "Homing Circle"]
        },
        modifiers: {
            defensePoints: 50,
            health: 1.5,
            speed: 2,
            dmg: 2.5
        },
        goal: { kills: 205 },
        rewards: { sliver: 75e6, gold: 8e3, workshopPoints: 5e3 },
        map: { name: "Space Shuttle", noBeacons: true }
    }, {
        description: `Get 65 kills and capture 1 beacon in 2 minutes.`,
        timeLimit: 60 * 1e3 * 2,
        spawnData: {
            rate: 8e3,
            amount: 12,
            enemies: ["Homing Circle"]
        },
        spawnPoints: true,
        bossName: "Bastion",
        modifiers: {
            defensePoints: 50,
            health: 5,
            dmg: 2
        },
        goal: { kills: 65, beacons: 1 },
        rewards: { sliver: 100e6, gold: 8e3, workshopPoints: 8e3 },
        map: { name: "Lost Forest", noBeacons: "middle" }
    }, {
        description: `Difficulty increased drastically. Get 305 kills and capture 5 beacons in 3 minutes.`,
        timeLimit: 60 * 1e3 * 3,
        spawnData: {
            rate: 12e3,
            amount: 35,
            enemies: ["Burner Circle", "Reaper Circle", "Homing Circle", "DoT Circle", "Anti Healing Circle"]
        },
        modifiers: {
            defensePoints: 50,
            health: 3,
            speed: 4,
            dmg: 3
        },
        goal: { kills: 305, beacons: 5 },
        rewards: { sliver: 125e6, gold: 8e3, workshopPoints: 8e3 },
        map: { name: "Lost Forest" }
    }, {
        description: `Get 1 kills and capture 1 beacon in 3 minutes.`,
        timeLimit: 60 * 1e3 * 3,
        spawnData: {
            rate: 60 * 1e3 * 60 * 60,
            amount: 0,
            enemies: ["Homing Circle"]
        },
        spawnPoints: true,
        bossName: "Bastion",
        bossModifiers: {
            defensePoints: 150,
            health: 4,
            dmg: 3.5
        },
        goal: { kills: 1, beacons: 1 },
        rewards: { sliver: 150e6, gold: 8e3, workshopPoints: 8e3 },
        map: { name: "Void", noBeacons: "middle" }
    }, {
        description: `Get 35 kills in 3 minutes.`,
        timeLimit: 60 * 1e3 * 3,
        spawnData: {
            rate: 20e3,
            amount: 5,
            enemies: ["Attacker Circle"]
        },
        modifiers: {
            defensePoints: 200,
            speed: 3,
            dmg: 12,
            health: 7
        },
        goal: { kills: 35 },
        rewards: { sliver: 150e6, gold: 8e3, workshopPoints: 8e3 },
        map: { name: "Space Shuttle", noBeacons: true }
    }];
    function drawGameModesDisplay() {
        document.getElementById("gameModesDisplay").innerHTML = `
        <div id="mainsDisplay" style="position: absolute; left: 0px; top: ${window.innerHeight / 2 - 175}px; width: 100%; height: 350px; background-color: rgb(0, 0, 0, 0.15); overflow-x: scroll; box-shadow: 0 0 10px 5px rgba(0, 0, 0, 0.5);">
        </div>
        `;
        let width = 250;
        for (let i = 0; i < gameModeData.length; i++) {
            let data = gameModeData[i]
            document.getElementById("mainsDisplay").innerHTML += `
            <div style="position: absolute; height: 100%; width: ${width}px; top: 0px; left: ${(width + 20) * i}px; background-color: ${i % 2 == 1 ? "rgb(255, 255, 255, 0.4)" : "rgb(0, 0, 0, 0.2)"};">
            <div style="font-size: 24px; margin-left: 10px; margin-top: 5px;">${data.name}</div>
            <hr>
            <div style="margin-left: 10px; font-size: 12px;">
            ${data.desc}
            </div>
            <div id="goFightId${data.id}" style="position: absolute; color: #fff; bottom: 10px; cursor: pointer; left: 10px; font-size: 24px; text-align: center; width: ${width - 20}px; height: 30px; background-color: ${data.level > player.profile.level ? "#909090" : "#fc9003"}; border-radius: 4px;">
            ${data.level > player.profile.level ? "LOCKED" : "FIGHT"}
            </div>
            </div>
            `;
        }
        for (let i = 0; i < gameModeData.length; i++) {
            let data = gameModeData[i];
            if (data.id + 1 >= 1 && document.getElementById(`goFightId${data.id}`)) {
                document.getElementById(`goFightId${data.id}`).onclick = function () {
                    if (data.level > player.profile.level) return;
                    if (data.id == 0) {
                        document.getElementById("gameModesDisplay").style.display = "none";
                        document.getElementById("sideDisplay").style.display = "block";
                        for (let i = 0; i < exterminationLevels.length; i++) {
                            let level = exterminationLevels[i];
                            document.getElementById("sideDisplay").innerHTML += `
                            <div id="goToLevelExtermination${i}" style="${player.exterminationIndx < i ? "" : "cursor: pointer;"} display: inline-block; width: 300px; height: 200px; margin: 20px; overflow-y: scroll; border-radius: 6px; background-color: ${player.exterminationIndx < i ? "rgb(0, 0, 0, .6)" : player.exterminationIndx > i ? "rgb(0, 255, 0, .6)" : "rgb(0, 0, 0, .3)"};">
                            <div style="margin-left: 10px; font-size: 24px; color: #fff;">Level ${i + 1}</div>
                            <hr>
                            <div style="margin-left: 10px; color: #fff;">
                            ${level.description}<br><br>
                            ${formatRewards(level.rewards)}
                            </div>
                            </div>
                            `;
                        }
                        for (let i = 0; i < exterminationLevels.length; i++) {
                            let level = exterminationLevels[i];
                            document.getElementById(`goToLevelExtermination${i}`).onclick = function () {
                                if (player.exterminationIndx >= i) {
                                    setUpGame(0, level, i);
                                    document.getElementById("chooseSlot").style.bottom = "0px";
                                    document.getElementById("goBackToHanger").style.display = "none";
                                    resize();
                                }
                            };
                        }
                    } else {
                        document.getElementById("chooseSlot").style.bottom = "0px";
                        document.getElementById("goBackToHanger").style.display = "none";
                        document.getElementById("gameModesDisplay").style.display = "none";
                        setUpGame(data.id);
                        resize();
                    }
                }
            } else if (data.ids) {
                let randomId = data.ids[Math.floor(Math.random() * data.ids.length)];
                document.getElementById(`goFightId${data.id}`).onclick = function () {
                    if (data.level > player.profile.level) return;
                    document.getElementById("chooseSlot").style.bottom = "0px";
                    document.getElementById("goBackToHanger").style.display = "none";
                    document.getElementById("gameModesDisplay").style.display = "none";
                    setUpGame(randomId);
                    resize();
                }
            }
        }
    }
    function setUpUIStuffThing() {
        let accountLevel = player.profile.level;
        if (accountLevel < 21) {
            document.getElementById("workshopToggle").style.pointerEvents = "none";
            document.getElementById("workshopToggle").style.opacity = .2;
        } else {
            document.getElementById("workshopToggle").style.opacity = 1;
            document.getElementById("workshopToggle").style.pointerEvents = "auto";
        }
        if (accountLevel < 11) {
            document.getElementById("operationToggle").style.pointerEvents = "none";
            document.getElementById("operationToggle").style.opacity = .2;
        } else {
            document.getElementById("operationToggle").style.opacity = 1;
            document.getElementById("operationToggle").style.pointerEvents = "auto";
        }
        if (accountLevel < 2) {
            document.getElementById("offersToggles").style.pointerEvents = "none";
            document.getElementById("offersToggles").style.opacity = .2;
        } else {
            document.getElementById("offersToggles").style.opacity = 1;
            document.getElementById("offersToggles").style.pointerEvents = "auto";
        }
        if (accountLevel < 6) {
            document.getElementById("lootBoxToggle").style.pointerEvents = "none";
            document.getElementById("lootBoxToggle").style.opacity = .2;
        } else {
            document.getElementById("lootBoxToggle").style.opacity = 1;
            document.getElementById("lootBoxToggle").style.pointerEvents = "auto";
        }
        if (accountLevel < 25) {
            document.getElementById("mothershipToggle").style.pointerEvents = "none";
            document.getElementById("mothershipToggle").style.opacity = .2;
        } else {
            document.getElementById("mothershipToggle").style.opacity = 1;
            document.getElementById("mothershipToggle").style.pointerEvents = "auto";
        }
    }
    function injectRewards(level, rewards, unlocked) {
        let element = document.createElement("div");
        element.style = `
        position: absolute;
        width: 600px;
        height: 400px;
        top: ${window.innerHeight / 2 - 200}px;
        left: ${window.innerWidth / 2 - 300}px;
        background-color: rgb(0, 0, 0, .25);
        border-radius: 6px;
        color: #fff;
        z-index: 90000;
        overflow-y: scroll;
        `;
        element.innerHTML = `
        <h1 style="width: 100%; text-align: center; color: #fff;">Leveled Up to ${level}</h1>
        <hr>
        <div style="position: absolute; top: 100px; left: 25px; width: 550px; height: 50px; background-color: rgb(0, 0, 0, .4); border-radius: 6px;">
        <div style="position: absolute; left: 0px; top: 0px; width: 50px; height: 50px; background-image: url('${agSource}'); background-size: 50px 50px;">
        </div>
        <div style="position: absolute; left: 55px; top: 0px; font-size: 35px;">
        ${abbreviateNumber(rewards.silver)}
        </div>
        </div>
        <div style="position: absolute; top: 160px; left: 25px; width: 550px; height: 50px; background-color: rgb(0, 0, 0, .4); border-radius: 6px;">
        <div style="position: absolute; left: 0px; top: 0px; width: 50px; height: 50px; background-image: url('${auSource}'); background-size: 50px 50px;">
        </div>
        <div style="position: absolute; left: 55px; top: 0px; font-size: 35px;">
        ${abbreviateNumber(rewards.gold)}
        </div>
        </div>
        `;
        let sad = 0;
        unlocked.forEach((e, index) => {
            sad++;
            element.innerHTML += `
            <div style="position: absolute; top: ${220 + (index * 60)}px; left: 25px; width: 550px; height: 50px; background-color: rgb(0, 0, 0, .4); border-radius: 6px;">
            <div style="position: absolute; left: 10px; top: 10px; font-size: 20px;">
            ${typeof e == "string" ? e : `You unlocked Tier ${e + 1} equipment!`}
            </div>
            </div>
            `;
        });
        element.innerHTML += `
        <div style="position: absolute; opactiy: 0; top: ${220 + (sad * 60)}px; left: 25px; width: 550px; height: 10px;">
        </div>
        `;
        document.getElementById("hangerUI").appendChild(element);
        element.onclick = function () { this.remove(); }
        updateMoneyDisplay("gold", rewards.gold);
        updateMoneyDisplay("sliver", rewards.silver);
    }
    function doLeagueThingyMath(league) {
        if (league >= 4701) {
            return 1;
        }

        const ranges = [
            { min: 3801, max: 4700 },
            { min: 2901, max: 3800 },
            { min: 2101, max: 2900 },
            { min: 1501, max: 2100 },
            { min: 1001, max: 1500 },
            { min: 701, max: 1000 },
            { min: 451, max: 700 }
        ];

        for (const range of ranges) {
            if (league >= range.min && league <= range.max) {
                const min = league - range.min;
                const max = range.max - range.min;
                return min / max;
            }
        }

        return league / 450;
    }
    function getLeagueBadge(league) {
        let name = getLeagueName(league);
        return `./images/badges/${name[0].toLowerCase() + name.slice(1)}_badge.png`;
    }
    function doProfileClickStuff() {
        let robots = player.shapes.filter(e => e.slot != null || e.slot != undefined);
        document.getElementById("hangerUI").style.display = "none";
        let width = window.innerWidth - 120;
        let box = width / 3;
        let top = ((window.innerHeight - 220) / 2) - ((box - 40) / 2);
        let size = box - 40;
        document.getElementById("sideDisplay").innerHTML = `
        <h1 style="width: 100%; text-align: center;">Profile</h1><hr>
        <div id="stats" style="position: absolute; top: ${top}px; left: ${window.innerWidth / 2 - ((box - 40) / 2)}px; width: ${box - 40}px; height: ${box - 40}px; border-radius: 6px; background-color: rgb(0, 0, 0, .25); overflow-x: scroll;">
        </div>

        <div id="player-level-holder" style="position: absolute; top: ${top}px; left: 60px; width: ${box - 40}px; height: ${box - 40}px;">
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; border-radius: 50%; background-color: #e4e4e4;">
        <div style="width: ${size}px; height: ${size}px; border-radius: 50%; background: conic-gradient(#50e0fa ${player.profile.level == 30 ? 360 : (360 * (player.profile.xp.current / player.profile.xp.max))}deg, #fff 0deg);">
        </div>
        <div style="position: absolute; display: flex; align: center; justify-content: center; top: 25px; left: 25px; width: ${size - 50}px; height: ${size - 50}px; border-radius: 50%; background-color: rgb(183, 183, 183);">
        <div style="position: absolute; display: flex; align: center; justify-content: center; left: 25%; top: 25%; width: 50%; height: 50%; transform: rotate(45deg); background-color: #808080;">
        <div style="transform: rotate(-45deg); font-size: ${(size - 40) * .35}px;">${player.profile.level}</div>
        </div>
        </div>
        </div>
        </div>

        <div id="league-holder" style="position: absolute; top: ${top}px; right: 60px; width: ${box - 40}px; height: ${box - 40}px;">
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; border-radius: 50%; background-color: #e4e4e4;">
        <div style="width: ${size}px; height: ${size}px; border-radius: 50%; background: conic-gradient(#50e0fa ${360 * (doLeagueThingyMath(player.league))}deg, #fff 0deg);">
        </div>
        <div style="position: absolute; top: 25px; left: 25px; width: ${size - 50}px; height: ${size - 50}px; border-radius: 50%; background-color: rgb(183, 183, 183);">
        </div>
        <div style="position: absolute; top: 25px; left: 25px; width: ${size - 50}px; height: ${size - 50}px; border-radius: 50%; background-color: rgb(183, 183, 183);">
        <img src="${getLeagueBadge(player.league)}" style="width: 100%; height: 100%"> 
        </div>
        </div>
        </div>

        <div id="robotsDisplays" style="position: absolute; bottom: 0px; width: 100%; height: 300px; background-color: rgb(0, 0, 0, .25); overflow-x: scroll;">
        </div>
        `;
        robots = robots.sort((a, b) => a.slot - b.slot);
        let rating = 0;
        for (let i = 0; i < 8; i++) {
            let robot = robots.find(e => e.slot == i);
            if (robot) {
                document.getElementById("robotsDisplays").innerHTML += `
                <div id="thingy${i}" style="position: absolute; top: 0px; left: ${225 * i}px; height: 100%; width: 225px; background-color: ${i % 2 == 0 ? "rgb(0, 0, 0, .25)" : "rgb(255, 255, 255, .45)"};">
                <div id="modules${i}" style="position: absolute; bottom: 0px; height: ${225 / 4}px;left: 0px; width: 225px; overflow-x: scroll;">
                </div>
                </div>
                `;
            }
        }
        for (let i = 0; i < 8; i++) {
            let robot = robots.find(e => e.slot == i);
            if (robot) {
                let modules = player.modules.filter(e => e.owner == robot.sid);
                modules.forEach((e, index) => {
                    rating += (e.tier + 1) * e.level;
                    document.getElementById(`modules${i}`).innerHTML += `
                    <div id="modules${i}${index}" style="position: absolute; left: ${index * (225 / 4)}px; bottom: 0px; width: ${225 / 4}px; height: ${225 / 4}px;">
                    </div>
                    `;
                });
                modules.forEach((e, index) => {
                    rating += (e.tier + 1) * e.level;
                    let image = getModuleIcon(e, true);
                    image.style = `width: ${225 / 4}px; height: ${225 / 4}px;`;
                    document.getElementById(`modules${i}${index}`).append(image);
                });
                let weapons = player.weapons.filter(e => e.owner == robot.sid);
                weapons.forEach((e, index) => {
                    document.getElementById(`thingy${i}`).innerHTML += `
                    <div id="weapons${i}${index}" style="position: absolute; top: ${index >= 4 ? (225 / 4) * (index - 4) : (225 / 4) * index}px; background-size: ${225 / 4}px ${225 / 4}px; height: ${225 / 4}px; width: ${225 / 4}px; ${index >= 4 ? "right" : "left"}: 0px; background-image: url('${e.imageSource || e.iconSource}');">
                    </div>
                    `;
                });
                rating += (robot.tier + 1) * robot.level;
                let pilot = player.pilots.find(e => e.owner == robot.sid);
                if (pilot) {
                    rating += (pilot.tier + 1) * 5;
                    for (let it = 0; it < pilot.skills.length; it++) {
                        let skill = pilot.skills[it];
                        if (skill) {
                            if (skill.legendary) {
                                rating += 8;
                            } else {
                                rating += skill.level;
                            }
                        }
                    }
                }
                let drone = player.drones.find(e => e.owner == robot.sid);
                if (drone) {
                    rating += (drone.tier + 1) * 5;
                    rating += drone.level * 5;
                    for (let it = 0; it < drone.abilities.length; it++) {
                        let skill = drone.abilities[it];
                        if (skill) {
                            if (skill.unlockAtLevel <= drone.level || !skill.unlockAtLevel) {
                                rating += 2;
                            }
                        }
                    }
                }
                let image = getShapeSprite(robot, true);
                image.style = "width: 225px; height: 225px;";
                document.getElementById(`thingy${i}`).append(image);
            }
        }
        let ship = player.motherships.find(e => e.using);
        if (ship) {
            rating += (ship.tier + 1) * 25;
            rating += ship.level * 5;
            ship.turrets.forEach(e => {
                rating += (e.tier + 1) * ship.turrets.length;
            });
        }
        let index = 0;
        if (player.profile.dmg) {
            let sum = player.profile.dmg.filter(e => !isNaN(e)).reduce((acc, currentValue) => acc + currentValue, 0);
            if (sum > 0) {
                let avg = sum / player.profile.dmg.length;
                document.getElementById("stats").innerHTML += `
                <div style="position: absolute; top: ${index * 32}px; width: 100%; height: 30px;">
                <div style="position: absolute; top: 0px; left: 5px; color: #fff; font-size: 25px;">Avg Dmg:</div>
                <div style="position: absolute; top: 0px; right: 5px; color: #fff; font-size: 25px;">${avg >= 10e6 ? abbreviateNumber(avg) : Math.round(avg)}</div>
                </div>
                `;
                index++;
            }
        }
        if (player.profile.wins) {
            let sum = player.profile.wins.reduce((acc, currentValue) => acc + currentValue, 0);
            let avg = sum / player.profile.wins.length;
            document.getElementById("stats").innerHTML += `
            <div style="position: absolute; top: ${index * 32}px; width: 100%; height: 30px">
            <div style="position: absolute; top: 0px; left: 5px; color: #fff; font-size: 25px;">Avg Win Rate:</div>
            <div style="position: absolute; top: 0px; right: 5px; color: #fff; font-size: 25px;">${Math.round(avg * 100)}%</div>
            </div>
            `;
            index++;
        }
        document.getElementById("stats").innerHTML += `
        <div style="position: absolute; top: ${index * 32}px; width: 100%; height: 30px">
        <div style="position: absolute; top: 0px; left: 5px; color: #fff; font-size: 25px;">Hanger Rating:</div>
        <div style="position: absolute; top: 0px; right: 5px; color: #fff; font-size: 25px;">${rating}</div>
        </div>
        `;
        index++;
        document.getElementById("stats").innerHTML += `
        <div style="position: absolute; top: ${index * 32}px; width: 100%; height: 30px">
        <div style="position: absolute; top: 0px; left: 5px; color: #fff; font-size: 25px;">Rating:</div>
        <div style="position: absolute; top: 0px; right: 5px; color: #fff; font-size: 25px;">${player.league}</div>
        </div>
        `;
        index++;
        document.getElementById("stats").innerHTML += `
        <div style="position: absolute; top: ${index * 32}px; width: 100%; height: 30px">
        <div style="position: absolute; top: 0px; left: 5px; color: #fff; font-size: 25px;">League:</div>
        <div style="position: absolute; top: 0px; right: 5px; color: #fff; font-size: 25px;">${getLeagueName(player.league)}</div>
        </div>
        `;
        index++;
    }
    function updateMoneyDisplay(index, value) {
        if (index == "workshop points") index = "workshopPoints";
        if (index && index.includes("token")) {
            if (index == "token 1") {
                player.tokens.mk1 += value;
            } else if (index == "token 2") {
                player.tokens.mk2 += value;
            } else {
                player.tokens.mk3 += value;
            }
        } else if (index && index == "player_xp") {
            if (player.profile) {
                player.profile.xp.current += value;
                if (player.profile.xp.current >= player.profile.xp.max) {
                    let unlockedSomething = [];
                    let rewards = {
                        gold: 0,
                        silver: 0
                    };
                    while (player.profile.xp.current >= player.profile.xp.max) {
                        let last = player.profile.level;
                        rewards.gold += player.profile.level >= 25 ? 1e3 : 500;
                        rewards.silver += player.profile.level >= 25 ? 20e6 : player.profile.level >= 15 ? 1e6 : 500e3;
                        player.profile.xp.current -= player.profile.xp.max;
                        if (player.profile.xp.current < 0) {
                            player.profile.xp.current = 0;
                        }
                        player.profile.xp.max += player.profile.level >= 25 ? 300 : 150;
                        player.profile.level++;
                        if (player.profile.level >= 30) {
                            player.profile.level = 30;
                            player.profile.xp.current = 0;
                            player.profile.xp.max = 1e9;
                        }
                        unlockedAtTier.forEach(e => {
                            if (last < e && player.profile.level >= e) {
                                unlockedSomething.push(unlockedAtTier.findIndex(t => t == e));
                            }
                        });
                        if (last < 2 && player.profile.level >= 2) {
                            unlockedSomething.push("Unlocked Tasks");
                        }
                        if (last < 11 && player.profile.level >= 11) {
                            unlockedSomething.push("Unlocked Operation");
                        }
                        if (last < 6 && player.profile.level >= 6) {
                            unlockedSomething.push("Unlocked Lootboxes");
                        }
                        if (last < 30 && player.profile.level >= 30) {
                            unlockedSomething.push("Unlocked Mark Chests");
                        }
                        if (last < 21 && player.profile.level >= 21) {
                            unlockedSomething.push("Unlocked Workshop");
                        }
                        if (last < 16 && player.profile.level >= 16) {
                            unlockedSomething.push("Unlocked Microchips");
                        }
                        if (last < 10 && player.profile.level >= 10) {
                            unlockedSomething.push("Unlocked Drones");
                        }
                        if (last < 25 && player.profile.level >= 25) {
                            unlockedSomething.push("Unlocked Motherships");
                        }
                        if (last < 30 && player.profile.level >= 30) {
                            unlockedSomething.push("Unlocked Titans");
                        }
                    }
                    setUpUIStuffThing();
                    injectRewards(player.profile.level, rewards, unlockedSomething);
                }
                if (player.profile.level > 30) {
                    player.profile.level = 30;
                    player.profile.xp.current = 0;
                    player.profile.xp.max = 1e9;
                }
            }
        } else if (player[index] != null) player[index] += value;
        document.getElementById("moneyDisplay").innerHTML = `
        <div style="position: absolute; top: 5px; left: ${window.innerWidth / 2 - 62.5}px; border: solid; border-color: #fff; border-radius: 4px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
        <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('${agSource}');">
        </div>
        <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
        ${abbreviateNumber(player.sliver)}
        </div>
        </div>

        <div style="position: absolute; top: 5px; left: ${window.innerWidth / 2 - 200}px; border: solid; border-color: #fff; border-radius: 4px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
        <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('${auSource}');">
        </div>
        <div style="position: absolute; top: 6.75px; left: 40px;  color: #fff;">
        ${abbreviateNumber(player.gold)}
        </div>
        </div>

        <div style="position: absolute; top: 5px; left: ${window.innerWidth / 2 + 75}px; border: solid; border-color: #fff; border-radius: 4px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
        <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('./images/icons/workshop.png');">
        </div>
        <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
        ${abbreviateNumber(player.workshopPoints)}
        </div>
        </div>
        `;
        document.getElementById("money2Display").innerHTML = `
        <div style="position: absolute; top: 5px; left: ${window.innerWidth / 2 + 10}px; border: solid; border-color: #fff; border-radius: 4px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
        <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('./images/tokens/mk2_token.png');">
        </div>
        <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
        ${abbreviateNumber(player.tokens.mk2)}
        </div>
        </div>

        <div style="position: absolute; top: 5px; left: ${window.innerWidth / 2 - 135}px; border: solid; border-color: #fff; border-radius: 4px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
        <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('./images/tokens/mk1_token.png');">
        </div>
        <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
        ${abbreviateNumber(player.tokens.mk1)}
        </div>
        </div>

        <div style="position: absolute; top: 5px; left: ${window.innerWidth / 2 - 280}px; border: solid; border-color: #fff; border-radius: 4px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
        <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('${keysSource}');">
        </div>
        <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
        ${abbreviateNumber(player.keys)}
        </div>
        </div>

        <div style="position: absolute; top: 5px; left: ${window.innerWidth / 2 + 155}px; border: solid; border-color: #fff; border-radius: 4px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
        <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('./images/tokens/mk3_token.png');">
        </div>
        <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
        ${abbreviateNumber(player.tokens.mk3)}
        </div>
        </div>
        `;
        document.getElementById("money3Display").innerHTML = `
        <div style="position: absolute; top: 5px; left: ${window.innerWidth / 2 - 62.5}px; border: solid; border-color: #fff; border-radius: 4px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
        <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px;">
        <span class="material-symbols-outlined" style="font-size: 35px; color: #ffff00;">
        rewarded_ads
        </span>
        </div>
        <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
        ${abbreviateNumber(player.league)}
        </div>
        </div>
        `;
        if (player.profile) {
            if (player.profile.level == null) player.profile.level = 1;
            document.getElementById("pfp").innerHTML = `
            <span id="profileClick" class="material-symbols-outlined" style="cursor: pointer; font-size: 50px; color: #fff;">
            account_circle
            </span>
            <div style="position: absolute; height: 25px; left: 55px; top: 2px; width: 195px;">
            (${player.profile.level}) Player
            </div>
            <div style="position: absolute; height: 25px; left: 55px; bottom: 0px; width: 190px;">
            <div style="position: absolute; color: #fff; font-size: 12px; bottom: 10px;">
            ${player.profile.xp.current}/${abbreviateNumber(player.profile.xp.max)}
            </div>
            <div style="position: absolute; bottom: 5px; left: 0px; width: 190px; height: 5px; background-color: rgb(0, 0, 0, .25); border-radius: 12px; overflow: hidden;">
            <div style="position: absolute; top: 0px; left: 0px; width: ${100 * (player.profile.xp.current / player.profile.xp.max)}%; height: 100%; background-color: #fff;">
            </div>
            </div>
            </div>
            `;
            document.getElementById("profileClick").onclick = function () {
                doProfileClickStuff();
            };
            drawGameModesDisplay();
        }
        setUpUIStuffThing();
        if (index) saveGameData();
    }
    updateMoneyDisplay();
    var pixelDensity = 1;
    drawGameModesDisplay();
    function resize() {
        if (player.gameMode >= 0) {
            if (document.getElementById("chooseSlot").style.bottom == "-200px") {
                updateChooseSlots();
            }
        } else {
            drawGameModesDisplay();
            updateMoneyDisplay();
        }
        if (player.shapes.length) updateSlots();
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        let scaleFillNative = Math.max(window.innerWidth / maxScreen.x, window.innerHeight / maxScreen.y) * pixelDensity;
        canvas.width = window.innerWidth * pixelDensity;
        canvas.height = window.innerHeight * pixelDensity;
        canvas.style.width = window.innerWidth + "px";
        canvas.style.height = window.innerHeight + "px";
        ctx.setTransform(
            scaleFillNative, 0,
            0, scaleFillNative,
            (window.innerWidth * pixelDensity - (maxScreen.x * scaleFillNative)) / 2,
            (window.innerHeight * pixelDensity - (maxScreen.y * scaleFillNative)) / 2
        );
    }
    window.addEventListener("resize", resize);
    resize();
    window.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });
    if (player.shapes.length == 0) {
        player.shapes.push(new shape(shapeData[0], 0));
        player.weapons.push(new weapon(weaponData[0], 0, 0));
        player.weapons.push(new weapon(weaponData[0], 0, 1));
    }
    function renderStar(ctxt, spikes, outer, inner) {
        let rot = Math.PI / 2 * 3;
        let x, y;
        let step = Math.PI / spikes;
        ctxt.beginPath();
        if (!navigator.platform.includes("Mac")) ctxt.moveTo(0, -outer);
        for (var i = 0; i < spikes; i++) {
            x = Math.cos(rot) * outer;
            y = Math.sin(rot) * outer;
            ctxt.lineTo(x, y);
            rot += step;
            x = Math.cos(rot) * inner;
            y = Math.sin(rot) * inner;
            ctxt.lineTo(x, y);
            rot += step;
        }
        if (!navigator.platform.includes("Mac")) ctxt.lineTo(0, -outer);
        ctxt.closePath();
    }
    function renderCircle(x, y, scale, ctxt, dontStroke, dontFill, color, lineColor, lineWidth) {
        ctxt = ctxt || ctx;
        ctxt.lineWidth = lineWidth || 5.5;
        ctxt.strokeStyle = lineColor || "#000";
        ctxt.fillStyle = color;
        ctxt.beginPath();
        ctxt.arc(x, y, scale, 0, 2 * Math.PI);
        if (!dontFill) ctxt.fill();
        if (!dontStroke) ctxt.stroke();
    }
    function renderOval(x, y, rx, ry, ctx, color, strokeColor, dontStroke, dontFill, w) {
        ctx.beginPath();
        ctx.lineWidth = w || 5.5;
        ctx.fillStyle = color;
        ctx.strokeColor = strokeColor;
        ctx.ellipse(x, y, rx, ry, 0, 0, 2 * Math.PI);
        if (!dontFill) ctx.fill();
        if (!dontStroke) ctx.stroke();
    }
    var shapeSprites = {};
    function exportProgress() {
        let content = {};
        content.shapes = [];
        for (let i = 0; i < player.shapes.length; i++) {
            let shape = player.shapes[i];
            if (!shape.isSold) content.shapes.push({
                name: shape.name,
                sid: shape.sid,
                level: shape.level,
                slot: shape.slot,
                activeModuleIndex: shape.activeModuleIndex || 0
            });
        }
        content.weapons = [];
        for (let i = 0; i < player.weapons.length; i++) {
            let weapon = player.weapons[i];
            if (!weapon.isSold) content.weapons.push({
                name: weapon.name,
                owner: weapon.owner,
                slot: weapon.slot,
                level: weapon.level
            });
        }
        content.modules = [];
        for (let i = 0; i < player.modules.length; i++) {
            let MODLUE = player.modules[i];
            if (!MODLUE.isSold) content.modules.push({
                name: MODLUE.name,
                owner: MODLUE.owner,
                slot: MODLUE.slot,
                level: MODLUE.level
            });
        }
        content.pilots = [];
        content.exterminationIndx = player.exterminationIndx;
        for (let i = 0; i < player.pilots.length; i++) {
            let pilot = player.pilots[i];
            let skills = [];
            pilot.skills.forEach(e => {
                if (!e.legendary) {
                    skills.push({
                        name: e.name,
                        level: e.level,
                        robotOwner: e.robotOwner,
                        slot: e.slot
                    });
                }
            });
            content.pilots.push({
                name: pilot.name,
                owner: pilot.owner,
                level: pilot.level,
                skills: skills
            });
        }
        content.drones = [];
        for (let i = 0; i < player.drones.length; i++) {
            let MODLUE = player.drones[i];
            content.drones.push({
                name: MODLUE.name,
                owner: MODLUE.owner,
                level: MODLUE.level
            });
        }
        content.motherships = [];
        for (let i = 0; i < player.motherships.length; i++) {
            let mothership = player.motherships[i];
            let turrets = [];
            mothership.turrets.forEach(e => {
                turrets.push({
                    name: e.name,
                    slot: e.slot
                });
            });
            content.motherships.push({
                name: mothership.name,
                using: mothership.using,
                level: mothership.level,
                skills: turrets
            });
        }
        content.profile = player.profile;
        content.tokens = JSON.stringify(player.tokens);
        content.ULIMATEXP = player.ULIMATEXP;
        content.slotData = JSON.stringify(slotData);
        content.league = player.league;
        content.league2 = player.league2;
        content.keys = player.keys;
        content.sliver = player.sliver;
        content.gold = player.gold;
        content.lootboxSpecialPrize = JSON.stringify(player.lootboxSpecialPrize);
        content.workshopPoints = player.workshopPoints;
        content.workshopQueue = JSON.stringify(workshopQueue);
        content.operationData = JSON.stringify(operationData);
        content.parts = JSON.stringify(player.parts);
        content = JSON.stringify(content);
        content.profile = player.profile;
        let blob = new Blob([content], { type: "text/plain" });
        let url = window.URL.createObjectURL(blob);
        let link = document.createElement("a");
        link.href = url;
        link.download = "shapeWarAccountBackupFile.txt";
        link.click();
        window.URL.revokeObjectURL(url);
    }
    function importProgress(content) {
        try {
            player.shapes = [];
            player.weapons = [];
            player.modules = [];
            player.drones = [];
            player.pilots = [];
            player.motherships = [];
            if (content.exterminationIndx) {
                player.exterminationIndx = parseInt(content.exterminationIndx);
            }
            for (let i = 0; i < content.shapes.length; i++) {
                let data = content.shapes[i];
                if (data) {
                    try {
                        let Shape = shapeData.find(e => data.name == e.name);
                        let newShape = new shape(Shape, data.slot);
                        newShape.slot = data.slot;
                        if (data.slot) {
                            slotData[data.slot].unlocked = true;
                            slotData[data.slot].used = true;
                        }
                        if (activeModuleData[data.activeModuleIndex]) {
                            newShape.activeModuleIndex = data.activeModuleIndex;
                        } else {
                            newShape.activeModuleIndex = 0;
                        }
                        newShape.sid = data.sid;
                        if (newShape.sid == undefined || newShape.sid == null) {
                            newShape.sid = "get anew";
                        }
                        for (let t = 0; t < data.level - 1; t++) {
                            upgradeShape(newShape, true);
                        }
                        player.shapes.push(newShape);
                    } catch (e) {
                    }
                }
            }
            let largestSid = player.shapes.filter(e => e.sid >= 0).sort((a, b) => b.sid - a.sid)[0].sid + 1;
            player.shapes.filter(e => e.sid == "get anew").forEach(e => {
                e.sid = largestSid;
                largestSid++;
            });
            player.shapes.forEach(item => {
                if (player.shapes.find(e => e.sid == item.sid && e != item)) {
                    item.sid = largestSid;
                    largestSid++;
                }
            });
            shapeSids = largestSid;
            for (let i = 0; i < content.weapons.length; i++) {
                let data = content.weapons[i];
                if (data) {
                    let Weapon = weaponData.find(e => data.name == e.name);
                    let newWeapon = new weapon(Weapon, data.owner, data.slot);
                    let shapeSid = player.shapes.find(e => e.sid == data.owner);
                    if (!shapeSid) {
                        newWeapon.owner = null;
                        newWeapon.slot = null;
                    }
                    for (let t = 0; t < data.level - 1; t++) {
                        upgradeWeapon(newWeapon, null, null, true);
                    }
                    player.weapons.push(newWeapon);
                }
            }
            for (let i = 0; i < content.modules.length; i++) {
                let data = content.modules[i];
                if (data) {
                    let Module = moduleData.find(e => data.name == e.name);
                    if (Module && Module.name != "Arc Reactor") {
                        let newModule = new module(Module, data.owner, data.slot);
                        let shapeSid = player.shapes.find(e => e.sid == data.owner);
                        if (!shapeSid) {
                            newModule.owner = null;
                            newModule.slot = null;
                        }
                        for (let t = 0; t < data.level - 1; t++) {
                            upgradeModule(newModule, null, null, true);
                        }
                        player.modules.push(newModule);
                    }
                }
            }
            if (!content.drones) content.drones = [];
            for (let i = 0; i < content.drones.length; i++) {
                let data = content.drones[i];
                if (data) {
                    let Module = dronesData.find(e => data.name == e.name);
                    if (Module) {
                        let newModule = new drone(Module, data.owner);
                        let shapeSid = player.shapes.find(e => e.sid == data.owner);
                        if (!shapeSid) {
                            newModule.owner = null;
                            newModule.slot = null;
                        }
                        for (let t = 0; t < data.level - 1; t++) {
                            upgradeDrone(newModule, null, null, true);
                        }
                        player.drones.push(newModule);
                    }
                }
            }
            if (!content.pilots) content.pilots = [];
            for (let i = 0; i < content.pilots.length; i++) {
                let data = content.pilots[i];
                if (data) {
                    let Pilot = pilotsData.find(e => data.name == e.name);
                    if (Pilot) {
                        let thePilot = new pilot(Pilot, data.owner);
                        let shapeSid = player.shapes.find(e => e.sid == data.owner);
                        if (!shapeSid) {
                            thePilot.owner = null;
                        }
                        thePilot.level = data.level;
                        data.skills.forEach(e => {
                            let Skill = pilotSkillList.find(_ => _.name == e.name);
                            if (Skill) {
                                let theSkill = new skill(Skill, e.slot, {
                                    name: e.robotOwner
                                });
                                if (!theSkill.getAbilityBackAtHalfHealth) {
                                    for (let t = 0; t < e.level - 1; t++) {
                                        upgradePilotSkill(theSkill);
                                    }
                                }
                                thePilot.skills.push(theSkill);
                            }
                        });
                        player.pilots.push(thePilot);
                    }
                }
            }
            if (!content.motherships) content.motherships = [];
            for (let i = 0; i < content.motherships.length; i++) {
                let data = content.motherships[i];
                if (data) {
                    let Mothership = mothershipData.find(e => data.name == e.name);
                    if (Mothership) {
                        let thePilot = new mothership(Mothership, data.using);
                        for (let i = 0; i < data.level - 1; i++) {
                            upgradeMothership(thePilot)
                        }
                        data.skills.forEach(e => {
                            let Skill = turretsData.find(_ => _.name == e.name);
                            if (Skill) {
                                let index = thePilot.turrets.length;
                                thePilot.turrets.push({ ...Skill });
                                thePilot.turrets[index].slot = e.slot;
                            }
                        });
                        player.motherships.push(thePilot);
                    }
                }
            }
            player.shapes.forEach(item => {
                let weapons = player.weapons.filter(e => item.sid == e.owner);
                let heavy = weapons.filter(e => e.type == "Heavy");
                let light = weapons.filter(e => e.type == "Light");
                if (heavy.length > item.hardpoints.heavy || light.length > item.hardpoints.light) {
                    weapons.forEach(e => {
                        e.owner = null;
                        e.slot = null;
                    });
                }
                let modules = player.modules.filter(e => item.sid == e.owner);
                if (modules.length > item.moduleHardpoints) {
                    modules.forEach(e => {
                        e.slot = null;
                        e.owner = null;
                    });
                }
                let drones = player.drones.filter(e => item.sid == e.owner);
                if (drones.length > 1) {
                    drones.forEach(e => {
                        e.owner = null;
                    });
                }
                let pilots = player.pilots.filter(e => item.sid == e.owner);
                if (pilots.length > 1) {
                    pilots.forEach(e => {
                        e.owner = null;
                    });
                }
            });
            if (content.profile) {
                player.profile = content.profile;
            }
            if (content.workshopPoints != null) {
                player.workshopPoints = content.workshopPoints;
            }
            if (content.tokens) {
                player.tokens = JSON.parse(content.tokens);
            }
            if (content.lootboxSpecialPrize) {
                player.lootboxSpecialPrize = JSON.parse(content.lootboxSpecialPrize);
            }
            if (content.workshopQueue) {
                workshopQueue = JSON.parse(content.workshopQueue);
            }
            if (content.slotData) {
                content.slotData = JSON.parse(content.slotData);
                slotData = [...content.slotData];
                if (slotData.length < 9) {
                    slotData.push({
                        unlocked: true,
                        used: false,
                        cost: Infinity
                    });
                }
            }
            if (content.parts) {
                player.parts = JSON.parse(content.parts);
            }
            if (content.league2) {
                player.league2 = content.league2;
            } else {
                player.league2 = 0;
            }
            if (content.league) {
                player.league = content.league;
            } else {
                player.league = 0;
            }
            if (content.operationData) {
                operationData = JSON.parse(content.operationData);
            }
            if (!content.ULIMATEXP && content.ULIMATEXP != null && !isNaN(content.ULIMATEXP)) {
                player.ULIMATEXP = content.ULIMATEXP;
            }
            player.keys = content.keys;
            player.sliver = content.sliver;
            player.gold = content.gold;
            updateMoneyDisplay();
            updateSlots();
            saveGameData();
        } catch (e) {
            alert("Import Failed!\nIf this is a unexpected bug, contact the developer.");
            setTimeout(() => { location.reload(); }, 250);
        }
    }
    window.exportProgress = exportProgress;
    var settingToggles = {
        showFPS: true,
        renderDrone_player: true,
        renderWeaponRange: true,
        dmgHealText: false,
        renderBulletShadows: true,
        renderReflector: true
    };
    function resetAllAccountStats() {
        operationData = {
            xp: 0,
            currentIndex: 0,
            data: []
        };
        workshopQueue = [];
        player = {
            exterminationData: null,
            sliver: 200e3,
            gold: 250,
            keys: 1e3,
            shapes: [],
            weapons: [],
            modules: [],
            drones: [],
            pilots: [],
            motherships: [],
            gameMode: -1,
            ULIMATEXP: 0,
            workshopPoints: 0,
            league: 0,
            league2: 0,
            exterminationIndx: 0,
            tokens: {
                mk1: 0,
                mk2: 0,
                mk3: 0
            },
            profile: {
                level: 1,
                xp: {
                    current: 0,
                    max: 300
                }
            },
            parts: {
                shapes: {},
                weapons: {}
            }
        };
        shapeSids = 0;
        slotData = [{ unlocked: true, used: true, cost: 0 }, { unlocked: false, used: false, cost: 50 }, { unlocked: false, used: false, cost: 200 }, { unlocked: false, used: false, cost: 1e3 }, { unlocked: false, used: false, cost: 1e3 }, { unlocked: false, used: false, cost: 2e3 }, { unlocked: false, used: false, cost: 2e3 }, { unlocked: false, used: false, cost: 3e3 }, { unlocked: true, used: false, cost: Infinity }];
        if (player.shapes.length == 0) {
            player.shapes.push(new shape(shapeData[0], 0));
            player.weapons.push(new weapon(weaponData[0], 0, 0));
            player.weapons.push(new weapon(weaponData[0], 0, 1));
        }
        updateSlots();
        updateMoneyDisplay();
        saveGameData();
    }
    document.getElementById("settingsToggle").onclick = function () {
        if (document.getElementById("settingsMenu")) return;
        let element = document.createElement("div");
        element.style = `
        position: absolute;
        top: 12.5%;
        left: 12.5%;
        width: 75%;
        height: 75%;
        background-color: rgb(0, 0, 0, .6);
        border-radius: 6px;
        z-index: 99;
        `;
        element.id = "settingsMenu";
        let height = window.innerHeight * .75;
        let width = window.innerWidth * .75;
        let tabs = ["Interface", "Graphics", "Controls", "Account"];
        function generateToggle(id, text, checked) {
            if (settingToggles[id] == null) settingToggles[id] = checked ? true : false;
            return `${text}: <input id="${id}" style="cursor: pointer;" type="checkbox" ${checked ? "checked" : ""}><br>`;
        }
        element.innerHTML = `
        <div id="closeSettings" style="position: absolute; right: 7.5px; top: 7.5px; font-size: 35px; color: #fff; cursor: pointer;">
        <span class="material-symbols-outlined">
        close
        </span>
        </div>

        <div style="position: absolute; top: 7.5px; left: 5px;">
        <span class="material-symbols-outlined" style="font-size: 35px; color: #fff;">
        settings
        </span>
        <div style="position: absolute; left: 37.5px; top: -2.5px; font-size: 30px; color: #fff;">
        Settings
        </div>
        </div>
        <div id="tabsContainer" style="position: absolute; top: 50px; width: 250px; height: ${height - 50}px;">
        </div>
        <div id="123__thingyyy" style="position: absolute; top: 50px; width: ${width - 250 - 10 - 10}px; right: 10px; height: ${height - 50}px; background-color: rgb(0, 0, 0, .4); color: #fff; overflow-y: scroll; border-radius: 4px;">
        <div id="Interface_thingy" style="display: block;">
        <div style="margin-top: 5px; margin-left: 10px;">
        ${generateToggle("showFPS", "Show FPS", settingToggles.showFPS)}
        </div>
        </div>

        <div id="Graphics_thingy" style="display: none;">
        <div style="margin-top: 5px; margin-left: 10px;">
        ${generateToggle("renderWeaponRange", "Render Weapon Ranges", settingToggles.renderWeaponRange)}
        ${generateToggle("renderDrone_player", "Render Player Drone", settingToggles.renderDrone_player)}
        ${generateToggle("dmgHealText", "Render Dmg/Heal Text", settingToggles.dmgHealText)}
        ${generateToggle("renderBulletShadows", "Render Bullet Glow/Shadow", settingToggles.renderBulletShadows)}
        ${generateToggle("renderReflector", "Render Reflector Effect", settingToggles.renderReflector)}
        </div>
        </div>

        <div id="Controls_thingy" style="display: none;">
        <div style="margin-top: 5px; margin-left: 10px;">
        There are no options in this section yet.
        </div>
        </div>

        <div id="Account_thingy" style="display: none;">
        <div style="margin-top: 5px; margin-left: 10px;">
        <input id="importFile" type="file" style="width: 180px;" accept=".txt">
        <button id="import" style="cursor: pointer;">Import</button><br>
        <button onclick="exportProgress();" style="cursor: pointer;">Export</button><br><br>
        <button id="resetProgress" style="cursor: pointer;">Restart Progress</button><input type="checkbox" id="verify"><br><br>
        Type to sell: <select id="typeToSell">
        <option value="0" selected>Shapes</option>
        <option value="1">Weapons</option>
        </select><br>
        Highest tier to sell: <select id="highestTierToSell">
        <option value="0" selected>1</option>
        <option value="1">2</option>
        <option value="2">3</option>
        <option value="3">4</option>
        <option value="4">5</option>
        </select><br>
        Highest level to sell: <select id="highestLevelToSell">
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">MK2</option>
        <option value="14">MK3</option>
        </select><br>
        <button id="sellItems_" >Sell</button> (only sells things in inventory)
        </div>
        </div>
        </div>
        `;
        document.getElementById("hangerUI").appendChild(element);
        let checkboxs = document.getElementById("123__thingyyy").getElementsByTagName("input");
        for (let i = 0; i < checkboxs.length; i++) {
            if (checkboxs[i].type == "checkbox") {
                checkboxs[i].addEventListener("change", () => {
                    settingToggles[checkboxs[i].id] = checkboxs[i].checked;
                    if (checkboxs[i].id == "renderBulletShadows") {
                        bulletImages = {};
                    }
                    saveGameData();
                });
            }
        }
        let e = document.getElementById("tabsContainer");
        for (let i = 0; i < tabs.length; i++) {
            e.innerHTML += `
            <div id="tab${tabs[i]}" style="${i == 0 ? "" : "cursor: pointer;"} width: 100%; height: 25px; font-size: 17px; color: ${i == 0 ? "#000" : "#fff"}; background-color: ${i == 0 ? "rgb(255, 255, 255, .6)" : i % 2 == 0 ? "rgb(0, 0, 0, .1)" : "rgb(0, 0, 0, .2)"};">
            <div style="margin-left: 10px;">${tabs[i]}</div>
            </div>
            `;
        }
        for (let i = 0; i < tabs.length; i++) {
            document.getElementById(`tab${tabs[i]}`).onclick = function () {
                tabs.forEach((item, index) => {
                    document.getElementById(item + "_thingy").style.display = item == tabs[i] ? "block" : "none";
                    document.getElementById(`tab${item}`).style = `${item == tabs[i] ? "" : "cursor: pointer;"} width: 100%; height: 25px; font-size: 17px; color: ${item == tabs[i] ? "#000" : "#fff"}; background-color: ${item == tabs[i] ? "rgb(255, 255, 255, .6)" : index % 2 == 0 ? "rgb(0, 0, 0, .1)" : "rgb(0, 0, 0, .2)"};`;
                });
            }
        }
        document.getElementById("resetProgress").onclick = function () {
            if (document.getElementById("verify").checked) {
                resetAllAccountStats();
                setTimeout(() => {
                    location.reload();
                }, 500);
            }
        }
        document.getElementById("sellItems_").onclick = function () {
            let typeToSell = document.getElementById("typeToSell").value;
            let highestTierToSell = parseInt(document.getElementById("highestTierToSell").value);
            let highestLevelToSell = parseInt(document.getElementById("highestLevelToSell").value);
            if (typeToSell == 0) {
                let amount = 0;
                player.shapes.filter(e => e.slot == null && e.level <= highestLevelToSell && e.tier <= highestTierToSell).forEach(shape => {
                    amount += shape.sellPrice;
                    shape.isSold = true;
                    player.weapons.filter(e => e.owner == shape.sid).forEach(e => {
                        e.owner = null;
                        e.slot = null;
                    });
                    player.modules.filter(e => e.owner == shape.sid).forEach(e => {
                        e.owner = null;
                        e.slot = null;
                    });
                    player.drones.filter(e => e.owner == shape.sid).forEach(e => {
                        e.owner = null;
                    });
                });
                if (amount > 0) {
                    updateMoneyDisplay("sliver", amount);
                    alert(`You have earned: ${abbreviateNumber(amount)} Silver`);
                }
            } else {
                let amount = 0;
                player.weapons.filter(e => (e.owner == undefined || e.owner == null) && e.level <= highestLevelToSell && e.tier <= highestTierToSell).forEach(e => {
                    e.isSold = true;
                    amount += e.sellPrice;
                });
                if (amount > 0) {
                    updateMoneyDisplay("sliver", amount);
                    alert(`You have earned: ${abbreviateNumber(amount)} Silver`);
                }
            }

            this.blur();
        }
        document.getElementById("closeSettings").onclick = function () {
            element.remove();
        }
        document.getElementById("import").onclick = function () {
            let fileInput = document.getElementById("importFile");
            if (fileInput.files.length > 0) {
                let selectedFile = fileInput.files[0];
                if (selectedFile.name.endsWith(".txt")) {
                    let reader = new FileReader();
                    reader.onload = function (e) {
                        let fileContents = e.target.result;
                        fileContents = fileContents.toString();
                        fileContents = JSON.parse(fileContents);
                        importProgress(fileContents);
                    };
                    reader.readAsText(selectedFile);
                }
            } else {
                alert("No file selected.");
            }
        };
    }
    var workshopQueue = [];
    var defaultData = [{
        tier: 696969,
        name: "Workshop Points",
        amount: 180,
        time: 3.6e6,
        cost: 175e3
    }, {
        tier: 696969,
        name: "Gold",
        amount: 35,
        time: 3.6e6,
        cost: 350e3
    }];
    function updateWorkshopDataStuff() {
        let items = shapeData.filter(e => e.costParts && !e.dontSell && !e.dontShow);
        items.forEach(e => {
            defaultData.push({
                name: e.name,
                tier: e.tier,
                type: "shape",
                amount: window.isDev ? 10e3 : e.tier == 4 ? 120 : e.tier == 3 ? 180 : 210,
                time: window.isDev ? 1e3 : (3.6e6 / 2) * (e.tier + 1),
                cost: (e.tier + 1) * 100e3
            });
        });
        defaultData = defaultData.sort((a, b) => b.tier - a.tier);
    }
    function displayPartsInventory(type) {
        let element = document.getElementById("inventoryDisplay");
        document.getElementById("invetory").style.display = "block";
        document.getElementById("production").style.display = "none";
        document.getElementById("inventoryDisplay").innerHTML = "";
        let Item = [];
        if (type == 0) {
            Item = shapeData.filter(e => e.costParts && !e.dontShow);
        }
        let thingy = player.parts.shapes;
        Item = Item.sort((a, b) => b.tier - a.tier).sort((a, b) => (thingy[b.name] || 0) - (thingy[a.name] || 0));
        for (let i = 0; i < Item.length; i++) {
            let item = Item[i];
            element.innerHTML += `
            <div style="position: absolute; top: 0px; left: ${250 * i}px; height: 100%; width: 250px; background-color: ${i % 2 == 0 ? "rgb(255, 255, 255, .4)" : "rgb(0, 0, 0, .2)"};">
            <div style="width: 100%; font-size: 24px; background-color: #101010; color: ${tierColor(item)}">${item.name}</div>
            <div id="image${i}" style="position: absolute; top: 32.5px; width: 250px; height: 250px;">
            </div>
            <div style="position: absolute; left: 10px; font-size: 12px; bottom: 55px; color: ${i % 2 == 0 ? "#000" : "#fff"};">
            <span class="material-symbols-outlined">
            extension
            </span>
            <div style="left: 26px; position: absolute; top: 4px; color: ${i % 2 == 0 ? "#000" : "#fff"};">
            ${(thingy[item.name] || 0)}/10000
            </div>
            </div>
            <div style="position: absolute; bottom: 50px; left: 10px; width: 230px; height: 3px; background-color: #575757;">
            <div style="height: 100%; width: ${Math.min(1, (thingy[item.name] || 0) / 10e3) * 100}%; background-color: ${tierColor(item)};">
            </div>
            </div>
            <div id="sadijasidojasoidhasidasudgyasdkdalsisd${i}" style="position: absolute; ${thingy[item.name] >= 10e3 ? "cursor: pointer;" : ""}; text-align: center; color: #fff; font-size: 24px; width: 230px; bottom: 10px; height: 35px; background-color: ${thingy[item.name] >= 10e3 ? "#02a302" : "#808080"}; right: 10px;">
            GET
            </div>
            </div>
            `;
        }
        for (let i = 0; i < Item.length; i++) {
            let item = Item[i];
            if (type == 0) {
                document.getElementById(`sadijasidojasoidhasidasudgyasdkdalsisd${i}`).onclick = function () {
                    if (thingy[item.name] - 10e3 >= 0) {
                        player.parts.shapes[item.name] -= 10e3;
                        let theThing = shapeData.find(e => e.name == item.name);
                        let sid = shapeSids;
                        player.shapes.push(new SHAPPPPPPPPPE(theThing));
                        let hardpoints = theThing.hardpoints.light + theThing.hardpoints.heavy;
                        for (let i = 0; i < hardpoints; i++) {
                            if (i < theThing.hardpoints.light && theThing.hardpoints.light > 0) {
                                player.weapons.push(new weapon(weaponData[0], sid, i));
                            } else {
                                player.weapons.push(new weapon(weaponData[2], sid, i));
                            }
                        }
                        displayPartsInventory(type);
                        saveGameData();
                    }
                }
                let image = getShapeSprite(item, true);
                image.style = "width: 100%; height: 100%;";
                document.getElementById(`image${i}`).appendChild(image);
            }
        }
    }
    function formatMilliseconds(milliseconds) {
        let seconds = Math.floor(milliseconds / 1000);
        let minutes = Math.floor(seconds / 60);
        let hours = Math.floor(minutes / 60);
        let days = Math.floor(hours / 24);
        let formattedTime = "";
        if (days > 0) {
            formattedTime += `${days}d `;
        }
        if (hours % 24 > 0) {
            formattedTime += `${hours % 24}h `;
        }
        if (minutes % 60 > 0) {
            formattedTime += `${minutes % 60}m `;
        }
        formattedTime += `${seconds % 60}s`;
        return formattedTime.trim();
    }
    function addWorkQueue(slot) {
        document.getElementById("thingy2Display").style.display = "block";
        document.getElementById("thingyDisplay").style.display = "none";
        document.getElementById("thingy2Display").innerHTML = "";
        document.body.append(document.getElementById("moneyDisplay"));
        for (let i = 0; i < defaultData.length; i++) {
            document.getElementById("thingy2Display").innerHTML += `
            <div id="thingyDisplayContent${i}" style="position: absolute; top: 0px; left: ${200 * i}px; height: 300px; width: 200px; background-color: ${i % 2 == 0 ? "rgb(0, 0, 0, .2)" : "rgb(255, 255, 255, 0.4)"};">
            </div>
            `;
        }
        for (let i = 0; i < defaultData.length; i++) {
            let item = defaultData[i];
            let element = document.getElementById(`thingyDisplayContent${i}`);
            element.innerHTML += `
            <div style="${item.type ? "" : "display: none;"} position: absolute; bottom: 0px; left: 0px; width: 100%; height: 50%; background-image: linear-gradient(rgb(0, 0, 0, 0), ${tierColor(item)});">
            </div>
            <div style="color: #fff; position: absolute; left: 10px; font-size: 24px; top: 175px;">
            <span class="material-symbols-outlined" style="font-size: 24px;">
            extension
            </span>
            </div>
            <div style="color: #fff; position: absolute; right: 10px; font-size: 24px; top: 169px;">
            ${item.amount}
            </div>
            <div style="position: absolute; bottom: 55px; left: 10px; text-align: center;">
            <div style="width: 20px; height: 20px; background-size: 20px 20px; background-image: url('${agSource}');">
            </div>
            <div style="position: absolute; width: 180px; top: 0px; left: 0px; text-align: center;">${abbreviateNumber(item.cost)}</div>
            </div>
            <div id="buythinglol${i}" style="display: ${unlockedAtTier[item.tier] > player.profile.level ? "none" : "block"}; cursor: pointer; position: absolute; text-align: center; bottom: 10px; left: 10px; width: 180px; height: 45px; background-color: #0f0; border-radius: 4px;">
            <span style="font-size: 20px;">PRODUCE</span><br>
            <span style="font-size: 10px;">${formatMilliseconds(item.time)}</span>
            </div>
            <div style="display: ${unlockedAtTier[item.tier] > player.profile.level ? "block" : "none"}; cursor: pointer; position: absolute; text-align: center; bottom: 10px; left: 10px; width: 180px; height: 45px; background-color: #808080; border-radius: 4px;">
            <span style="font-size: 30px;">LOCKED</span>
            </div>
            `;
            if (item.name == "Workshop Points" || item.name == "Gold") {
                element.style.backgroundSize = "200px 200px";
                element.style.backgroundRepeat = "no-repeat";
                if (item.name == "Gold") {
                    element.style.backgroundImage = `url('${auSource}')`;
                } else {
                    element.style.backgroundImage = `url('./images/icons/workshop.png')`;
                }
            } else {
                if (item.type == "shape") {
                    let image = getShapeSprite(shapeData.find(e => e.name == item.name), true);
                    image.style = "z-index: 10000000; width: 200px; height: 200px;";
                    element.appendChild(image);
                }
            }
            document.getElementById(`buythinglol${i}`).onclick = function () {
                if (player.sliver - item.cost >= 0) {
                    document.getElementById("hangerUI").append(document.getElementById("moneyDisplay"));
                    updateMoneyDisplay("sliver", -item.cost);
                    let length = workshopQueue.length;
                    workshopQueue.push({ ...item });
                    workshopQueue[length].slot = slot;
                    workshopQueue[length].date = Date.now();
                    updateWorkshopDisplay();
                    saveGameData();
                }
            }
        }
    }
    function doDrawTheWorkyThingy(ele, thing, h, slot) {
        ele.innerHTML = `
        <div style="position: absolute; width: 100%; text-align: center;">
        ${(thing.date + thing.time) - Date.now() <= 0 ? "Done!" : formatMilliseconds((thing.date + thing.time) - Date.now())}
        </div>
        <div id="collectstuff${slot}" style="position: absolute; font-size: 34px; text-align: center; border-radius: 6px; bottom: 10px; left: 10px; width: 255px; height: 50px; background-color: ${(thing.date + thing.time) - Date.now() <= 0 ? "#0f0; cursor: pointer;" : "#808080;"}">
        COLLECT
        </div>
        `;
        if (thing.name == "Workshop Points" || thing.name == "Gold") {
            ele.style.backgroundSize = "275px 275px";
            ele.style.backgroundRepeat = "no-repeat";
            if (thing.name == "Gold") {
                ele.style.backgroundImage = `url('${auSource}')`;
            } else {
                ele.style.backgroundImage = `url('./images/icons/workshop.png')`;
            }
        } else {
            if (thing.type == "shape") {
                let image = getShapeSprite(shapeData.find(e => e.name == thing.name), true);
                image.style = "width: 275px; height: 275px;";
                ele.appendChild(image);
            }
        }
        document.getElementById(`collectstuff${slot}`).onclick = function () {
            if ((thing.date + thing.time) - Date.now() <= 0) {
                if (thing.name == "Workshop Points") {
                    updateMoneyDisplay("workshopPoints", thing.amount);
                } else if (thing.name == "Gold") {
                    updateMoneyDisplay("gold", thing.amount);
                } else {
                    if (thing.type == "shape") {
                        if (player.parts.shapes[thing.name] == null || isNaN(player.parts.shapes[thing.name])) player.parts.shapes[thing.name] = 0;
                        player.parts.shapes[thing.name] += thing.amount;
                    }
                }
                let index = workshopQueue.findIndex(e => e.slot == slot);
                workshopQueue.splice(index, 1);
                updateWorkshopDisplay();
            }
        }
    }
    function updateWorkshopDisplay() {
        document.getElementById("thingy2Display").style.display = "none";
        document.getElementById("thingyDisplay").style.display = "block";
        let element = document.getElementById("thingyDisplay");
        document.getElementById("hangerUI").append(document.getElementById("moneyDisplay"));
        element.innerHTML = "";
        for (let i = 0; i < 10; i++) {
            element.innerHTML += `
            <div id="workShopSlot${i}" style="position: absolute; left: ${i * 275}px; top: 0px; width: 275px; height: 100%; background-color: ${i % 2 == 0 ? "rgb(0, 0, 0, .2)" : "rgb(255, 255, 255, 0.4)"};">
            </div>
            `;
        }
        for (let i = 0; i < 10; i++) {
            let thing = workshopQueue.find(e => e.slot == i);
            let ele = document.getElementById(`workShopSlot${i}`);
            if (thing) {
                doDrawTheWorkyThingy(ele, thing, true, i);
            } else {
                ele.style.cursor = "pointer";
                ele.innerHTML = `
                <div style="position: absolute; text-align: center; top: ${375 / 2 - (275 / 2)}px; height: 275px; width: 275px;">
                <span class="material-symbols-outlined" style="font-size: 275px; color: #fff;">
                add
                </span>
                </div>
                `;
                ele.onclick = function () {
                    addWorkQueue(i);
                };
            }
        }
        let deltaTImerrr = 0;
        let lastUpdate = 0;
        function update() {
            let delta = Date.now() - lastUpdate;
            lastUpdate = Date.now();
            deltaTImerrr -= delta;
            if (deltaTImerrr <= 0) {
                deltaTImerrr = 1e3;
                workshopQueue.forEach(e => {
                    if (document.getElementById(`workShopSlot${e.slot}`)) {
                        doDrawTheWorkyThingy(document.getElementById(`workShopSlot${e.slot}`), e, false, e.slot);
                    }
                });
            }
            if (document.getElementById("thingyDisplay") && document.getElementById("thingyDisplay").style.display == "block") {
                window.requestAnimationFrame(update);
            }
        }
        window.requestAnimationFrame(update);
    }
    document.getElementById("workshopToggle").onclick = function () {
        document.getElementById("sideDisplay").innerHTML = `
        <div id="invetory" style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;">
        <div id="inventoryDisplay" style="position: absolute; right: 0px; top: ${window.innerHeight / 2 - 175}px; width: ${window.innerWidth - 400}px; height: 350px; background-color: rgb(0, 0, 0, 0.3); overflow-x: scroll;">
        </div>
        <div id="shapeTab" style="position: absolute; left: 235px; font-size: 25px; top: ${window.innerHeight / 2 - (35 / 2)}px; background-color: rgb(255, 255, 255, 0.4); text-align: center; width: 150px; height: 35px; border-radius: 4px;">
        SHAPES
        </div>
        <div id="gotoworkshop" style="position: absolute; color: #fff; cursor: pointer; right: 10px; top: ${window.innerHeight / 2 + 185}px; width: 50px; height: 50px; border-radius: 4px; background-color: rgb(0, 0, 0, 0.3);">
        <span class="material-symbols-outlined" style="font-size: 50px;">
        extension
        </span>
        </div>
        </div>
        <div id="production" style="display: none; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;">
        <div id="thingyDisplay" style="position: absolute; left: 0px; top: ${window.innerHeight / 2 - 187.5}px; height: 375px; width: 100%; overflow-x: scroll; background-color: rgb(0, 0, 0, 0.2);">
        </div>
        <div id="thingy2Display" style="display: none; position: absolute; left: 0px; top: ${window.innerHeight / 2 - 150}px; height: 300px; width: 100%; overflow-x: scroll; background-color: rgb(0, 0, 0, 0.2);">
        </div>
        </div>
        <div id="backButton" style="position: fixed; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        `;
        displayPartsInventory(0);
        document.getElementById("gotoworkshop").onclick = function () {
            this.style.display = "none";
            document.getElementById("invetory").style.display = "none";
            document.getElementById("production").style.display = "block";
            updateWorkshopDisplay();
        }
        document.getElementById("hangerUI").style.display = "none";
        document.getElementById("backButton").onclick = function () {
            document.getElementById("sideDisplay").innerHTML = "";
            document.getElementById("hangerUI").style.display = "block";
        }
    }
    document.getElementById("historyToggle").onclick = function () {
        document.getElementById("hangerUI").style.display = "none";
        document.getElementById("sideDisplay").innerHTML = mainDisplayText;
        document.getElementById("sideDisplay").innerHTML += `
        <div id="backButton" style="position: fixed; cursor: pointer; text-align: center; font-size: 40px; color: #fff; right: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        `;
        document.getElementById("backButton").onclick = function () {
            document.getElementById("hangerUI").style.display = "block";
            document.getElementById("sideDisplay").innerHTML = "";
        }
    }
    var shapeImagesSpecial = {};
    function getShapeImage(obj) {
        let tmp = shapeImagesSpecial[obj.specialOf];
        if (!tmp) {
            tmp = new Image();
            tmp.src = obj.specialOf;
            tmp.onload = function () {
                tmp.isLoaded = true;
            }
            shapeImagesSpecial[obj.specialOf] = tmp;
        }
        return tmp;
    }
    function getShapeSprite(obj, isIcon) {
        let tmpSprite = shapeSprites[obj.name];
        if (!tmpSprite) {
            let tmpCanvas = document.createElement("canvas");
            tmpCanvas.width = tmpCanvas.height = obj.scale * (isIcon ? 3 : 1.2);
            tmpCanvas.style.width = tmpCanvas.style.height = (obj.scale * (isIcon ? 3 : 1.2)) + "px";
            let tmpCtx = tmpCanvas.getContext("2d");
            tmpCtx.globalAlpha = 1;
            tmpCtx.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
            if (!obj.industryName) obj.industryName = "";
            if (obj.name.includes("Circle") || obj.industryName.includes("Circle")) {
                renderCircle(0, 0, obj.scale, tmpCtx, false, false, obj.color, obj.borderColor || "#000", 5.5 * (obj.increaseLine ? obj.increaseLine : 1));
            } else if (obj.name.includes("Pentagon") || obj.industryName.includes("Pentagon")) {
                tmpCtx.rotate(Math.PI / 2);
                tmpCtx.strokeStyle = obj.borderColor || "#000";
                tmpCtx.lineWidth = 12 * (obj.increaseLine ? obj.increaseLine : 1);
                tmpCtx.fillStyle = obj.color;
                renderStar(tmpCtx, 2.5, obj.scale, obj.scale);
                tmpCtx.stroke();
                tmpCtx.fill();
            } else if (obj.name.includes("Square") || obj.industryName.includes("Square")) {
                tmpCtx.rotate(Math.PI / 2);
                tmpCtx.strokeStyle = (obj.borderColor || "#000");
                tmpCtx.lineWidth = 12 * (obj.increaseLine ? obj.increaseLine : 1);
                tmpCtx.fillStyle = obj.color;
                renderStar(tmpCtx, 2, obj.scale, obj.scale);
                tmpCtx.stroke();
                tmpCtx.fill();
            } else if (obj.name.includes("Hexagon") || obj.industryName.includes("Hexagon")) {
                tmpCtx.rotate(Math.PI / 2);
                tmpCtx.strokeStyle = (obj.borderColor || "#000");
                tmpCtx.lineWidth = 12 * (obj.increaseLine ? obj.increaseLine : 1);
                tmpCtx.fillStyle = obj.color;
                renderStar(tmpCtx, 3, obj.scale, obj.scale);
                tmpCtx.stroke();
                tmpCtx.fill();
            } else if (obj.name.includes("Heptagon") || obj.industryName.includes("Heptagon")) {
                tmpCtx.rotate(Math.PI / 2);
                tmpCtx.strokeStyle = "#000";
                tmpCtx.lineWidth = 12 * (obj.increaseLine ? obj.increaseLine : 1);
                tmpCtx.fillStyle = obj.color;
                renderStar(tmpCtx, 3.5, obj.scale, obj.scale);
                tmpCtx.stroke();
                tmpCtx.fill();
            } else if (obj.name.includes("Triangle") || obj.industryName.includes("Triangle")) {
                tmpCtx.rotate(Math.PI / 2);
                tmpCtx.strokeStyle = (obj.borderColor || "#000");
                tmpCtx.lineWidth = 12 * (obj.increaseLine ? obj.increaseLine : 1);
                tmpCtx.fillStyle = obj.color;
                renderStar(tmpCtx, 1.5, obj.scale, obj.scale);
                tmpCtx.stroke();
                tmpCtx.fill();
            } else if (obj.name.includes("Octagon") || obj.industryName.includes("Octagon")) {
                tmpCtx.rotate(Math.PI / 2);
                tmpCtx.strokeStyle = "#000";
                tmpCtx.lineWidth = 12 * (obj.increaseLine ? obj.increaseLine : 1);
                tmpCtx.fillStyle = obj.color;
                renderStar(tmpCtx, 4, obj.scale, obj.scale);
                tmpCtx.stroke();
                tmpCtx.fill();
            } else if (obj.name == "Polygon") {
                renderCircle(0, 0, obj.scale, tmpCtx, false, false, "#e9e9e9", "#000");
                tmpCtx.rotate(Math.PI / 2);
                tmpCtx.strokeStyle = "#000";
                tmpCtx.lineWidth = 12
                tmpCtx.fillStyle = "#ffb400";
                renderStar(tmpCtx, 3.5, obj.scale * .7, obj.scale * .7);
                tmpCtx.stroke();
                tmpCtx.fill();
                tmpCtx.rotate(-(Math.PI / 2));

                tmpCtx.rotate(Math.PI / 2);
                tmpCtx.strokeStyle = "#000";
                tmpCtx.lineWidth = 12 * (obj.increaseLine ? obj.increaseLine : 1);
                tmpCtx.fillStyle = "#ffff00";
                renderStar(tmpCtx, 2.5, obj.scale * .4, obj.scale * .4);
                tmpCtx.stroke();
                tmpCtx.fill();
            }
            if (!isIcon) shapeSprites[obj.name] = tmpCanvas;
            tmpSprite = tmpCanvas;
        }
        return tmpSprite;
    }
    var weaponIcons = {};
    function getWeaponIcon(obj, isIcon) {
        let tmpIcon = weaponIcons[obj.name];
        if (!tmpIcon) {
            tmpIcon = new Image();
            tmpIcon.src = obj.imageSource;
            tmpIcon.onload = function () {
                tmpIcon.isLoaded = true;
            }
            if (!isIcon) weaponIcons[obj.name] = tmpIcon;
        }
        return tmpIcon;
    }
    var moduleIcon = {};
    function getModuleIcon(obj, isIcon) {
        let tmpIcon = moduleIcon[obj.name];
        if (!tmpIcon) {
            tmpIcon = new Image();
            tmpIcon.src = obj.imageSource;
            tmpIcon.onload = function () {
                tmpIcon.isLoaded = true;
            }
            if (!isIcon) moduleIcon[obj.name] = tmpIcon;
        }
        return tmpIcon;
    }
    const WEPAONAPOENOPAWNEOPWANEAPWOEN = weapon;
    function styleNumberWithCommas(number) {
        return Math.floor(number).toLocaleString();
    }
    function drawWeaponDisplay(weapons, index, HA, shape, slot, inInventory) {
        let Weapon = weapons[index];
        if (!Weapon) return;
        let newWeapon = weaponData.find(e => Weapon.name == e.name);
        let weapon = new WEPAONAPOENOPAWNEOPWANEAPWOEN(newWeapon);
        for (let i = 0; i < Weapon.level - 1; i++) {
            upgradeWeapon(weapon, null, null, true);
        }// && e.titan == shape.titan
        let currentIndex = index;
        document.getElementById("WEAPONdisplay").innerHTML = `
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(rgb(0, 0, 0, 0), ${tierColor(weapon)});">
        </div>
        <div id="weaponImage" style="position: absolute; top: ${window.innerHeight / 2 - 187.5}px; left: ${window.innerWidth / 2 - 187.5}px; height: 375px; width: 375px;">
        </div>
        <div style="display: ${Weapon.amount == "main" ? "none" : "block"};position: absolute; text-align: center; top: ${window.innerHeight / 2 + 187.5}px; left: ${window.innerWidth / 2 - 187.5}px; height: 100px; width: 375px;">
        In Stock: ${(!inInventory ? player.weapons.filter(e => e.name == Weapon.name).length : Weapon.amount)}
        </div>
        <div style="position: absolute; top: ${window.innerHeight / 2 - 250}px; left: ${window.innerWidth / 2 - 522.5}px; width: 325px; height: 500px; background-color: rgb(0, 0, 0, .2); border: solid; border-color: #fff; border-radius: 6px;">
        <div style="position: absolute; top: 7px; left: 5px;">
        <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(weapon)};">
        ${weapon.level >= 13 && !weapon.titan ? 1 : weapon.level}
        </div>
        <div style="position: absolute; top: 2px; width: 260px; left: 45px; color: #fff; font-size: 24px;">
        <strong>
        ${returnStyledName(weapon, weapon.name)}
        ${weapon.level >= 13 && !weapon.titan ? `<span style="color: #${levelToMKColor(weapon.level)};">${levelToMKText(weapon.level)}</span>` : ""}
        </strong>
        </div>
        </div>
        <div style="position: absolute; top: 45px; left: 0px;">
        <hr style="position: absolute; top: 0px; left: 0px; color: #fff; width: 325px;">
        <div style="position: absolute; top: 15px; left: 5px; width: 320px;">
        <strong>Industry: ${weapon.industryName}</strong><br><br>
        ${weapon.desc}<br>
        <hr style="position: absolute; left: -5px; color: #fff; width: 325px;">
        <br>
        ${weapon.dmg ? `Damage: ${styleNumberWithCommas(weapon.dmg)}<br>Total Damage: ${weapon.ammo == 1e300 ? Infinity : styleNumberWithCommas(weapon.dmg * weapon.ammo * (weapon.shotsPerFire || 1))}<br><span style="font-size: 8px;">^^^Not including other factors like damage multiplication, DoT, or BLAST.</span><br>` : ""}
        ${weapon.range ? `Range: ${weapon.range} PX<br>` : ""}
        ${weapon.reload > 0 ? `${weapon.chargingMechanic ? "Charging Time" : "Reload"}: ${(weapon.reload * (weapon.continuousReload ? weapon.ammo / weapon.ammoEachReloadTick : 1)) / 1000} sec<br>` : ""}
        ${weapon.chargingDelay ? `Charging Delay: ${weapon.chargingDelay / 1e3} sec<br>` : ""}
        ${weapon.motherShipCharge ? `MS Charge per Bullet: ${(weapon.motherShipCharge * 100).toFixed(4)}%<br>` : ""}
        ${weapon.aoeRange ? "AOE Range: " + weapon.aoeRange + " PX<br>" : ""}
        ${weapon.dotDamage ? `DOT Damage: ${styleNumberWithCommas(weapon.dotDamage)}<br>` : ""}
        ${weapon.effectIncrease ? `Effect Accumulation: ${Math.round(weapon.effectIncrease * 1e4) / 100}%<br>` : ""}
        ${weapon.fireRateDecrease + 1 >= 0 ? `Fire Rate Decrease: ${weapon.fireRateDecrease} ms<br>` : ""}
        ${weapon.baseShielding ? `Shield Durability: ${abbreviateNumber(weapon.baseShielding.health)}<br>` : ""}
        ${weapon.defenseBypass ? `Defense Mitigation: ${weapon.defenseBypass * 100}%<br>` : ""}
        ${weapon.healBackOnDamage ? `On Damage Heal Back: ${weapon.healBackOnDamage * 100}%<br>` : ""}
        ${weapon.overheatTime ? `Overheat Time: ${weapon.overheatTime / 1e3} second(s)` : ""}
        <p></p>
        </div>
        </div>
        </div>
        <div id="Unequip" style="display: ${Weapon.amount == "main" ? "block" : !inInventory ? "none" : "none"}; position: absolute; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 187.5}px; top: ${window.innerHeight / 2 + 35}px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #f00;">
        UNEQUIP
        </div>
        <div id="Equip" style="display: ${Weapon.amount == "main" ? "none" : !inInventory ? "none" : "block"}; position: absolute; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 187.5}px; top: ${window.innerHeight / 2 + 35}px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #0f0;">
        EQUIP
        </div>
        <div id="Upgrade" style="position: absolute; display: ${!inInventory ? "none" : "block"}; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 187.5}px; top: ${window.innerHeight / 2 - 25}px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #0f0;">
        UPGRADE
        </div>
        <div id="buyWeapon" style="position: absolute; display: ${!inInventory ? "block" : "none"}; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 187.5}px; top: ${window.innerHeight / 2 - 25}px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #0f0;">
        ${unlockedAtTier[weapon.tier] > player.profile.level ? "LOCKED" : "BUY"}
        </div>
        <div id="upgradeMenu" style="z-index: 2; position: absolute; color: #fff; display: none; top: 12.5%; left: 12.5%; width: 75%; height: 75%; background-color: rgb(0, 0, 0, .7);">
        </div>
        <div style="position: absolute; bottom: 100px; left: 12.5%; width: 75%; height: 6px; background-color: #fff; border-radius: 4px; overflow: hidden;">
        <div style="position: absolute; top: 0px; left: ${(1 / weapons.length) * 100 * currentIndex}%; width: ${(1 / weapons.length) * 100}%; height: 100%; background-color: #00dbcd;">
        </div>
        </div>
        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        <div id="buyMenu" style="position: absolute; display: none; color: #fff; top: ${(window.innerHeight / 2) - (225 / 2)}px; left: ${(window.innerWidth / 2) - (425 / 2)}px; width: 425px; height: 225px; background-color: rgb(0, 0, 0, .7);">
        </div>
        <div id="sellItem" style="position: absolute; display: ${!inInventory ? "none" : Weapon.amount == "main" ? "none" : "block"}; cursor: pointer; top: ${window.innerHeight / 2 + 95}px; left: ${window.innerWidth / 2 + 187.5}px; width: 50px; height: 50px; background-color: rgb(0, 0, 0, .4);">
        <span class="material-symbols-outlined" style="font-size: 50px; color: #fff;">
        delete
        </span>
        </div>
        `;
        let weaponImg = getWeaponIcon(weapon, true);
        weaponImg.style = "width: 100%; height: 100%;";
        document.getElementById("weaponImage").appendChild(weaponImg);
        document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
        if (weapons[index].dontSell) document.getElementById("buyWeapon").style.display = "none";
        document.getElementById("Unequip").onclick = function () {
            let weapon = player.weapons.find(e => shape.sid == e.owner && e.slot == slot);
            weapon.slot = null;
            weapon.owner = null;
            if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                document.getElementById("slot" + shape.slot).click();
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            } else {
                document.getElementById("hangerUI").style.display = "block";
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
        }
        document.getElementById("Equip").onclick = function () {
            let weapon = player.weapons.find(e => e.name == Weapon.name && e.owner == null && e.level == Weapon.level);
            let oldWeapon = player.weapons.find(e => shape.sid == e.owner && e.slot == slot);
            if (oldWeapon) {
                oldWeapon.owner = null;
                oldWeapon.slot = null;
            }
            weapon.owner = shape.sid;
            weapon.slot = slot;
            if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                document.getElementById("slot" + shape.slot).click();
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            } else {
                document.getElementById("hangerUI").style.display = "block";
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
        }
        document.getElementById("Upgrade").onclick = function () {
            let weapon = player.weapons.find(e => e.name == Weapon.name && (Weapon.amount == "main" ? shape.sid == e.owner && e.slot == slot : !e.owner) && e.level == Weapon.level);
            if (!weapon) return;
            let titanUpgradeCost = (shape.level * (120 * ((shape.tier + 1) * .25)) + Math.ceil(shape.level / 5) * 1200) * (shape.tier + 1) * .5;
            document.body.appendChild(document.getElementById("moneyDisplay"));
            let adjustwidth = window.innerWidth * .75;
            document.getElementById("upgradeMenu").style.display = "block";
            document.getElementById("upgradeMenu").innerHTML = `
            <div style="width: 100%; text-align: center; margin-top: 5px; font-size: 30px;">
            ${[14, 13].includes(weapon.level) && !weapon.titan ? `${weapon.name} <span style="color: ${weapon.level == 13 ? "#0f0" : "#ffff00"};">${weapon.level == 13 ? "MK2" : "MK3"}</span>` : `Lvl ${weapon.level} ${weapon.name}`}
            </div>
            <hr>
            <div style="position: absolute; left: 300px; top: 65px;">
            ${enterBarForWeapon("damage", weapon)}
            ${enterBarForWeapon("dot damage", weapon)}
            ${enterBarForWeapon("effect increase", weapon)}
            ${enterBarForWeapon("fireRateDecreaseData", weapon)}
            ${enterBarForWeapon("shield hp", weapon)}
            ${enterBarForWeapon("defenseBypass", weapon)}
            ${enterBarForWeapon("ondamageheal", weapon)}
            </div>
            <div id="leaveUpgrade" style="position: absolute; cursor: pointer; right: 10px; top: 10px;">
            X
            </div>
            <div id="UPGRADE" style="position: absolute; width: 200px; height: 80px; cursor: pointer; left: ${adjustwidth / 2 - 100}px; bottom: 10px; background-color: ${weapon.level < 25 && weapon.titan ? "#00ff00" : sliverUpgradesByTier[weapon.tier].weapons[weapon.level] ? "#00ff00" : [12, 13].includes(weapon.level) ? "#ffff00" : "#808080"};">
            <div style="color: ${weapon.level < 25 && weapon.titan ? "#fff" : [12, 13].includes(weapon.level) ? "f00" : "#fff"}; width: 100%; text-align: center; font-size: ${weapon.level < 25 && weapon.titan ? "24" : sliverUpgradesByTier[weapon.tier].weapons[weapon.level] ? "24" : [12, 13].includes(weapon.level) ? "24" : "40"}px; margin-top: ${weapon.level < 25 && weapon.titan ? "5" : sliverUpgradesByTier[weapon.tier].weapons[weapon.level] ? "5" : [12, 13].includes(weapon.level) ? "5" : "10"}px;">${weapon.level < 25 && weapon.titan ? "UPGRADE" : sliverUpgradesByTier[weapon.tier].weapons[weapon.level] ? "UPGRADE" : [12, 13].includes(weapon.level) ? "ENHANCE" : "MAXED"}</div>
            <div style="color: ${weapon.level < 25 && weapon.titan ? "#fff" : [12, 13].includes(weapon.level) ? "f00" : "#fff"}; display: ${weapon.level < 25 && weapon.titan ? "block" : sliverUpgradesByTier[weapon.tier].weapons[weapon.level] ? "block" : [12, 13].includes(weapon.level) ? "block" : "none"}; width: 100%; text-align: center; font-size: 12px;">${weapon.level < 25 && weapon.titan ? `${abbreviateNumber(titanUpgradeCost)} WSP` : [12, 13].includes(weapon.level) ? `${abbreviateNumber(weapon.enhanceCost * (weapon.level == 13 ? 24 : 1))} Gold` : `${abbreviateNumber(sliverUpgradesByTier[weapon.tier].weapons[weapon.level])} Sliver`}</div>
            </div>
            `;
            let sprite = getWeaponIcon(weapon, true);
            sprite.style = "width: 280px; height: 280px;";
            document.getElementById("upgradeMenu").appendChild(sprite);
            document.getElementById("leaveUpgrade").onclick = function () {
                document.getElementById("upgradeMenu").style.display = "none";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
            document.getElementById("UPGRADE").onclick = function () {
                if (weapon.titan) {
                    if (weapon.level < 25 && player.workshopPoints - titanUpgradeCost >= 0) {
                        updateMoneyDisplay("workshopPoints", -titanUpgradeCost);
                        upgradeWeapon(weapon, currentIndex, weapons, false, false, shape, slot, inInventory);
                    }
                } else if (sliverUpgradesByTier[weapon.tier].weapons[weapon.level] || weapon.level == 12 || weapon.level == 13) {
                    if (weapon.level >= 12) {
                        if (player.gold - (weapon.enhanceCost * (weapon.level == 13 ? 24 : 1)) >= 0) {
                            updateMoneyDisplay("gold", -(weapon.enhanceCost * (weapon.level == 13 ? 24 : 1)));
                            upgradeWeapon(weapon, currentIndex, weapons, false, false, shape, slot, inInventory);
                        }
                    } else {
                        if (player.sliver - sliverUpgradesByTier[weapon.tier].weapons[weapon.level] >= 0) {
                            updateMoneyDisplay("sliver", -sliverUpgradesByTier[weapon.tier].weapons[weapon.level]);
                            upgradeWeapon(weapon, currentIndex, weapons, false, false, shape, slot, inInventory);
                        } else if (player.gold > 0) {
                            let amountNeeded = sliverUpgradesByTier[weapon.tier].weapons[weapon.level] - player.sliver;
                            let amountToGold = Math.round(amountNeeded / 1250);
                            if (player.gold - amountToGold >= 0) {
                                let answer = prompt(`Not Enough Silver!\nYou Need ${abbreviateNumber(amountNeeded)} Silver!\nUse ${abbreviateNumber(amountToGold)} Gold to make up for the amount of silver missing!\nType "y" or "yes" to confirm.`);
                                if (answer) {
                                    answer = answer.toLocaleLowerCase();
                                    if (answer == "yes" || answer == "y") {
                                        updateMoneyDisplay("sliver", -player.sliver);
                                        updateMoneyDisplay("gold", -amountToGold);
                                        upgradeWeapon(weapon, currentIndex, weapons, false, false, shape, slot, inInventory);
                                    }
                                }
                            }
                        }
                    }
                }

            }
        }
        document.getElementById("backButton").onclick = function () {
            if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                document.getElementById("slot" + shape.slot).click();
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            } else {
                document.getElementById("hangerUI").style.display = "block";
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
        }
        document.getElementById("buyWeapon").onclick = function () {
            if (unlockedAtTier[weapon.tier] > player.profile.level) return;
            document.body.appendChild(document.getElementById("moneyDisplay"));
            document.getElementById("buyMenu").style.display = "block";
            document.getElementById("storeButton").style.display = "none";
            document.getElementById("inventoryButton").style.display = "none";
            let num = 60;
            let theHA = weapons[currentIndex];
            document.getElementById("buyMenu").innerHTML = `
            <div style="width: 100%; text-align: center; font-size: 30px;">
            Confirm Purchase
            </div>
            <hr>
            <div id="lo____l" style="position: absolute; cursor: pointer; top: 5px; right: 10px;">
            x
            </div>

            <div style="position: absolute; top: ${num}px; left: ${425 / 2 - 62.5}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
            <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('${agSource}');">
            </div>
            <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
            ${abbreviateNumber(theHA.cost.sliver)}
            </div>
            </div>
    
            <div style="position: absolute; top: ${num}px; left: ${425 / 2 - 200}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
            <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('${auSource}');">
            </div>
            <div style="position: absolute; top: 6.75px; left: 40px;  color: #fff;">
            ${abbreviateNumber(theHA.cost.gold)}
            </div>
            </div>
    
            <div style="position: absolute; top: ${num}px; left: ${425 / 2 + 75}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
            <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('./images/icons/workshop.png');">
            </div>
            <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
            ${abbreviateNumber(theHA.cost.workshopPoints || 0)}
            </div>
            </div>

            <div id="confirm" style="position: absolute; cursor: pointer; font-size: 24px; text-align: center; bottom: 10px; left: ${425 / 2 - 75}px; width: 150px; border-radius: 6px; height: 40px; background-color: #0f0;">
            Confirm
            </div>
            `;
            document.getElementById("confirm").onclick = function () {
                let theThing = weapons[currentIndex];
                if (player.sliver - theThing.cost.sliver >= 0 && player.gold - theThing.cost.gold >= 0) {
                    if ((!theThing.cost.workshopPoints ? true : player.workshopPoints - theThing.cost.workshopPoints >= 0)) {
                        updateMoneyDisplay("sliver", -theThing.cost.sliver);
                        updateMoneyDisplay("gold", -theThing.cost.gold);
                        updateMoneyDisplay("workshopPoints", -(theThing.cost.workshopPoints || 0));
                        let oldWeapon = player.weapons.find(e => e.owner == shape.sid && e.slot == slot);
                        if (oldWeapon) {
                            oldWeapon.slot = null;
                            oldWeapon.owner = null;
                        }
                        player.weapons.push(new WEPAONAPOENOPAWNEOPWANEAPWOEN(theThing, shape.sid, slot));
                        if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                            document.getElementById("slot" + shape.slot).click();
                            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                        } else {
                            document.getElementById("hangerUI").style.display = "block";
                            document.getElementById("sideDisplay").innerHTML = "";
                            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                        }
                    }
                }
            }
            document.getElementById("lo____l").onclick = function () {
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                document.getElementById("buyMenu").style.display = "none";
                document.getElementById("storeButton").style.display = "block";
                document.getElementById("inventoryButton").style.display = "block";
            }
        }
        if (HA) {
            document.getElementById("Upgrade").click();
        }
    }
    function enterBarForWeapon(type, weapon) {
        let text = "";
        let Weapon = weaponData.find(item => item.name == weapon.name)
        let maxwidth = window.innerWidth >= 1442 ? 500 : window.innerWidth >= 1374 ? 450 : window.innerWidth >= 1311 ? 400 : window.innerWidth >= 1245 ? 350 : window.innerWidth >= 1182 ? 300 : 250;
        maxwidth += 281.25;
        if (type == "damage" && Weapon.damageData) {
            let maxdmg = Weapon.damageData.base;
            for (let i = 0; i < Weapon.damageData.level.length; i++) {
                maxdmg += Weapon.damageData.level[i];
            }
            let mk1 = maxdmg;
            if (!weapon.titan) maxdmg *= 1.2;
            let mk2 = maxdmg;
            if (!weapon.titan) maxdmg *= 1.05;
            let indexAdjust = ((weapon.dmg / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.dmg + (weapon.level == 13 ? maxdmg - mk2 : weapon.level == 12 ? mk2 - mk1 : Weapon.damageData.level[weapon.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Damage: ${abbreviateNumber(weapon.dmg)}
            <div style="display: ${Weapon.damageData.level[weapon.level] ? "block" : weapon.level == 13 ? "block" : weapon.level == 12 ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${(weapon.level == 13 && !weapon.titan ? abbreviateNumber(maxdmg - mk2) : weapon.level == 12 && !weapon.titan ? abbreviateNumber(mk2 - mk1) : abbreviateNumber(Weapon.damageData.level[weapon.level]))}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "dot damage" && Weapon.dotData) {
            let maxdmg = Weapon.dotData.base;
            for (let i = 0; i < Weapon.dotData.level.length; i++) {
                maxdmg += Weapon.dotData.level[i];
            }
            let Mk1 = maxdmg;
            if (!weapon.titan) maxdmg *= 1.2;
            let Mk2 = maxdmg;
            if (!weapon.titan) maxdmg *= 1.05;
            let indexAdjust = ((weapon.dotDamage / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.dotDamage + (weapon.level == 13 ? (maxdmg - Mk2) : weapon.level == 12 ? (Mk2 - Mk1) : Weapon.dotData.level[weapon.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            DOT Damage: ${abbreviateNumber(weapon.dotDamage)}
            <div style="display: ${Weapon.dotData.level[weapon.level] ? "block" : weapon.level == 13 ? "block" : weapon.level == 12 ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${(weapon.level == 13 && !weapon.titan ? abbreviateNumber(maxdmg - Mk2) : weapon.level == 12 && !weapon.titan ? abbreviateNumber(Mk2 - Mk1) : abbreviateNumber(Weapon.dotData.level[weapon.level]))}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "effect increase" && Weapon.effectIncreaseData) {
            let maxdmg = Weapon.effectIncreaseData.base;
            for (let i = 0; i < Weapon.effectIncreaseData.level.length; i++) {
                maxdmg += Weapon.effectIncreaseData.level[i];
            }
            let indexAdjust = ((weapon.effectIncrease / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.effectIncrease + Weapon.effectIncreaseData.level[weapon.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Effect Accumulation: ${Math.round(weapon.effectIncrease * 1e4) / 100}%
            <div style="display: ${Weapon.effectIncreaseData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Weapon.effectIncreaseData.level[weapon.level] * 100}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "fireRateDecreaseData" && Weapon.fireRateDecreaseData) {
            let maxdmg = Weapon.fireRateDecreaseData.base;
            for (let i = 0; i < Weapon.fireRateDecreaseData.level.length; i++) {
                maxdmg += Weapon.fireRateDecreaseData.level[i];
            }
            let indexAdjust = ((weapon.fireRateDecrease / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.fireRateDecrease + Weapon.fireRateDecreaseData.level[weapon.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Fire Rate Decrease: ${abbreviateNumber(weapon.fireRateDecrease)} ms
            <div style="display: ${Weapon.fireRateDecreaseData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${abbreviateNumber(Weapon.fireRateDecreaseData.level[weapon.level])} ms
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "shield hp" && weapon.baseShielding) {
            let maxspeed = Weapon.shieldData.base;
            for (let i = 0; i < Weapon.shieldData.level.length; i++) {
                maxspeed += Weapon.shieldData.level[i];
            }
            let MK1 = maxspeed;
            if (!weapon.titan) maxspeed *= 1.2;
            let Mk2 = maxspeed;
            if (!weapon.titan) maxspeed *= 1.05;
            let indexAdjust = ((weapon.baseShielding.health / maxspeed) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.baseShielding.health + (weapon.level == 13 ? maxspeed - Mk2 : weapon.level == 12 ? Mk2 - MK1 : Weapon.shieldData.level[weapon.level])) / maxspeed) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Shield Durability: ${abbreviateNumber(weapon.baseShielding.health)}
            <div style="display: ${Weapon.shieldData.level[weapon.level] ? "block" : weapon.level == 13 ? "block" : weapon.level == 12 ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${weapon.level == 13 && !weapon.titan ? abbreviateNumber(maxspeed - Mk2) : weapon.level == 12 && !weapon.titan ? abbreviateNumber(Mk2 - MK1) : abbreviateNumber(Weapon.shieldData.level[weapon.level])}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "defenseBypass" && Weapon.defenseBypassData) {
            let maxdmg = Weapon.defenseBypassData.base;
            for (let i = 0; i < Weapon.defenseBypassData.level.length; i++) {
                maxdmg += Weapon.defenseBypassData.level[i];
            }
            let indexAdjust = ((weapon.defenseBypass / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.defenseBypass + Weapon.defenseBypassData.level[weapon.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Defense Mitigation: ${(weapon.defenseBypass * 100)}%
            <div style="display: ${Weapon.defenseBypassData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${(Weapon.defenseBypassData.level[weapon.level] * 100)}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "ondamageheal" && Weapon.healBackOnDamageData) {
            let maxdmg = Weapon.healBackOnDamageData.base;
            for (let i = 0; i < Weapon.healBackOnDamageData.level.length; i++) {
                maxdmg += Weapon.healBackOnDamageData.level[i];
            }
            let indexAdjust = ((weapon.healBackOnDamage / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.healBackOnDamage + Weapon.healBackOnDamageData.level[weapon.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            On Damage: Heal Back: ${(weapon.healBackOnDamage * 100)}%
            <div style="display: ${Weapon.healBackOnDamageData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${(Weapon.healBackOnDamageData.level[weapon.level] * 100)}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        }
        return text;
    }
    function upgradeWeapon(weapon, currentIndex, weapons, noEz, isBOT, shape, slot, inInventory) {
        let Weapon = weaponData.find(item => item.name == weapon.name);
        if (Weapon.damageData) {
            if (weapon.level < 12 || weapon.titan) {
                if (!weapon.titan) weapon.sellPrice += sliverUpgradesByTier[weapon.tier].weapons[weapon.level] * .75;
                let dmgIncrease = Weapon.damageData.level[weapon.level];
                weapon.dmg += dmgIncrease;
            } else {
                weapon.dmg *= weapon.level == 13 ? 1.05 : 1.2;
                weapon.dmg = Math.round(weapon.dmg);
            }
        }
        if (Weapon.dotData) {
            if (weapon.level < 12 || weapon.titan) {
                let dmgIncrease = Weapon.dotData.level[weapon.level];
                weapon.dotDamage += dmgIncrease;
            } else {
                weapon.dotDamage *= weapon.level == 13 ? 1.05 : 1.2;
                weapon.dotDamage = Math.round(weapon.dotDamage);
            }
        }
        if (weapon.baseShielding) {
            if (weapon.level < 12) {
                let increase = Weapon.shieldData.level[weapon.level];
                weapon.baseShielding.health += increase;
            } else {
                weapon.baseShielding.health *= weapon.level == 13 ? 1.05 : 1.2;
            }
        }
        if (Weapon.fireRateDecreaseData) {
            if (weapon.level < 12) {
                let dmgIncrease = Weapon.fireRateDecreaseData.level[weapon.level];
                weapon.fireRateDecrease += dmgIncrease;
            }
        }
        if (Weapon.healBackOnDamageData && weapon.level < 12) {
            let dmgIncrease = Weapon.healBackOnDamageData.level[weapon.level];
            weapon.healBackOnDamage += dmgIncrease;
            weapon.healBackOnDamage *= 1000;
            weapon.healBackOnDamage = Math.round(weapon.healBackOnDamage);
            weapon.healBackOnDamage /= 1000;
        }
        if (Weapon.defenseBypassData && weapon.level < 12) {
            let dmgIncrease = Weapon.defenseBypassData.level[weapon.level];
            weapon.defenseBypass += dmgIncrease;
            weapon.defenseBypass *= 100;
            weapon.defenseBypass = Math.round(weapon.defenseBypass);
            weapon.defenseBypass /= 100;
        }
        if (Weapon.effectIncreaseData && weapon.level < 12) {
            let dmgIncrease = Weapon.effectIncreaseData.level[weapon.level];
            weapon.effectIncrease += dmgIncrease;
        }
        weapon.level++;
        if (!noEz) {
            weapons[currentIndex].level++;
            customizeWeapon(weapon, shape, slot);
            if (!inInventory) {
                document.getElementById("storeButton").click();
            }
            for (let i = 0; i < currentIndex; i++) {
                document.getElementById("goToNext").click();
            }
            document.getElementById("Upgrade").click();
        }
        if (!noEz) updateSlots();
        if (!noEz) saveGameData();
    }
    function customizeWeapon(weapon, shape, slot) {
        if (true) {
            let filteredWeapons = [];
            if (weapon == "Light" || weapon == "Heavy") {
                let f = player.weapons.filter(e => e.owner == null && e.type == weapon && e.titan == shape.titan).sort((a, b) => b.level - a.level).sort((a, b) => b.tier - a.tier);
                for (let i = 0; i < f.length; i++) {
                    let item = f[i];
                    if (item.isSold) continue;
                    if (filteredWeapons.find(e => e.name == item.name && e.level == item.level)) {
                        let index = filteredWeapons.findIndex(e => e.name == item.name && e.level == item.level);
                        filteredWeapons[index].amount++;
                    } else {
                        filteredWeapons.push({
                            name: item.name,
                            level: item.level,
                            amount: 1
                        });
                    }
                }
            } else {
                let f = player.weapons.filter(e => e.owner == null && e.type == weapon.type && e.titan == shape.titan).sort((a, b) => b.level - a.level).sort((a, b) => b.tier - a.tier);
                for (let i = 0; i < f.length; i++) {
                    let item = f[i];
                    if ((item.owner == shape.sid && item.slot == slot) || item.isSold) continue;
                    if (filteredWeapons.find(e => e.name == item.name && e.level == item.level)) {
                        let index = filteredWeapons.findIndex(e => e.name == item.name && e.level == item.level);
                        filteredWeapons[index].amount++;
                    } else {
                        filteredWeapons.push({
                            name: item.name,
                            level: item.level,
                            amount: 1
                        });
                    }
                }
            }
            let mainWeapon = player.weapons.find(e => e.owner == shape.sid && e.slot == slot);
            if (mainWeapon) {
                filteredWeapons.unshift({
                    name: mainWeapon.name,
                    level: mainWeapon.level,
                    amount: "main"
                });
            }
            let currentIndex = 0;
            document.getElementById("sideDisplay").innerHTML = `
            <div id="WEAPONdisplay" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;">
            </div>
            <div id="goToPre" style="display: none; position: absolute; cursor: pointer; left: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
            <div id="goToPreCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
            <span class="material-symbols-outlined" style="font-size: 40px;">
            navigate_before
            </span>
            </div>
            </div>
            <div id="goToNext" style="position: absolute; transition: .25s; cursor: pointer; right: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
            <div id="goToNextCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
            <span class="material-symbols-outlined" style="font-size: 40px;">
            navigate_next
            </span>
            </div>
            </div>
            <div id="inventoryButton" style="position: absolute; text-align: center; font-size: 25px; color: #000; left: ${window.innerWidth / 2 - 165}px; top: 30px; border-radius: 6px; height: 42.5px; padding-top: 7.5px; width: 150px; background-color: rgb(255, 255, 255, .6);">
            INVENTORY
            </div>
            <div id="storeButton" style="position: absolute; text-align: center; font-size: 35px; cursor: pointer; color: #fff; left: ${window.innerWidth / 2 + 20}px; top: 30px; border-radius: 6px; height: 50px; width: 150px; background-color: rgb(0, 0, 0, .4);">
            STORE
            </div>
            `;
            let inInventory = true;
            let filteredShopItems = weaponData.filter(e => !e.dontShow && e.titan == shape.titan && (typeof weapon == "string" ? e.type == weapon : e.type == weapon.type));
            let diiiisbled = false;
            document.getElementById("inventoryButton").onclick = function () {
                if (!diiiisbled) {
                    this.style.cursor = null;
                    this.style.color = "#000";
                    this.style.backgroundColor = "rgb(255, 255, 255, .6)";
                    document.getElementById("goToPre").style.display = "none";
                    document.getElementById("goToNext").style.display = "block";
                    document.getElementById("storeButton").style.cursor = "pointer";
                    document.getElementById("storeButton").style.color = "#fff";
                    document.getElementById("storeButton").style.backgroundColor = "rgb(0, 0, 0, .4)";
                    currentIndex = 0;
                    inInventory = true;
                    drawWeaponDisplay(inInventory ? filteredWeapons : filteredShopItems.filter(e => e.titan == shape.titan).sort((a, b) => a.tier - b.tier), currentIndex, false, shape, slot, inInventory);
                }
            };
            document.getElementById("storeButton").onclick = function () {
                this.style.cursor = null;
                this.style.color = "#000";
                this.style.backgroundColor = "rgb(255, 255, 255, .6)";
                document.getElementById("goToPre").style.display = "none";
                document.getElementById("goToNext").style.display = "block";
                document.getElementById("inventoryButton").style.cursor = "pointer";
                document.getElementById("inventoryButton").style.color = "#fff";
                document.getElementById("inventoryButton").style.backgroundColor = "rgb(0, 0, 0, .4)";
                currentIndex = 0;
                inInventory = false;
                drawWeaponDisplay(inInventory ? filteredWeapons : filteredShopItems.filter(e => e.titan == shape.titan).sort((a, b) => a.tier - b.tier), currentIndex, false, shape, slot, inInventory);
            };
            if (filteredWeapons.length == 0) {
                document.getElementById("storeButton").click();
                document.getElementById("inventoryButton").style.cursor = null;
                diiiisbled = true;
            }
            drawWeaponDisplay(filteredWeapons, 0, false, shape, slot, inInventory);
            if (!(inInventory ? filteredWeapons[currentIndex - 1] : filteredShopItems.filter(e => e.titan == shape.titan)[currentIndex - 1])) {
                document.getElementById("goToPre").style.display = "none";
            }
            document.getElementById("goToPre").onclick = function () {
                currentIndex--;
                drawWeaponDisplay(inInventory ? filteredWeapons : filteredShopItems.filter(e => e.titan == shape.titan).sort((a, b) => a.tier - b.tier), currentIndex, false, shape, slot, inInventory);
                if (!(inInventory ? filteredWeapons[currentIndex - 1] : filteredShopItems.filter(e => e.titan == shape.titan)[currentIndex - 1])) {
                    document.getElementById("goToPre").style.display = "none";
                } else {
                    document.getElementById("goToPre").style.display = "block";
                }
                if (!(inInventory ? filteredWeapons[currentIndex + 1] : filteredShopItems.filter(e => e.titan == shape.titan)[currentIndex + 1])) {
                    document.getElementById("goToNext").style.display = "none";
                } else {
                    document.getElementById("goToNext").style.display = "block";
                }
            }
            if (!(inInventory ? filteredWeapons[currentIndex + 1] : filteredShopItems.filter(e => e.titan == shape.titan)[currentIndex + 1])) {
                document.getElementById("goToNext").style.display = "none";
            }
            document.getElementById("goToNext").onclick = function () {
                currentIndex++;
                drawWeaponDisplay(inInventory ? filteredWeapons : filteredShopItems.filter(e => e.titan == shape.titan).sort((a, b) => a.tier - b.tier), currentIndex, false, shape, slot, inInventory);
                if (!(inInventory ? filteredWeapons[currentIndex + 1] : filteredShopItems.filter(e => e.titan == shape.titan)[currentIndex + 1])) {
                    document.getElementById("goToNext").style.display = "none";
                } else {
                    document.getElementById("goToNext").style.display = "block";
                }
                if (!(inInventory ? filteredWeapons[currentIndex - 1] : filteredShopItems.filter(e => e.titan == shape.titan)[currentIndex - 1])) {
                    document.getElementById("goToPre").style.display = "none";
                } else {
                    document.getElementById("goToPre").style.display = "block";
                }
            }
            document.getElementById("goToNext").onmouseover = function () {
                this.style.backgroundColor = "rgb(255, 255, 255, .45)";
                document.getElementById("goToNextCon").style.color = "#000";
            }
            document.getElementById("goToNext").onmouseout = function () {
                this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
                document.getElementById("goToNextCon").style.color = "#fff";
            }
            document.getElementById("goToPre").onmouseover = function () {
                this.style.backgroundColor = "rgb(255, 255, 255, .45)";
                document.getElementById("goToPreCon").style.color = "#000";
            }
            document.getElementById("goToPre").onmouseout = function () {
                this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
                document.getElementById("goToPreCon").style.color = "#fff";
            }
        }
    }
    function removeDecimals(value) {
        let string = value.toString();
        if (string.includes(".")) {
            return string.split(".")[0];
        }
        return string;
    }
    function enterBarForModule(type, module) {
        let text = "";
        let Module = moduleData.find(item => item.name == module.name);
        let maxwidth = window.innerWidth >= 1442 ? 500 : window.innerWidth >= 1374 ? 450 : window.innerWidth >= 1311 ? 400 : window.innerWidth >= 1245 ? 350 : window.innerWidth >= 1182 ? 300 : 250;
        maxwidth += 281.25;
        if (type == "healthIncrease" && Module.healthIncreaseData) {
            let maxdmg = Math.abs(Module.healthIncreaseData.base);
            for (let i = 0; i < Module.healthIncreaseData.level.length; i++) {
                maxdmg += Math.abs(Module.healthIncreaseData.level[i]);
            }
            let indexAdjust = ((Math.abs(module.healthIncrease) / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((Math.abs(module.healthIncrease) + Math.abs(Module.healthIncreaseData.level[module.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Health Increase: ${Math.round(module.healthIncrease * 1e3) / 10}%
            <div style="display: ${Math.abs(Module.healthIncreaseData.level[module.level]) ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            ${Module.healthIncreaseData.level[module.level] >= 0 ? "+" : ""}${Math.round(Module.healthIncreaseData.level[module.level] * 1e3) / 10}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "selfFixRepair" && Module.selfFixRepairData) {
            let maxdmg = Module.selfFixRepairData.base;
            for (let i = 0; i < Module.selfFixRepairData.level.length; i++) {
                maxdmg += Module.selfFixRepairData.level[i];
            }
            let indexAdjust = ((module.selfFixRepair / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.selfFixRepair + Module.selfFixRepairData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Repair Power: ${abbreviateNumber(module.selfFixRepair)}/SEC
            <div style="display: ${Module.selfFixRepairData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${abbreviateNumber(Module.selfFixRepairData.level[module.level])}/SEC
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "dmgIncrease" && Module.dmgIncreaseData) {
            let maxdmg = Module.dmgIncreaseData.base;
            for (let i = 0; i < Module.dmgIncreaseData.level.length; i++) {
                maxdmg += Module.dmgIncreaseData.level[i];
            }
            let indexAdjust = ((module.dmgIncrease / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.dmgIncrease + Module.dmgIncreaseData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Damage Increase: ${Math.round(module.dmgIncrease * 1e3) / 10}%
            <div style="display: ${Module.dmgIncreaseData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Math.round(Module.dmgIncreaseData.level[module.level] * 1e3) / 10}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "immunity" && Module.immunePercentData) {
            let maxdmg = Module.immunePercentData.base;
            for (let i = 0; i < Module.immunePercentData.level.length; i++) {
                maxdmg += Module.immunePercentData.level[i];
            }
            let indexAdjust = ((module.immunePercent / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.immunePercent + Module.immunePercentData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Immunity Threshold: ${removeDecimals(module.immunePercent * 100)}%
            <div style="display: ${Module.immunePercentData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${removeDecimals(Module.immunePercentData.level[module.level] * 100)}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "lastingTime" && Module.immunePercentData) {
            let maxdmg = Module.lastingTimeData.base;
            for (let i = 0; i < Module.lastingTimeData.level.length; i++) {
                maxdmg += Module.lastingTimeData.level[i];
            }
            let indexAdjust = ((module.lastingTime / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.lastingTime + Module.lastingTimeData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Effect Duration: ${module.lastingTime / 1000} sec
            <div style="display: ${Module.lastingTimeData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Module.lastingTimeData.level[module.level] / 1000} sec
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "shieldHealth" && Module.shieldHealthData) {
            let maxdmg = Module.shieldHealthData.base;
            for (let i = 0; i < Module.shieldHealthData.level.length; i++) {
                maxdmg += Module.shieldHealthData.level[i];
            }
            let indexAdjust = ((module.shieldHealth / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.shieldHealth + Module.shieldHealthData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Shield Durability Increase: ${module.shieldHealth * 100}%
            <div style="display: ${Module.shieldHealthData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Module.shieldHealthData.level[module.level] * 100}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "shieldRegen" && Module.shieldRegenData) {
            let maxdmg = Module.shieldRegenData.base;
            for (let i = 0; i < Module.shieldRegenData.level.length; i++) {
                maxdmg += Module.shieldRegenData.level[i];
            }
            let indexAdjust = ((module.shieldRegen / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.shieldRegen + Module.shieldRegenData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Shield Regen Increase: ${module.shieldRegen * 100}%
            <div style="display: ${Module.shieldRegenData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Module.shieldRegenData.level[module.level] * 100}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "grayDamageDecrease" && Module.grayDamageDecreaseData) {
            let maxdmg = Module.grayDamageDecreaseData.base;
            for (let i = 0; i < Module.grayDamageDecreaseData.level.length; i++) {
                maxdmg += Module.grayDamageDecreaseData.level[i];
            }
            let indexAdjust = ((module.grayDamageDecrease / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.grayDamageDecrease + Module.grayDamageDecreaseData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Gray Damage Decrease: ${module.grayDamageDecrease * 100}%
            <div style="display: ${Module.grayDamageDecreaseData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Module.grayDamageDecreaseData.level[module.level] * 100}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "durabilityLostAmp" && Module.durabilityLostAmpData) {
            let maxdmg = Module.durabilityLostAmpData.base;
            for (let i = 0; i < Module.durabilityLostAmpData.level.length; i++) {
                maxdmg += Module.durabilityLostAmpData.level[i];
            }
            let indexAdjust = ((maxdmg / module.durabilityLostAmp) * maxwidth) / maxwidth;
            let indexAdjusted = ((maxdmg / (module.durabilityLostAmp + Module.durabilityLostAmpData.level[module.level])) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Durability Requirement: ${(module.durabilityLostAmp * 100)}%
            <div style="display: ${Math.abs(Module.durabilityLostAmpData.level[module.level]) ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            ${Module.durabilityLostAmpData.level[module.level] >= 0 ? "+" : "-"}${(Math.abs(Module.durabilityLostAmpData.level[module.level]) * 100)}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "increasedDefensePoints" && Module.increasedDefensePointsData) {
            let maxdmg = Module.increasedDefensePointsData.base;
            for (let i = 0; i < Module.increasedDefensePointsData.level.length; i++) {
                maxdmg += Module.increasedDefensePointsData.level[i];
            }
            let indexAdjust = ((module.increasedDefensePoints / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.increasedDefensePoints + Module.increasedDefensePointsData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Defense Points (@condition): ${module.increasedDefensePoints}
            <div style="display: ${Module.increasedDefensePointsData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Module.increasedDefensePointsData.level[module.level]}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "anticontrol" && Module.antiControlData) {
            let maxdmg = Module.antiControlData.base;
            for (let i = 0; i < Module.antiControlData.level.length; i++) {
                maxdmg += Module.antiControlData.level[i];
            }
            let indexAdjust = ((module.antiControl / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.antiControl + Module.antiControlData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Effect Duration Reduction: ${removeDecimals(module.antiControl * 100)}%
            <div style="display: ${Module.antiControlData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${removeDecimals(Module.antiControlData.level[module.level] * 100)}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "nuclearAmpData" && Module.nuclearAmpData) {
            let maxdmg = Module.nuclearAmpData.base;
            for (let i = 0; i < Module.nuclearAmpData.level.length; i++) {
                maxdmg += Module.nuclearAmpData.level[i];
            }
            let indexAdjust = ((module.nuclearAmp / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.nuclearAmp + Module.nuclearAmpData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Damage Increase: ${(module.nuclearAmp * 100)}%
            <div style="display: ${Module.nuclearAmpData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${(Module.nuclearAmpData.level[module.level] * 100)}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "defense amp 1" && Module.defensePointsIncreaseData) {
            let maxdmg = Module.defensePointsIncreaseData.base;
            for (let i = 0; i < Module.defensePointsIncreaseData.level.length; i++) {
                maxdmg += Module.defensePointsIncreaseData.level[i];
            }
            let indexAdjust = ((module.defensePointsIncrease / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.defensePointsIncrease + Module.defensePointsIncreaseData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Defense Points (per stack): ${module.defensePointsIncrease}
            <div style="display: ${Module.defensePointsIncreaseData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Module.defensePointsIncreaseData.level[module.level]}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "grayDamageFixRepairData" && Module.grayDamageFixRepairData) {
            let maxdmg = Module.grayDamageFixRepairData.base;
            for (let i = 0; i < Module.grayDamageFixRepairData.level.length; i++) {
                maxdmg += Module.grayDamageFixRepairData.level[i];
            }
            let indexAdjust = ((module.grayDamageFixRepair / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.grayDamageFixRepair + Module.grayDamageFixRepairData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Gray Damage Repair: ${abbreviateNumber(module.grayDamageFixRepair)}
            <div style="display: ${Module.grayDamageFixRepairData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${abbreviateNumber(Module.grayDamageFixRepairData.level[module.level])}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "titanCharge" && Module.titanChargeData) {
            let maxdmg = Module.titanChargeData.base;
            for (let i = 0; i < Module.titanChargeData.level.length; i++) {
                maxdmg += Module.titanChargeData.level[i];
            }
            let indexAdjust = ((module.titanCharge / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((module.titanCharge + Module.titanChargeData.level[module.level]) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Titan Charge: ${module.titanCharge * 100}%
            <div style="display: ${Module.titanChargeData.level[module.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Module.titanChargeData.level[module.level] * 100}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        }
        return text;
    }
    const MODULESAODJAOSIDAS = module;
    function drawModuleDisplay(modules, index, HA, shape, slot, inInventory) {
        let Weapon = modules[index];
        if (!Weapon) return;
        let newWeapon = moduleData.find(e => Weapon.name == e.name);
        let weapon = new MODULESAODJAOSIDAS(newWeapon);
        for (let i = 0; i < Weapon.level - 1; i++) {
            upgradeModule(weapon, null, null, true);
        }
        let currentIndex = index;
        document.getElementById("WEAPONdisplay").innerHTML = `
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(rgb(0, 0, 0, 0), ${tierColor(weapon)});">
        </div>
        <div id="weaponImage" style="position: absolute; top: ${window.innerHeight / 2 - 187.5}px; left: ${window.innerWidth / 2 - 187.5}px; height: 375px; width: 375px;">
        </div>
        <div style="display: ${Weapon.amount == "main" ? "none" : "block"};position: absolute; text-align: center; top: ${window.innerHeight / 2 + 187.5}px; left: ${window.innerWidth / 2 - 187.5}px; height: 50px; width: 375px;">
        In Stock: ${!inInventory ? player.modules.filter(e => e.name == Weapon.name).length : Weapon.amount}
        </div>
        <div style="position: absolute; top: ${window.innerHeight / 2 - 250}px; left: ${window.innerWidth / 2 - 522.5}px; width: 325px; height: 500px; background-color: rgb(0, 0, 0, .2); border: solid; border-color: #fff; border-radius: 6px; overflow-y: scroll;">
        <div style="position: absolute; top: 7px; left: 5px;">
        <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(weapon)};">
        ${weapon.level}
        </div>
        <div style="position: absolute; top: 2px; width: 260px; left: 45px; color: #fff; font-size: 24px;">
        <strong>
        ${weapon.name}
        </strong>
        </div>
        </div>
        <div style="position: absolute; top: 45px; left: 0px;">
        <hr style="position: absolute; top: 0px; left: 0px; color: #fff; width: 325px;">
        <div style="position: absolute; top: 15px; left: 5px; width: 320px;">
        ${weapon.desc}<br>
        <hr style="position: absolute; left: -5px; color: #fff; width: 325px;">
        <br>
        ${weapon.dmgIncrease ? "Damage Increase: " + removeDecimals(weapon.dmgIncrease * 100) + "%<br>" : ""}
        ${weapon.healthIncrease ? "Durability Increase: " + removeDecimals(weapon.healthIncrease * 1000) / 10 + "%<br>" : ""}
        ${weapon.selfFixRepair ? "Repair Power: " + abbreviateNumber(weapon.selfFixRepair) + "/SEC<br>" : ""}
        ${weapon.grayDamageFixRepair ? `Gray Damage Repair: ${abbreviateNumber(weapon.grayDamageFixRepair)}<br>` : ""}
        ${weapon.immunePercent ? "Immunity Threshold: " + (weapon.immunePercent * 100) + "%<br>" : ""}
        ${weapon.lastingTime ? "Effect Duration: " + (weapon.lastingTime / 1000) + " sec<br>" : ""}
        ${weapon.shieldHealth ? "Shield Durability Increase: " + removeDecimals(weapon.shieldHealth * 100) + "%<br>" : ""}
        ${weapon.shieldRegen ? "Shield Regen Decrease: " + removeDecimals(weapon.shieldRegen * 100) + "%<br>" : ""}
        ${weapon.grayDamageDecrease ? "Gray Damage Decrease: " + removeDecimals(weapon.grayDamageDecrease * 100) + "%<br>" : ""}
        ${weapon.durabilityLostAmp ? "Durability Requirement: " + (weapon.durabilityLostAmp * 100) + "%<br>" : ""}
        ${weapon.increasedDefensePoints ? "Defense Points (@max stacks): " + (weapon.increasedDefensePoints) + "<br>" : ""}
        ${weapon.antiControl ? `Effect Duration Reduction: ${weapon.antiControl * 100}%<br>` : ""}
        ${weapon.nuclearAmp ? `Damage Bonus: ${weapon.nuclearAmp * 100}%<br>` : ""}
        ${weapon.defensePointsIncrease ? `Defense Points (per stack): ${weapon.defensePointsIncrease}<br>` : ""}
        ${weapon.titanCharge ? `Titan Charge: ${weapon.titanCharge * 100}%` : ""}
        <p></p>
        </div>
        </div>
        </div>
        <div id="Unequip" style="display: ${Weapon.amount == "main" ? "block" : "none"}; position: absolute; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 187.5}px; top: ${window.innerHeight / 2 + 35}px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #f00;">
        UNEQUIP
        </div>
        <div id="Equip" style="display: ${Weapon.amount == "main" ? "none" : inInventory ? "block" : "none"}; position: absolute; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 187.5}px; top: ${window.innerHeight / 2 + 35}px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #0f0;">
        EQUIP
        </div>
        <div id="Upgrade" style="position: absolute; display: ${!inInventory ? "none" : "block"}; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 187.5}px; top: ${window.innerHeight / 2 - 25}px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #0f0;">
        UPGRADE
        </div>
        <div id="upgradeMenu" style="position: absolute; color: #fff; display: none; top: 12.5%; left: 12.5%; width: 75%; height: 75%; background-color: rgb(0, 0, 0, .7);">
        </div>
        <div style="position: absolute; bottom: 100px; left: 12.5%; width: 75%; height: 6px; background-color: #fff; border-radius: 4px; overflow: hidden;">
        <div style="position: absolute; top: 0px; left: ${(1 / modules.length) * 100 * currentIndex}%; width: ${(1 / modules.length) * 100}%; height: 100%; background-color: #00dbcd;">
        </div>
        </div>
        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        <div id="buyModule" style="position: absolute; display: ${!inInventory ? "block" : "none"}; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 187.5}px; top: ${window.innerHeight / 2 - 25}px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #0f0;">
        ${unlockedAtTier[weapon.tier] > player.profile.level ? "LOCKED" : "BUY"}
        </div>
        <div id="buyMenu" style="position: absolute; display: none; color: #fff; top: ${(window.innerHeight / 2) - (225 / 2)}px; left: ${(window.innerWidth / 2) - (425 / 2)}px; width: 425px; height: 225px; background-color: rgb(0, 0, 0, .7);">
        </div>
        `;
        let weaponImg = getModuleIcon(weapon, true);
        weaponImg.style = "width: 100%; height: 100%;";
        document.getElementById("weaponImage").appendChild(weaponImg);
        document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
        if (modules[index].dontSell) document.getElementById("buyModule").style.display = "none";
        document.getElementById("Unequip").onclick = function () {
            let weapon = player.modules.find(e => shape.sid == e.owner && e.slot == slot);
            weapon.slot = null;
            weapon.owner = null;
            if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                document.getElementById("slot" + shape.slot).click();
                document.getElementById("switchModule").click();
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            } else {
                document.getElementById("hangerUI").style.display = "block";
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
        }
        document.getElementById("Equip").onclick = function () {
            let weapon = player.modules.find(e => e.name == Weapon.name && e.owner == null && e.level == Weapon.level);
            let oldWeapon = player.modules.find(e => shape.sid == e.owner && e.slot == slot);
            if (oldWeapon) {
                oldWeapon.owner = null;
                oldWeapon.slot = null;
            }
            weapon.owner = shape.sid;
            weapon.slot = slot;
            if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                document.getElementById("slot" + shape.slot).click();
                document.getElementById("switchModule").click();
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            } else {
                document.getElementById("hangerUI").style.display = "block";
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
        }
        document.getElementById("Upgrade").onclick = function () {
            document.body.appendChild(document.getElementById("moneyDisplay"));
            let weapon = player.modules.find(e => e.name == Weapon.name && (Weapon.amount == "main" ? shape.sid == e.owner && e.slot == slot : !e.owner) && e.level == Weapon.level);
            if (!weapon) return;
            let titanUpgradeCost = (shape.level * (120 * ((shape.tier + 1) * .25)) + Math.ceil(shape.level / 5) * 1200) * (shape.tier + 1) * .5;
            let adjustwidth = window.innerWidth * .75;
            document.getElementById("upgradeMenu").style.display = "block";
            document.getElementById("upgradeMenu").innerHTML = `
            <div style="width: 100%; text-align: center; margin-top: 5px; font-size: 30px;">
            Lvl ${weapon.level} ${weapon.name}
            </div>
            <hr>
            <div style="position: absolute; left: 300px; top: 65px;">
            ${enterBarForModule("healthIncrease", weapon)}
            ${enterBarForModule("selfFixRepair", weapon)}
            ${enterBarForModule("grayDamageFixRepairData", weapon)}
            ${enterBarForModule("dmgIncrease", weapon)}
            ${enterBarForModule("immunity", weapon)}
            ${enterBarForModule("lastingTime", weapon)}
            ${enterBarForModule("shieldHealth", weapon)}
            ${enterBarForModule("shieldRegen", weapon)}
            ${enterBarForModule("grayDamageDecrease", weapon)}
            ${enterBarForModule("durabilityLostAmp", weapon)}
            ${enterBarForModule("increasedDefensePoints", weapon)}
            ${enterBarForModule("anticontrol", weapon)}
            ${enterBarForModule("nuclearAmpData", weapon)}
            ${enterBarForModule("defense amp 1", weapon)}
            ${enterBarForModule("titanCharge", weapon)}
            </div>
            <div id="leaveUpgrade" style="position: absolute; cursor: pointer; right: 10px; top: 10px;">
            X
            </div>
            <div id="UPGRADE" style="position: absolute; width: 200px; height: 80px; cursor: pointer; left: ${adjustwidth / 2 - 100}px; bottom: 10px; background-color: ${weapon.level < 25 && weapon.titan ? "#00ff00" : sliverUpgradesByTier[weapon.tier].modules[weapon.level] ? "#00ff00" : "#808080"};">
            <div style="width: 100%; text-align: center; font-size: ${weapon.level < 25 && weapon.titan ? "24" : sliverUpgradesByTier[weapon.tier].modules[weapon.level] ? "24" : "40"}px; margin-top: ${weapon.level < 25 && weapon.titan ? "5" : sliverUpgradesByTier[weapon.tier].modules[weapon.level] ? "5" : "10"}px;">${weapon.level < 25 && weapon.titan ? "UPGRADE" : sliverUpgradesByTier[weapon.tier].modules[weapon.level] ? "UPGRADE" : "MAXED"}</div>
            <div style="display: ${weapon.level < 25 && weapon.titan ? "block" : sliverUpgradesByTier[weapon.tier].modules[weapon.level] ? "block" : "none"}; width: 100%; text-align: center; font-size: 12px;">${weapon.level < 25 && weapon.titan ? `${abbreviateNumber(titanUpgradeCost)} WSP` : `${abbreviateNumber(sliverUpgradesByTier[weapon.tier].modules[weapon.level])} Sliver`}</div>
            </div>
            `;
            let sprite = getModuleIcon(weapon, true);
            sprite.style = "width: 280px; height: 280px;";
            document.getElementById("upgradeMenu").appendChild(sprite);
            document.getElementById("leaveUpgrade").onclick = function () {
                document.getElementById("upgradeMenu").style.display = "none";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
            document.getElementById("UPGRADE").onclick = function () {
                if (weapon.titan) {
                    if (weapon.level < 25 && player.workshopPoints - titanUpgradeCost >= 0) {
                        updateMoneyDisplay("workshopPoints", -titanUpgradeCost);
                        upgradeModule(weapon, currentIndex, modules, false, false, shape, slot, inInventory);
                    }
                } else if (sliverUpgradesByTier[weapon.tier].modules[weapon.level] && player.sliver - sliverUpgradesByTier[weapon.tier].modules[weapon.level] >= 0) {
                    updateMoneyDisplay("sliver", -sliverUpgradesByTier[weapon.tier].modules[weapon.level]);
                    upgradeModule(weapon, currentIndex, modules, false, false, shape, slot, inInventory);
                }
            }
        }
        document.getElementById("backButton").onclick = function () {
            if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                document.getElementById("slot" + shape.slot).click();
                document.getElementById("switchModule").click();
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            } else {
                document.getElementById("hangerUI").style.display = "block";
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
        }
        document.getElementById("buyModule").onclick = function () {
            if (unlockedAtTier[weapon.tier] > player.profile.level) return;
            document.body.appendChild(document.getElementById("moneyDisplay"));
            document.getElementById("buyMenu").style.display = "block";
            document.getElementById("storeButton").style.display = "none";
            document.getElementById("inventoryButton").style.display = "none";
            let num = 60;
            let theHA = modules[currentIndex];
            document.getElementById("buyMenu").innerHTML = `
            <div style="width: 100%; text-align: center; font-size: 30px;">
            Confirm Purchase
            </div>
            <hr>
            <div id="lo____l" style="position: absolute; cursor: pointer; top: 5px; right: 10px;">
            x
            </div>

            <div style="position: absolute; top: ${num}px; left: ${425 / 2 - 62.5}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
            <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('${agSource}');">
            </div>
            <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
            ${abbreviateNumber(theHA.cost.sliver)}
            </div>
            </div>
    
            <div style="position: absolute; top: ${num}px; left: ${425 / 2 - 200}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
            <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('${auSource}');">
            </div>
            <div style="position: absolute; top: 6.75px; left: 40px;  color: #fff;">
            ${abbreviateNumber(theHA.cost.gold)}
            </div>
            </div>
    
            <div style="position: absolute; top: ${num}px; left: ${425 / 2 + 75}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
            <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('./images/icons/workshop.png');">
            </div>
            <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
            ${abbreviateNumber(theHA.cost.workshopPoints || 0)}
            </div>
            </div>

            <div id="confirm" style="position: absolute; cursor: pointer; font-size: 24px; text-align: center; bottom: 10px; left: ${425 / 2 - 75}px; width: 150px; border-radius: 6px; height: 40px; background-color: #0f0;">
            Confirm
            </div>
            `;
            document.getElementById("confirm").onclick = function () {
                let theThing = modules[currentIndex];
                if (player.sliver - theThing.cost.sliver >= 0 && player.gold - theThing.cost.gold >= 0) {
                    if ((!theThing.cost.workshopPoints ? true : player.workshopPoints - theThing.cost.workshopPoints >= 0)) {
                        updateMoneyDisplay("sliver", -theThing.cost.sliver);
                        updateMoneyDisplay("gold", -theThing.cost.gold);
                        updateMoneyDisplay("workshopPoints", -(theThing.cost.workshopPoints || 0));
                        let oldWeapon = player.modules.find(e => e.owner == shape.sid && e.slot == slot);
                        if (oldWeapon) {
                            oldWeapon.slot = null;
                            oldWeapon.owner = null;
                        }
                        player.modules.push(new MODULESAODJAOSIDAS(theThing, shape.sid, slot));
                        if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                            document.getElementById("slot" + shape.slot).click();
                            document.getElementById("switchModule").click();
                            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                        } else {
                            document.getElementById("hangerUI").style.display = "block";
                            document.getElementById("sideDisplay").innerHTML = "";
                            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                        }
                    }
                }
            }
            document.getElementById("lo____l").onclick = function () {
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                document.getElementById("buyMenu").style.display = "none";
                document.getElementById("storeButton").style.display = "block";
                document.getElementById("inventoryButton").style.display = "block";
            }
        }
        if (HA) {
            document.getElementById("Upgrade").click();
        }
    }
    function upgradeModule(module, currentIndex, modules, noEz, isBOT, shape, slot, inInventory) {
        let Module = moduleData.find(item => item.name == module.name);
        if (Module.healthIncreaseData) {
            let healthIncrease = Module.healthIncreaseData.level[module.level];
            module.healthIncrease += healthIncrease;
            module.healthIncrease *= 1000;
            module.healthIncrease = Math.round(module.healthIncrease);
            module.healthIncrease /= 1000;
        }
        if (Module.defensePointsIncreaseData) {
            let healthIncrease = Module.defensePointsIncreaseData.level[module.level];
            if (module.defensePointsIncrease == .7 && healthIncrease == .1) {
                module.defensePointsIncrease = .8;
            } else {
                module.defensePointsIncrease += healthIncrease;
                module.defensePointsIncrease = Math.round(module.defensePointsIncrease * 1e3) / 1e3;
            }
        }
        if (Module.titanChargeData) {
            let healthIncrease = Module.titanChargeData.level[module.level];
            module.titanCharge += healthIncrease;
            module.titanCharge = Math.round(module.titanCharge * 1e3) / 1e3;
        }
        if (Module.selfFixRepairData) {
            let healthIncrease = Module.selfFixRepairData.level[module.level];
            module.selfFixRepair += healthIncrease;
        }
        if (Module.grayDamageFixRepairData) {
            let healthIncrease = Module.grayDamageFixRepairData.level[module.level];
            module.grayDamageFixRepair += healthIncrease;
        }
        if (Module.nuclearAmpData) {
            let healthIncrease = Module.nuclearAmpData.level[module.level];
            module.nuclearAmp += healthIncrease;
            module.nuclearAmp *= 1000;
            module.nuclearAmp = Math.round(module.nuclearAmp);
            module.nuclearAmp /= 1000;
        }
        if (Module.dmgIncreaseData) {
            let healthIncrease = Module.dmgIncreaseData.level[module.level];
            module.dmgIncrease += healthIncrease;
            module.dmgIncrease *= 1e3;
            module.dmgIncrease = Math.round(module.dmgIncrease);
            module.dmgIncrease /= 1e3;
        }
        if (Module.immunePercentData) {
            let healthIncrease = Module.immunePercentData.level[module.level];
            module.immunePercent += healthIncrease;
        }
        if (Module.lastingTimeData) {
            let healthIncrease = Module.lastingTimeData.level[module.level];
            module.lastingTime += healthIncrease;
        }
        if (Module.shieldHealthData) {
            let healthIncrease = Module.shieldHealthData.level[module.level];
            module.shieldHealth += healthIncrease;
        }
        if (Module.shieldRegenData) {
            let healthIncrease = Module.shieldRegenData.level[module.level];
            module.shieldRegen += healthIncrease;
        }
        if (Module.grayDamageDecreaseData) {
            let healthIncrease = Module.grayDamageDecreaseData.level[module.level];
            module.grayDamageDecrease += healthIncrease;
        }
        if (Module.durabilityLostAmpData) {
            let healthIncrease = Module.durabilityLostAmpData.level[module.level];
            module.durabilityLostAmp += healthIncrease;
            module.durabilityLostAmp = Math.round(module.durabilityLostAmp * 1e3) / 1e3;
        }
        if (Module.increasedDefensePointsData) {
            let healthIncrease = Module.increasedDefensePointsData.level[module.level];
            module.increasedDefensePoints += healthIncrease;
        }
        if (Module.antiControlData) {
            let healthIncrease = Module.antiControlData.level[module.level];
            module.antiControl += healthIncrease;
            module.antiControl *= 100;
            module.antiControl = Math.round(module.antiControl);
            module.antiControl /= 100;
        }
        module.level++;
        if (!noEz) {
            modules[currentIndex].level++;
            customizeModule(module, shape, slot);
            if (!inInventory) {
                document.getElementById("storeButton").click();
            }
            for (let i = 0; i < currentIndex; i++) {
                document.getElementById("goToNext").click();
            }
            document.getElementById("Upgrade").click();
            //drawModuleDisplay(modules, currentIndex, true, shape, slot, inInventory);
        }
        if (!noEz) updateSlots();
        if (!noEz) saveGameData();
    }
    function customizeModule(module, shape, slot) {
        if (true) {
            let filteredWeapons = [];
            let f = player.modules.filter(e => e.owner == null && e.titan == shape.titan).sort((a, b) => b.level - a.level).sort((a, b) => b.tier - a.tier);
            for (let i = 0; i < f.length; i++) {
                let item = f[i];
                if ((item.owner == shape.sid && item.slot == slot) || item.isSold) {
                    continue;
                }
                if (filteredWeapons.find(e => e.name == item.name && e.level == item.level)) {
                    let index = filteredWeapons.findIndex(e => e.name == item.name && e.level == item.level);
                    filteredWeapons[index].amount++;
                } else {
                    filteredWeapons.push({
                        name: item.name,
                        level: item.level,
                        amount: 1
                    });
                }
            }
            let mainModule = player.modules.find(e => e.owner == shape.sid && e.slot == slot);
            if (mainModule) {
                filteredWeapons.unshift({
                    name: mainModule.name,
                    level: mainModule.level,
                    amount: "main"
                });
            }
            let currentIndex = 0;
            document.getElementById("sideDisplay").innerHTML = `
            <div id="WEAPONdisplay" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;">
            </div>
            <div id="goToPre" style="display: none; position: absolute; cursor: pointer; left: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
            <div id="goToPreCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
            <span class="material-symbols-outlined" style="font-size: 40px;">
            navigate_before
            </span>
            </div>
            </div>
            <div id="goToNext" style="position: absolute; transition: .25s; cursor: pointer; right: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
            <div id="goToNextCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
            <span class="material-symbols-outlined" style="font-size: 40px;">
            navigate_next
            </span>
            </div>
            </div>
            <div id="inventoryButton" style="position: absolute; text-align: center; font-size: 25px; color: #000; left: ${window.innerWidth / 2 - 165}px; top: 30px; border-radius: 6px; height: 42.5px; padding-top: 7.5px; width: 150px; background-color: rgb(255, 255, 255, .6);">
            INVENTORY
            </div>
            <div id="storeButton" style="position: absolute; text-align: center; font-size: 35px; cursor: pointer; color: #fff; left: ${window.innerWidth / 2 + 20}px; top: 30px; border-radius: 6px; height: 50px; width: 150px; background-color: rgb(0, 0, 0, .4);">
            STORE
            </div>
            `;
            let inInventory = true;
            let diiiisbled = false;
            document.getElementById("inventoryButton").onclick = function () {
                if (!diiiisbled) {
                    this.style.cursor = null;
                    this.style.color = "#000";
                    this.style.backgroundColor = "rgb(255, 255, 255, .6)";
                    document.getElementById("goToPre").style.display = "none";
                    document.getElementById("goToNext").style.display = "block";
                    document.getElementById("storeButton").style.cursor = "pointer";
                    document.getElementById("storeButton").style.color = "#fff";
                    document.getElementById("storeButton").style.backgroundColor = "rgb(0, 0, 0, .4)";
                    currentIndex = 0;
                    inInventory = true;
                    drawModuleDisplay(inInventory ? filteredWeapons : moduleData.filter(e => e.titan == shape.titan).sort((a, b) => a.tier - b.tier), currentIndex, false, shape, slot, inInventory);
                }
            };
            document.getElementById("storeButton").onclick = function () {
                this.style.cursor = null;
                this.style.color = "#000";
                this.style.backgroundColor = "rgb(255, 255, 255, .6)";
                document.getElementById("goToPre").style.display = "none";
                document.getElementById("goToNext").style.display = "block";
                document.getElementById("inventoryButton").style.cursor = "pointer";
                document.getElementById("inventoryButton").style.color = "#fff";
                document.getElementById("inventoryButton").style.backgroundColor = "rgb(0, 0, 0, .4)";
                currentIndex = 0;
                inInventory = false;
                drawModuleDisplay(inInventory ? filteredWeapons : moduleData.filter(e => e.titan == shape.titan).sort((a, b) => a.tier - b.tier), currentIndex, false, shape, slot, inInventory);
            };
            if (filteredWeapons.length == 0) {
                document.getElementById("storeButton").click();
                document.getElementById("inventoryButton").style.cursor = null;
                diiiisbled = true;
            }
            drawModuleDisplay(filteredWeapons, 0, false, shape, slot, inInventory);
            if (!(inInventory ? filteredWeapons[currentIndex - 1] : moduleData.filter(e => e.titan == shape.titan)[currentIndex - 1])) {
                document.getElementById("goToPre").style.display = "none";
            }
            document.getElementById("goToPre").onclick = function () {
                currentIndex--;
                drawModuleDisplay(inInventory ? filteredWeapons : moduleData.filter(e => e.titan == shape.titan).sort((a, b) => a.tier - b.tier), currentIndex, false, shape, slot, inInventory);
                if (!(inInventory ? filteredWeapons[currentIndex - 1] : moduleData.filter(e => e.titan == shape.titan)[currentIndex - 1])) {
                    document.getElementById("goToPre").style.display = "none";
                } else {
                    document.getElementById("goToPre").style.display = "block";
                }
                if (!(inInventory ? filteredWeapons[currentIndex + 1] : moduleData.filter(e => e.titan == shape.titan)[currentIndex + 1])) {
                    document.getElementById("goToNext").style.display = "none";
                } else {
                    document.getElementById("goToNext").style.display = "block";
                }
            }
            if (!(inInventory ? filteredWeapons[currentIndex + 1] : moduleData.filter(e => e.titan == shape.titan)[currentIndex + 1])) {
                document.getElementById("goToNext").style.display = "none";
            }
            document.getElementById("goToNext").onclick = function () {
                currentIndex++;
                drawModuleDisplay(inInventory ? filteredWeapons : moduleData.filter(e => e.titan == shape.titan).sort((a, b) => a.tier - b.tier), currentIndex, false, shape, slot, inInventory);
                if (!(inInventory ? filteredWeapons[currentIndex + 1] : moduleData.filter(e => e.titan == shape.titan)[currentIndex + 1])) {
                    document.getElementById("goToNext").style.display = "none";
                } else {
                    document.getElementById("goToNext").style.display = "block";
                }
                if (!(inInventory ? filteredWeapons[currentIndex - 1] : moduleData.filter(e => e.titan == shape.titan)[currentIndex - 1])) {
                    document.getElementById("goToPre").style.display = "none";
                } else {
                    document.getElementById("goToPre").style.display = "block";
                }
            }
            document.getElementById("goToNext").onmouseover = function () {
                this.style.backgroundColor = "rgb(255, 255, 255, .45)";
                document.getElementById("goToNextCon").style.color = "#000";
            }
            document.getElementById("goToNext").onmouseout = function () {
                this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
                document.getElementById("goToNextCon").style.color = "#fff";
            }
            document.getElementById("goToPre").onmouseover = function () {
                this.style.backgroundColor = "rgb(255, 255, 255, .45)";
                document.getElementById("goToPreCon").style.color = "#000";
            }
            document.getElementById("goToPre").onmouseout = function () {
                this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
                document.getElementById("goToPreCon").style.color = "#fff";
            }
        }
    }
    function drawActiveModuleDisplay(module, index, shape) {
        document.getElementById("WEAPONdisplay").innerHTML = `
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(rgb(0, 0, 0, 0), ${tierColor(module)});">
        </div>
        <div id="weaponImage" style="position: absolute; top: ${window.innerHeight / 2 - 187.5}px; left: ${window.innerWidth / 2 - 187.5}px; height: 375px; width: 375px;">
        </div>
        <div style="position: absolute; text-align: center; top: ${window.innerHeight / 2 + 187.5}px; left: ${window.innerWidth / 2 - 187.5}px; height: 50px; width: 375px;">
        <div style="position: absolute; top: 5px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('./images/icons/workshop.png');"></div>
        <div style="position: absolute; font-size: 40px; top: 0px; width: 100%; text-align: center;">
        ${abbreviateNumber(module.cost)}
        </div>
        </div>
        <div style="position: absolute; top: ${window.innerHeight / 2 - 250}px; left: ${window.innerWidth / 2 - 522.5}px; width: 325px; height: 500px; background-color: rgb(0, 0, 0, .2); border: solid; border-color: #fff; border-radius: 6px; overflow-y: scroll;">
        <div style="position: absolute; top: 7px; left: 5px;">
        <div style="position: absolute; top: 2px; width: 260px; left: 5px; color: #fff; font-size: 24px;">
        <strong>
        ${module.name}
        </strong>
        </div>
        </div>
        <div style="position: absolute; top: 45px; left: 0px;">
        <hr style="position: absolute; top: 0px; left: 0px; color: #fff; width: 325px;">
        <div style="position: absolute; top: 15px; left: 5px; width: 320px;">
        ${module.desc}<br>
        <hr style="position: absolute; left: -5px; color: #fff; width: 325px;">
        <br>
        ${module.repairUnitPower ? `
        Repair Power: ${module.repairUnitPower.type == "percent" ? module.repairUnitPower.power * 100 + "%" : abbreviateNumber(module.repairUnitPower.power)}<br>
        Rate of Repair: ${module.repairUnitPower.rate / 1000} second(s)<br>
        ` : ""}
        ${module.instantFixPercent ? `Instant Repair: ${module.instantFixPercent * 100}%<br>` : ""}
        ${module.healthMulti ? `Health Boost: ${module.healthMulti * 100}%<br>` : ""}
        ${module.dmgIncrease ? `Damage Increase: ${Math.round(module.dmgIncrease * 1e3) / 10}%<br>` : ""}
        ${module.stealthTime ? `Stealth Duration: ${module.stealthTime / 1e3} second(s)<br>` : ""}
        ${module.defenseIncrease ? `Defense Points Increase: ${module.defenseIncrease}<br>` : ""}
        ${module.lastTime ? `Duration: ${module.lastTime / 1000} second(s)<br>` : ""}
        Reload: ${module.reload / 1000} second(s)<br>
        <p></p>
        </div>
        </div>
        </div>
        <div id="Equip" style="display: ${index > 0 ? "block" : "none"}; position: absolute; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 187.5}px; top: ${window.innerHeight / 2 - 25}px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #0f0;">
        USE
        </div>
        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        `;
        let weaponImg = getWeaponIcon(module, true);
        weaponImg.style = "width: 100%; height: 100%;";
        document.getElementById("weaponImage").appendChild(weaponImg);
        document.getElementById("Equip").onclick = function () {
            shape.activeModuleIndex = activeModuleData.findIndex(e => e.name == module.name);
            if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                document.getElementById("slot" + shape.slot).click();
                document.getElementById("switchModule").click();
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            } else {
                document.getElementById("hangerUI").style.display = "block";
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
            saveGameData();
        }
        document.getElementById("backButton").onclick = function () {
            if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                document.getElementById("slot" + shape.slot).click();
                document.getElementById("switchModule").click();
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            } else {
                document.getElementById("hangerUI").style.display = "block";
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
        }
    }
    function customizeActiveModule(module, shape) {
        let filtered = activeModuleData.filter(e => e != module).sort((a, b) => a.tier - b.tier);
        filtered.unshift(module);
        let currentIndex = 0;
        document.getElementById("sideDisplay").innerHTML = `
        <div id="WEAPONdisplay" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;">
        </div>
        <div id="goToPre" style="display: none; position: absolute; cursor: pointer; left: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToPreCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_before
        </span>
        </div>
        </div>
        <div id="goToNext" style="position: absolute; transition: .25s; cursor: pointer; right: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToNextCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_next
        </span>
        </div>
        </div>
        `;
        drawActiveModuleDisplay(filtered[currentIndex], currentIndex, shape);
        if (!filtered[currentIndex - 1]) {
            document.getElementById("goToPre").style.display = "none";
        }
        document.getElementById("goToPre").onclick = function () {
            currentIndex--;
            drawActiveModuleDisplay(filtered[currentIndex], currentIndex, shape);
            if (!filtered[currentIndex - 1]) {
                document.getElementById("goToPre").style.display = "none";
            } else {
                document.getElementById("goToPre").style.display = "block";
            }
            if (!filtered[currentIndex + 1]) {
                document.getElementById("goToNext").style.display = "none";
            } else {
                document.getElementById("goToNext").style.display = "block";
            }
        }
        if (!filtered[currentIndex + 1]) {
            document.getElementById("goToNext").style.display = "none";
        }
        document.getElementById("goToNext").onclick = function () {
            currentIndex++;
            drawActiveModuleDisplay(filtered[currentIndex], currentIndex, shape);
            if (!filtered[currentIndex + 1]) {
                document.getElementById("goToNext").style.display = "none";
            } else {
                document.getElementById("goToNext").style.display = "block";
            }
            if (!filtered[currentIndex - 1]) {
                document.getElementById("goToPre").style.display = "none";
            } else {
                document.getElementById("goToPre").style.display = "block";
            }
        }
        document.getElementById("goToNext").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToNextCon").style.color = "#000";
        }
        document.getElementById("goToNext").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToNextCon").style.color = "#fff";
        }
        document.getElementById("goToPre").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToPreCon").style.color = "#000";
        }
        document.getElementById("goToPre").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToPreCon").style.color = "#fff";
        }
    }
    document.getElementById("goToBattle").onclick = function () {
        saveGameData();
        document.getElementById("money3Display").style.display = "block";
        document.body.append(document.getElementById("money3Display"));
        document.getElementById("hangerUI").append(document.getElementById("moneyDisplay"));
        document.getElementById("hangerUI").style.display = "none";
        document.getElementById("sideDisplay").style.display = "none";
        document.getElementById("goBackToHanger").style.display = "block";
        document.getElementById("gameModesDisplay").style.display = "block";
        this.style.display = "none";
    }
    var players = [];
    var mapInfo = {
        x: 0,
        y: 0
    }
    function updateChooseSlots() {
        let player = players.find(e => e.name == "player");
        if (!player) return;
        document.getElementById("chooseSlot").style.width = (window.innerWidth / 8) + "px";
        document.getElementById("chooseSlot").innerHTML = "";
        let width = window.innerWidth / 8;
        for (let i = 0; i < 9; i++) {
            let robot = player.robots[i];
            if (robot) {
                document.getElementById("chooseSlot").innerHTML += `
                <div id="useSlot${i}" style="${robot.USED ? "" : "cursor: pointer;"} ${i == 8 && document.getElementById("chooseSlot").style.bottom == "-200px" ? "display: block;" : ""} ${i == 8 ? player.titanCharge >= 1 ? "" : "pointer-events: none;" : ""} ${i == 8 ? "border-radius: 4px;" : ""} position: absolute; left: ${i == 8 ? (window.innerWidth / 2) - width : (width * i)}px; bottom: ${i == 8 ? 300 : 0}px; width: ${(i == 8 ? width * 2 : width)}px; height: ${(i == 8 ? width * 2 : width)}px; background-color: ${i == 8 && player.titanCharge < 1 ? "rgb(255, 0, 0, .4)" : i % 2 ? "rgb(0, 0, 0, 0.2)" : "rgb(255, 255, 255, 0.2)"};">
                <div style="width: 100%; text-align: center; color: ${robot.level == 13 ? "#00f" : "#000"}">
                ${robot.name}<br>
                ${i == 8 ? player.titanCharge >= 1 ? "" : `
                <span style="color: #f00">
                Locked
                </span>
                ` : ""}
                </div>
                </div>
                `;
            } else {
                document.getElementById("chooseSlot").innerHTML += `
                <div style="position: absolute; left: ${width * i}px; bottom: 0px; width: ${width}px; height: ${width}px; background-color: ${i % 2 ? "rgb(0, 0, 0, 0.2)" : "rgb(255, 255, 255, 0.2)"};">
                </div>
                `;
            }
        }
        for (let i = 0; i < 9; i++) {
            let robot = player.robots[i];
            if (robot) {
                if (robot.USED) {
                    document.getElementById(`useSlot${i}`).innerHTML += `
                    <div style="z-index: 2; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-size: 100% 100%; background-image: url('./images/icons/cant_use_shape.png');">
                    </div>
                    `;
                }
                document.getElementById(`useSlot${i}`).onclick = function () {
                    if (!robot.USED) {
                        maxScreen = {
                            x: 1980 * robot.fieldOfViewMulti,
                            y: 1080 * robot.fieldOfViewMulti
                        };
                        if (players[0].oldIndex > 0 && !players[0].robots[players[0].oldIndex].dead) {
                            addLogger({ name: "Game" }, null, player);
                        }
                        players[0].oldIndex = i;
                        players[0].robotIndex = i;
                        robot.USED = true;
                        if (document.getElementById("useSlot8")) {
                            document.getElementById("useSlot8").style.display = "none";
                        }
                        document.getElementById("abilityCharges").innerHTML = "";
                        document.getElementById("mapName").style.display = "none";
                        document.getElementById("chooseSlot").style.bottom = `${-width}px`;
                        resize();
                    }
                }
                if (!robot.USED) {
                    let dosas = robot.weapons.sort((a, b) => a.slot - b.slot);
                    for (let t = 0; t < dosas.length; t++) {
                        let weaponImg = getWeaponIcon(dosas[t], true);
                        weaponImg.style = `pointer-events: none; z-index: 44; position: absolute; bottom: ${t >= 4 ? 45 : 0}px; left: ${45 * (t >= 4 ? t - 4 : t)}px; width: ${width / 4}px; height: ${width / 4}px;`;
                        document.getElementById(`useSlot${i}`).appendChild(weaponImg);
                    }
                }
                if (robot.specialOf) {
                    document.getElementById(`useSlot${i}`).style.backgroundSize = `${width}px ${width}px`;
                    document.getElementById(`useSlot${i}`).style.backgroundImage = `url('${robot.specialOf}')`;
                } else {
                    let robotImg = getShapeSprite(robot, true);
                    robotImg.style = "pointer-events: none; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;";
                    document.getElementById(`useSlot${i}`).appendChild(robotImg);
                }
            }
        }
    }
    var keysPressed = Array(100).fill(0);
    var LMAOASODPKASPODK = [];
    document.addEventListener("keydown", (e) => {
        keysPressed[e.keyCode] = 1;
        if (e.keyCode == 27 && !(player.gameMode >= 0)) {
            document.getElementById("money3Display").style.display = "none";
            document.getElementById("hangerUI").append(document.getElementById("moneyDisplay"));
            document.getElementById("hangerUI").append(document.getElementById("money3Display"));
            document.getElementById("rewardAnimation").style.overflow = "hidden";
            document.getElementById("rewardAnimation").style.pointerEvents = "none";
            document.getElementById("rewardAnimation").style.display = "none";
            document.getElementById("sideDisplay").innerHTML = "";
            document.getElementById("hangerUI").style.display = "block";
            document.getElementById("sideDisplay").style.display = "block";
            document.getElementById("money2Display").style.display = "none";
            document.getElementById("goBackToHanger").click();
            if (document.getElementById("pilotDisplay")) {
                document.getElementById("pilotDisplay").remove();
            }
            if (document.getElementById("mothershipDisplayyy")) {
                document.getElementById("mothershipDisplayyy").remove();
            }
            updateSlots();
        }
        if (e.key == "K" && player.gameMode >= 0) {
            if (document.getElementById("chooseSlot").style.bottom == "0px") {
                document.getElementById("chooseSlot").style.bottom = "-200px";
                updateChooseSlots();
                if (document.getElementById("useSlot8")) {
                    document.getElementById("useSlot8").style.display = "none";
                }
            } else {
                document.getElementById("chooseSlot").style.bottom = `0px`;
                updateChooseSlots();
            }
        }
        if (parseInt(e.key) <= 8 && parseInt(e.key) >= 1 && !document.getElementById("pilotDisplay")) {
            if (window.isDev) {
                player.league = 10e3;
                addOperationXP(100e3);
                updateMoneyDisplay("sliver", 1e12);
                updateMoneyDisplay("gold", 10e6);
                updateMoneyDisplay("keys", 100e3);
                updateMoneyDisplay("workshopPoints", 500e6);
                updateMoneyDisplay("token 1", 50e3);
                updateMoneyDisplay("token 2", 50e3);
                updateMoneyDisplay("token 3", 50e3);
                updateMoneyDisplay("player_xp", 10000);
            }
            if (document.getElementById("slot" + (parseInt(e.key) - 1))) {
                document.getElementById("slot" + (parseInt(e.key) - 1)).click();
            }
        }
        if (e.key == "ArrowLeft") {
            if (document.getElementById("goToPre") && (!document.getElementById("goToPre").style.display || document.getElementById("goToPre").style.display == "block")) {
                for (let i = 0; i < 1; i++) document.getElementById("goToPre").click();
            }
        }
        if (e.key == "ArrowRight") {
            if (document.getElementById("goToNext") && (!document.getElementById("goToNext").style.display || document.getElementById("goToNext").style.display == "block")) {
                for (let i = 0; i < 1; i++) document.getElementById("goToNext").click();
            }
        }
        if (e.keyCode == 13) {
            if (players[0]) {
                let plasd = players[0].robots[players[0].robotIndex];
                if (plasd) {
                    LMAOASODPKASPODK.push({
                        x: plasd.x,
                        y: plasd.y
                    });
                }
            }
            for (let i = 0; i < (window.isDev ? 13 : 1); i++) {
                if (document.getElementById("upgradeShape")) {
                    document.getElementById("upgradeShape").click();
                    document.getElementById("UPGRADE").click();
                }
                if (document.getElementById("Upgrade")) {
                    document.getElementById("Upgrade").click();
                    if (document.getElementById("UPGRADE")) document.getElementById("UPGRADE").click();
                }
            }
        }
        if (e.key == "=" && player.gameMode >= 0) {
            document.getElementById("chooseSlot").style.bottom = "-200px";
            document.getElementById("shields").innerHTML = "";
            document.getElementById("abilityCharges").innerHTML = "";
            document.getElementById("abilityCharges2").innerHTML = "";
            document.getElementById("useActiveModule").style.display = "none";
            document.getElementById("useAbility").style.display = "none";
            document.getElementById("useAbility2").style.display = "none";
            document.getElementById("weaponThing").style.display = "none";
            document.getElementById("healthBar").style.display = "none";
            document.getElementById("mothershipBar").style.display = "none";
            document.getElementById("mapName").style.display = "none";
            if (document.getElementById("useSlot8")) document.getElementById("useSlot8").style.display = "none";
            endGame([...players], false, true);
            resetDataStuff();
        }
    });
    document.addEventListener("keyup", (e) => {
        keysPressed[e.keyCode] = 0;
    });
    var blueBell = [{
        "name": "Ultimate Purple Hexagon",
        "weapons": {
            "heavy": "Ultimate Destroyer",
            "light": "Ultimate Punisher"
        },
        "modules": [
            "Repair Amplifier",
            "Nuclear Amplifier", ,
            "Immune Amplifier",
            "Last Stand"
        ],
        "drone": "Superman",
        "pilotName": "Everest Oded",
        "skills": [
            "Road Hog",
            "Deft Survivor",
            "Master Gunsmith",
            "Armor Expert",
            "Mechanic",
            "Stubborn Warrior",
            "Medicine Expert"
        ],
        "activeModuleIndex": 6
    }, {
        "name": "Light Gray Heptagon",
        "weapons": {
            "heavy": "Aramis",
            "light": "Athos"
        },
        "modules": [
            "Repair Amplifier",
            "Nuclear Amplifier",
            "Immune Amplifier",
            "Defense Amplifier"
        ],
        "drone": "Hawkeye",
        "pilotName": "Raptor",
        "skills": [
            "Armor Expert",
            "Mechanic",
            "Cautious Pilot",
            "Stubborn Warrior",
            "Tough Guy",
            "Deft Survivor",
            "Destroyer"
        ],
        "activeModuleIndex": 6
    }, {
        "name": "Mauler",
        "weapons": {
            "heavy": "Discharger",
            "light": "Igniter"
        },
        "modules": [
            "Titan Repair Amplifier",
            "Grand Balance Reactor",
            "Grand Balance Reactor",
            "Grand Balance Reactor"
        ],
        "pilotName": "Everest Oded (Titans)", // "Chris Kristoffer (Titans: Luchador)",
        "skills": [
            "Road Hog",
            "Destroyer",
            "Mechanic",
            "Generalist",
            "Armor Expert",
            "Stubborn Warrior",
            "Wonderworker",
            "Tough Guy",
            "Cautious Pilot",
            "Deft Survivor"
        ],
        "activeModuleIndex": 0
    }, {
        "name": "Grayish Blue Triangle",
        "weapons": {
            "heavy": "Ultimate Destroyer",
            "light": "Ultimate Punisher"
        },
        "modules": [
            "Repair Amplifier",
            "Nuclear Amplifier",
            "Last Stand"
        ],
        "drone": "Pascal",
        "pilotName": "Sux",
        "skills": [
            "Road Hog",
            "Deft Survivor",
            "Master Gunsmith",
            "Armor Expert",
            "Mechanic",
            "Stubborn Warrior",
            "Medicine Expert"
        ],
        "activeModuleIndex": 6
    }, {
        "name": "Ultimate Purple Hexagon",
        "weapons": {
            "heavy": "Ultimate Destroyer",
            "light": "Ultimate Punisher"
        },
        "modules": [
            "Repair Amplifier",
            "Nuclear Amplifier", ,
            "Immune Amplifier",
            "Last Stand"
        ],
        "drone": "Superman",
        "pilotName": "Everest Oded",
        "skills": [
            "Road Hog",
            "Deft Survivor",
            "Master Gunsmith",
            "Armor Expert",
            "Mechanic",
            "Stubborn Warrior",
            "Medicine Expert"
        ],
        "activeModuleIndex": 6
    }, {
        "name": "Ultimate Brown Pentagon",
        "weapons": {
            "heavy": "Hammer",
            "light": "Mace"
        },
        "modules": [
            "Repair Amplifier",
            "Nuclear Amplifier",
            "Defense Amplifier",
            "Immune Amplifier"
        ],
        "drone": "Superman",
        "pilotName": "Bernadette",
        "skills": [
            "Cautious Pilot",
            "Road Hog",
            "Armor Expert",
            "Stubborn Warrior",
            "Tough Guy",
            "Mechanic",
            "Master Gunsmith"
        ],
        "activeModuleIndex": 6
    }, {
        "name": "Ultimate Tan Circle",
        "weapons": {
            "heavy": "Aramis",
            "light": "Athos"
        },
        "modules": [
            "Repair Amplifier",
            "Immune Amplifier",
            "Nuclear Amplifier",
            "Defense Amplifier"
        ],
        "drone": "Superman",
        "pilotName": "Mosi Kristoffer",
        "skills": [
            "Destroyer",
            "Deft Survivor",
            "Cautious Pilot",
            "Armor Expert",
            "Tough Guy",
            "Stubborn Warrior",
            "Mechanic"
        ],
        "activeModuleIndex": 6
    }, {
        "name": "Ultimate Purple Hexagon",
        "weapons": {
            "heavy": "Ultimate Destroyer",
            "light": "Ultimate Punisher"
        },
        "modules": [
            "Repair Amplifier",
            "Nuclear Amplifier", ,
            "Immune Amplifier",
            "Last Stand"
        ],
        "drone": "Superman",
        "pilotName": "Everest Oded",
        "skills": [
            "Road Hog",
            "Deft Survivor",
            "Master Gunsmith",
            "Armor Expert",
            "Mechanic",
            "Stubborn Warrior",
            "Medicine Expert"
        ],
        "activeModuleIndex": 6
    }, {
        "name": "Light Gray Heptagon",
        "weapons": {
            "heavy": "Aramis",
            "light": "Athos"
        },
        "modules": [
            "Repair Amplifier",
            "Nuclear Amplifier",
            "Defense Amplifier",
            "Immune Amplifier"
        ],
        "drone": "Hawkeye",
        "pilotName": "R4PT0R",
        "skills": [
            "Armor Expert",
            "Destroyer",
            "Deft Survivor",
            "Road Hog",
            "Tough Guy",
            "Cautious Pilot",
            "Mechanic"
        ],
        "activeModuleIndex": 6
    }];
    var redBell = [{
        "name": "Ultimate Brown Pentagon",
        "weapons": {
            "heavy": "Fengbao",
            "light": "Leiming"
        },
        "modules": [
            "Defense Amplifier",
            "Nuclear Amplifier",
            "Repair Amplifier", "Repair Amplifier",
            "Immune Amplifier", "Immune Amplifier",
            "Anti Control"
        ],
        "drone": "Pascal",
        "pilotName": "Bernadette",
        "skills": [
            "Armor Expert",
            "Tough Guy",
            "Cautious Pilot",
            "Gunsmith",
            "Road Hog",
            "Stubborn Warrior",
            "Mechanic"
        ],
        "activeModuleIndex": 3
    }, {
        "name": "Light Blue Heptagon",
        "weapons": {
            "heavy": "Inferno",
            "light": "Pyro"
        },
        "modules": [
            "Defense Amplifier",
            "Nuclear Amplifier",
            "Repair Amplifier",
            "Immune Amplifier", "Last Stand"
        ],
        "drone": "Pascal",
        "pilotName": "Sebastian Wren",
        "skills": [
            "Sebastian's Fortitude",
            "Armor Expert",
            "Road Hog",
            "Tough Guy",
            "Stubborn Warrior",
            "Mechanic",
            "Cautious Pilot",
            "Wonderworker"
        ],
        "activeModuleIndex": 3
    }, {
        "name": "Blue-Outlined Tan Circle",
        "weapons": {
            "heavy": "Fengbao",
            "light": "Leiming"
        },
        "modules": [
            "Defense Amplifier",
            "Nuclear Amplifier",
            "Repair Amplifier",
            "Immune Amplifier", "Last Stand", "Anti Control"
        ],
        "drone": "Kestrel",
        "pilotName": "Mosi Kristoffer",
        "skills": [
            "Mosi's Stampede",
            "Armor Expert",
            "Cautious Pilot",
            "Stubborn Warrior",
            "Tough Guy",
            "Deft Survivor",
            "Wonderworker",
            "Mechanic"
        ],
        "activeModuleIndex": 3
    }, {
        "name": "Magenta Hexagon",
        "weapons": {
            "heavy": "Maha Vajra",
            "light": "Vajra"
        },
        "modules": [
            "Nuclear Amplifier",
            "Repair Amplifier",
            "Immune Amplifier",
            "Defense Amplifier", "Last Stand"
        ],
        "drone": "Kestrel",
        "pilotName": "Indra",
        "skills": [
            "Indra's Prowess",
            "Deft Survivor",
            "Cautious Pilot",
            "Wonderworker",
            "Armor Expert",
            "Mechanic",
            "Stubborn Warrior",
            "Tough Guy"
        ],
        "activeModuleIndex": 3
    }, {
        "name": "Blue-Outlined Tan Circle",
        "weapons": {
            "heavy": "Gangantua",
            "light": "Pantagruel"
        },
        "modules": [
            "Repair Amplifier",
            "Nuclear Amplifier",
            "Immune Amplifier",
            "Immune Amplifier"
        ],
        "drone": "Hiruko",
        "pilotName": "Mosi Kristoffer",
        "skills": [
            "Mosi's Stampede",
            "Mechanic",
            "Deft Survivor",
            "Armor Expert",
            "Tough Guy",
            "Cautious Pilot",
            "Stubborn Warrior",
            "Wonderworker"
        ],
        "activeModuleIndex": 3
    }, {
        "name": "Magenta Circle",
        "weapons": {
            "heavy": "Shocker",
            "light": "Fulgur"
        },
        "modules": [
            "Last Stand",
            "Nuclear Amplifier",
            "Nuclear Amplifier",
            "Balance Unit"
        ],
        "drone": "Kestrel",
        "pilotName": "Everest Oded",
        "skills": [
            "Everest's Knowhow",
            "Armor Expert",
            "Mechanic",
            "Master Gunsmith",
            "Deft Survivor",
            "Thrill Hunter",
            "Thrill Seeker",
            "Destroyer"
        ],
        "activeModuleIndex": 3
    }, {
        "name": "White Heptagon",
        "weapons": {
            "heavy": "Maha Vajra",
            "light": "Vajra"
        },
        "modules": [
            "Defense Amplifier",
            "Nuclear Amplifier",
            "Repair Amplifier",
            "Immune Amplifier",
            "Damage Controller", "Damage Controller"
        ],
        "drone": "Pascal",
        "pilotName": "Everest Oded",
        "skills": [
            "Everest's Knowhow",
            "Stubborn Warrior",
            "Cautious Pilot",
            "Wonderworker",
            "Armor Expert",
            "Tough Guy",
            "Mechanic",
            "Defense Expert"
        ],
        "activeModuleIndex": 3
    }, {
        "name": "Dark Tan Circle",
        "weapons": {
            "heavy": "Veyron",
            "light": "Punisher"
        },
        "modules": [
            "Defense Amplifier",
            "Nuclear Amplifier",
            "Repair Amplifier",
            "Immune Amplifier"
        ],
        "drone": "Pascal",
        "pilotName": "Xavier Sinclair",
        "skills": [
            "Road Hog",
            "Mechanic",
            "Wonderworker",
            "Destroyer",
            "Armor Expert",
            "Tough Guy",
            "Deft Survivor"
        ],
        "activeModuleIndex": 2
    }];
    function leagueToTier(type) {
        let league = player.league;
        let name = getLeagueName(league);
        if (name == "Champion") {
            if (league >= 7e3) return 5;
            if (league >= 6e3 && Math.random() < .85) {
                return 5;
            } else if (Math.random() < .25 && !type) {
                return 5;
            } else if (Math.random() < .5 && type == "weapon") {
                return 5;
            } else {
                return 4;
            }
        } else if (name == "Master") {
            if (Math.random() < .75) {
                return 4;
            } else {
                return 3;
            }
        } else if (name == "Expert") {
            if (Math.random() < .5) {
                return 4;
            } else {
                return 3;
            }
        } else if (name == "Diamond") {
            if (Math.random() < .25) {
                return 4;
            } else {
                return 3;
            }
        } else if (name == "Gold") {
            if (Math.random() < .5) {
                return 3;
            } else {
                return 2;
            }
        } else if (name == "Silver") {
            return 2;
        } else if (name == "Bronze") {
            if (Math.random() < .5) {
                return 2;
            } else {
                return 1;
            }
        } else if (name == "Private") {
            if (Math.random() < .25) {
                return 2;
            } else {
                return 1;
            }
        } else {
            return 1;
        }
    }
    function leagueToLevel() {
        let league = player.league;
        let name = getLeagueName(league);
        if (name == "Champion") {
            return 14;
        } else if (name == "Master") {
            return Math.randInt(13, 14);
        } else if (name == "Expert") {
            return Math.randInt(11, 13);
        } else if (name == "Diamond") {
            return Math.randInt(10, 12);
        } else if (name == "Gold") {
            return Math.randInt(8, 12);
        } else if (name == "Silver") {
            return Math.randInt(5, 9);
        } else if (name == "Bronze") {
            return Math.randInt(5, 7);
        } else if (name == "Private") {
            return Math.randInt(3, 5);
        } else {
            return Math.randInt(1, 3);
        }
    }
    function generateRandomName() {
        let listOfNames = ["SolarSculptor", "QuantumQuasar", "EternalVagabond", "VividVortex", "NovaNomad", "MysticMarauder", "GalacticGlider", "CrimsonComet", "SilverShadow", "AstralPioneer", "TechTrekker", "CelestialScribe", "PixelPilgrim", "NeonNebula", "StarlightSorcerer", "SereneStardust", "SonicSpecter", "CipherSeeker", "NebulaNinja", "EpicExplorer", "RogueRadiance", "QuantumQuester", "DreamDynamo", "CeruleanCraze", "AstroAdventurer", "SynthwaveSculptor", "LunarLuminary", "BlazeBlitzer", "EclipseEnigma", "WhisperingWarp", "DigitalDrifter", "PulsarPioneer", "VortexVagabond", "InfiniteInsider", "CelestialCipher", "StellarStrategist", "PhantomPioneer", "VividVoyager", "CosmicChampion", "NebulaNavigator"];
        listOfNames.forEach(e => {
            e = e.slice(0, 14);
        });
        return listOfNames[Math.floor(Math.random() * listOfNames.length)];
    }
    var KILLLOGS = [];
    function addLogger(name1, weapon, name2) {
        KILLLOGS.push({ attacker: name1, weapon: weapon, victim: name2 });
        if (KILLLOGS.length > 3) {
            KILLLOGS.shift();
        }
    }
    var inGameSids = -1;
    function setRobotSids(robot) {
        robot.inGameSid = inGameSids;
        inGameSids++;
    }
    function setRobotLocation(robot, isAlly, gameMode, spawnLocations) {
        if (gameMode == 7) {
            robot.x = Math.random() * mapInfo.x;
            robot.y = Math.random() * mapInfo.y;
        } else if (gameMode == 3 || gameMode == 4) {
            robot.x = Math.random() * mapInfo.x;
            if (player.mapID == 1) {
                robot.y = Math.randInt((2500 + robot.scale * 2), mapInfo.y - (2500 + robot.scale * 2));
            } else {
                robot.y = Math.random() * mapInfo.y;
            }
        } else if (robot.isMe) {
            if ((gameMode == 0 || gameMode == 6) && !spawnLocations) {
                robot.x = Math.random() * mapInfo.x;
                robot.y = Math.random() * mapInfo.x;
            } else {
                robot.x = spawnLocations[0][spawnLocations[1]].x + Math.randInt(-250, 500);
                robot.y = spawnLocations[0][spawnLocations[1]].y + Math.randInt(-250, 500);
            }
        } else {
            if (isAlly) {
                robot.x = spawnLocations[0][spawnLocations[1]].x + Math.randInt(-250, 500);
                robot.y = spawnLocations[0][spawnLocations[1]].y + Math.randInt(-250, 500);
            } else {
                let index = spawnLocations[1] ? 0 : 1;
                robot.x = spawnLocations[0][index].x + Math.randInt(-250, 500);
                robot.y = spawnLocations[0][index].y + Math.randInt(-250, 500);
            }
        }
    }
    function setWeaponData(robot, weapons) {
        robot.weapons = [];
        let checked = 0;
        weapons = weapons.sort((a, b) => a.slot - b.slot);
        for (let t = 0; t < weapons.length; t++) {
            let newWeapon = new weapon(weapons[t]);
            newWeapon.level = weapons[t].level;
            newWeapon.slot = (weapons[t].slot != undefined ? weapons[t].slot : t);
            if ((robot.name == "Ultimate Brown Pentagon" || robot.name == "Kid" || robot.name == "Brown Pentagon") && newWeapon.type == "Heavy") {
                newWeapon.notActive = true;
            } else if ((robot.name == "Eiffel" || robot.name == "Light Blue Heptagon") && newWeapon.type == "Heavy" && checked < 2) {
                checked++;
                newWeapon.targetedWeaponsToUse = true;
                newWeapon.notActive = true;
            } else if (robot.name == "Pinkish-Red Heptagon" && newWeapon.type == "Light") {
                newWeapon.notActive = true;
            } else if (newWeapon.name == "Cinder" && robot.name == "Orange Pentagon") {
                newWeapon.dmg *= 2;
            }
            if (robot.name == "Polygon") {
                if (newWeapon.range < 2e3) newWeapon.range = 2e3;
                newWeapon.reload *= .05;
            }
            robot.weapons.push(newWeapon);
        }
    }
    function setModuleData(robot, modules) {
        robot.modules = [];
        for (let t = 0; t < modules.length; t++) {
            let newModule = new module(modules[t]);
            newModule.level = modules[t].level;
            robot.modules.push(newModule);
        }
        let repairAmps = robot.modules.filter(e => e.name == "Repair Amplifier" || e.name == "Titan Repair Amplifier");
        if (repairAmps.length) {
            robot.repairAmp = {
                require: 1e300,
                requirePercent: 1,
                defensePoints: 0,
                amount: 0,
                titan: false,
                graydmg: 0,
                normal: 0
            };
            for (let i = 0; i < repairAmps.length; i++) {
                if (robot.repairAmp.requirePercent >= repairAmps[i].durabilityLostAmp) {
                    robot.repairAmp.requirePercent = repairAmps[i].durabilityLostAmp;
                    robot.repairAmp.require = robot.maxhealth * repairAmps[i].durabilityLostAmp;
                }
                robot.repairAmp.titan = repairAmps[i].titan;
                robot.repairAmp.normal += repairAmps[i].selfFixRepair;
                robot.repairAmp.graydmg += repairAmps[i].grayDamageFixRepair;
                robot.repairAmp.defensePoints += repairAmps[i].increasedDefensePoints;
                robot.repairAmp.amount++;
            }
        }
        let antiControl = robot.modules.filter(e => e.name == "Anti Control" || e.name == "Titan Anti Control").sort((a, b) => b.antiControl - a.antiControl)[0];
        if (antiControl) {
            robot.negEffectReduction = 1 - antiControl.antiControl;
        }
        let defenseAmp = robot.modules.filter(e => e.name == "Defense Amplifier");
        if (defenseAmp.length) {
            let asd = defenseAmp.sort((a, b) => b.increasedDefensePoints - a.increasedDefensePoints)[0];
            asd = asd.defensePointsIncrease;
            robot.defenseAmp = {
                name: "Defense Amplifier",
                increase: asd,
                amount: defenseAmp.length
            };
        }
        let immuneamps = robot.modules.filter(e => e.name == "Immune Amplifier");
        if (immuneamps.length) {
            robot.immuneAmp = {
                name: "Immune Amplifier",
                healthIncrease: (3 * (robot.maxhealth * (immuneamps.sort((a, b) => b.healthIncrease - a.healthIncrease)[0].healthIncrease))) / 60,
                amount: immuneamps.length
            };
        }
    }
    function setShieldsData(robot) {
        robot.shields = [];
        let tmpShields = {};
        for (let i = 0; i < robot.weapons.length; i++) {
            let weapon = robot.weapons[i];
            if (weapon.baseShielding) {
                if (tmpShields[weapon.baseShielding.health] == null) {
                    tmpShields[weapon.baseShielding.health] = 1;
                } else {
                    tmpShields[weapon.baseShielding.health]++;
                }
            }
        }
        let increase = 1;
        if (robot.fixedExtraShieldHealthL1 + 1 >= 1) {
            increase += robot.fixedExtraShieldHealthL1;
        }
        let fortifier = robot.modules.filter(e => e.shieldHealth);
        fortifier.forEach(e => {
            increase += e.shieldHealth;
        });
        for (let i in tmpShields) {
            robot.shields.push({
                maxhealth: parseInt(i) * tmpShields[i] * increase,
                health: parseInt(i) * tmpShields[i] * increase,
                baseShield: true,
                type: "energy",
                regen: .05
            });
        }
        if (robot.baseShielding) {
            if (robot.name == "Gray Pentagon" || robot.name == "Orange Pentagon") {
                let data = robot.baseShielding;
                let t = (Math.PI * 2) / data.amountOfShields;
                for (let i = 0; i < data.amountOfShields; i++) {
                    let divider = (robot.name == "Gray Pentagon" ? i == 0 ? 2 : data.amountOfShields : data.amountOfShields);
                    robot.shields.push({
                        maxhealth: (data.health * increase) / (divider),
                        health: (data.health * increase) / (divider),
                        baseShield: "built in",
                        dir: t * i,
                        angleDist: t,
                        type: data.type,
                        regen: data.regen
                    });
                }
            } else if (robot.name == "Arthur") {
                let data = robot.baseShielding;
                let health = (data.health * increase) / 2;
                robot.shields.push({
                    maxhealth: health,
                    health: health,
                    baseShield: "built in",
                    dir: Math.PI / 2.5,
                    angleDist: Math.PI / 3,
                    barrierField: true,
                    type: "normal",
                    regen: 0
                });
                robot.shields.push({
                    maxhealth: health,
                    health: health,
                    baseShield: "built in",
                    dir: -Math.PI / 2.5,
                    angleDist: Math.PI / 3,
                    barrierField: true,
                    type: "normal",
                    regen: 0
                });
            } else {
                robot.shields.push({
                    maxhealth: robot.baseShielding.health * increase,
                    health: robot.baseShielding.health * increase,
                    baseShield: "built in",
                    type: robot.baseShielding.type,
                    regen: robot.baseShielding.regen
                });
            }
        }
    }
    function doPilotSkillInject(skill, statAdjustments, robot) {
        if (skill.healthIncrease) {
            statAdjustments.health += skill.healthIncrease;
        }
        if (skill.blinkVV2) robot.blinkVV2 = true;
        if (skill.lynxV2) robot.lynxV2 = true;
        if (skill.mastermindV2) robot.mastermindV2 = true;
        if (skill.moreDamageOnNuclearRocketShot) {
            robot.moreDamageOnNuclearRocketShot = skill.moreDamageOnNuclearRocketShot;
        }
        if (skill.shieldBreakOnDefenseBreach) {
            robot.shieldBreakOnDefenseBreach = true;
        }
        if (skill.superMechanic) {
            robot.superMechanic = skill.superMechanic;
        }
        if (skill.name == "Bernadette's Stamina") {
            robot.baseShielding = undefined;
        }
        if (skill.superCometSplash) {
            robot.superCometSplash = true;
        }
        if (skill.domainRangeIncrease) {
            robot.domainRangeIncrease = skill.domainRangeIncrease;
        }
        if (skill.onAbilityUseStealth) {
            robot.onAbilityUseStealth = skill.onAbilityUseStealth;
        }
        if (skill.getAbilityBackAtHalfHealth) {
            robot.canGetAbilityBackAtHalfHealth = true;
        }
        if (skill.cometSplashV2) {
            robot.cometSplashV2 = true;
        }
        if (skill.abilityDefenseIncrease) {
            for (let i = 0; i < robot.abilities.length; i++) {
                let ability = robot.abilities[i];
                ability.abilityDefensePoints += skill.abilityDefenseIncrease;
            }
        }
        if (skill.abilityDurationIncrease) {
            for (let i = 0; i < robot.abilities.length; i++) {
                let ability = robot.abilities[i];
                ability.lastingTime += skill.abilityDurationIncrease;
            }
        }
        if (skill.skywardV2) robot.skywardV2 = skill.skywardV2;
        if (skill.chargeIncrease) {
            if (skill.name == "Forge's Breakthrough") {
                for (let i = 0; i < robot.abilities.length; i++) {
                    robot.abilities[i].reload *= .8;
                }
            } else if (skill.name == "Indra's Prowess") {
                robot.builtInDefensePoints += 50;
            }
            for (let i = 0; i < robot.abilities.length; i++) {
                robot.abilities[i].maxcharge += skill.chargeIncrease;
                robot.abilities[i].charges += skill.chargeIncrease;
            }
        }
        if (skill.debutDurationIncrease) {
            for (let i = 0; i < robot.abilities.length; i++) {
                if (robot.abilities[i].name == "Debut") {
                    robot.abilities[i].lastingTime += skill.debutDurationIncrease;
                }
            }
        }
        if (skill.abilitySpeedDecrease) {
            for (let i = 0; i < robot.abilities.length; i++) {
                robot.abilities[i].reload *= (1 - skill.abilitySpeedDecrease);
            }
        }
        if (skill.additionalHealth) {
            for (let i = 0; i < robot.abilities.length; i++) {
                robot.abilities[i].additionalHealth += skill.additionalHealth;
            }
        }
        if (skill.stampedeV2) {
            robot.stampedeV2 = true;
        }
        if (skill.dmgPercentage) {
            robot.dmgPercentage = skill.dmgPercentage;
        }
        if (skill.onAbilityUseSpeed) {
            robot.onAbilityUseSpeed = skill.onAbilityUseSpeed;
        }
        if (skill.extraAbilityDamage) {
            if (robot.extraAbilityDamageAddM == null) robot.extraAbilityDamageAddM = 0;
            robot.extraAbilityDamageAddM += skill.extraAbilityDamage;
        }
        if (skill.extraShieldHealth) {
            if (robot.fixedExtraShieldHealthL1 == null) robot.fixedExtraShieldHealthL1 = 0;
            robot.fixedExtraShieldHealthL1 += skill.extraShieldHealth;
        }
        if (skill.dmgIncrease) {
            statAdjustments.dmg += skill.dmgIncrease;
        }
        if (skill.mechanicHeal) {
            if (robot.mechanicHeal == null) robot.mechanicHeal = 0;
            robot.mechanicHeal += skill.mechanicHeal;
        }
        if (skill.speedIncrease) {
            statAdjustments.speed += skill.speedIncrease;
        }
        if (skill.onLowDefense) {
            robot.onLowDefense = skill.onLowDefense;
        }
        if (skill.onLowSpeed) {
            robot.onLowSpeed = skill.onLowSpeed;
        }
        if (skill.onAbilityUseFix) {
            robot.onAbilityUseFix = skill.onAbilityUseFix;
        }
        if (skill.onAbilityUseDefense) {
            robot.onAbilityUseDefense = skill.onAbilityUseDefense;
        }
        if (skill.increaseDurationOfPositiveEffects) {
            robot.increaseDurationOfPositiveEffects = skill.increaseDurationOfPositiveEffects;
        }
    }
    function setStatAdjustments(statAdjustments, robot, pilot, drone) {
        if (drone) {
            let Drone = { ...drone };
            let abilities = [];
            Drone.abilities.forEach(e => {
                if (e.unlockAtLevel <= drone.level || !e.unlockAtLevel) {
                    abilities.push(e);
                }
            });
            Drone.abilities = [...abilities];
            Drone.abilities.forEach(e => {
                if (e.healthIncrease) {
                    statAdjustments.health += e.healthIncrease;
                }
                if (e.dmgIncrease) {
                    statAdjustments.dmg += e.dmgIncrease;
                }
            });
            robot.drones.push({ ...Drone });
        }

        if (robot.name == "Grayish Blue Triangle" || robot.name == "Polygon") {
            let drone1 = new DRONEAJDOIASJDISAOJDAOSDJ(dronesData.find(e => e.name == (robot.name == "Polygon" ? "Dux Drone #3" : "Dux Drone #1")));
            drone1.abilities[0].dmg = robot.name == "Polygon" ? 6e3 : robot.abilities[0].dmg / 3;

            robot.drones.push(drone1);

            if (robot.name != "Polygon") {
                let drone2 = new DRONEAJDOIASJDISAOJDAOSDJ(dronesData.find(e => e.name == "Dux Drone #2"));
                drone2.abilities[0].dmg = robot.abilities[0].dmg / 3;

                let drone3 = new DRONEAJDOIASJDISAOJDAOSDJ(dronesData.find(e => e.name == "Dux Drone #3"));
                drone3.abilities[0].dmg = robot.abilities[0].dmg / 3;

                robot.drones.push(drone2);
                robot.drones.push(drone3);
            }

            for (let i = 0; i < 3; i++) if (robot.name == "Polygon") {
                let drone1 = new DRONEAJDOIASJDISAOJDAOSDJ(dronesData.find(e => e.name == "Dux Drone #3"));
                drone1.abilities[0].dmg = robot.name == "Polygon" ? 6e3 : robot.abilities[0].dmg / 3;

                let drone2 = new DRONEAJDOIASJDISAOJDAOSDJ(dronesData.find(e => e.name == "Dux Drone #3"));
                drone2.abilities[0].dmg = robot.name == "Polygon" ? 6e3 : robot.abilities[0].dmg / 3;

                let drone3 = new DRONEAJDOIASJDISAOJDAOSDJ(dronesData.find(e => e.name == "Dux Drone #3"));
                drone3.abilities[0].dmg = robot.name == "Polygon" ? 6e3 : robot.abilities[0].dmg / 3;

                robot.drones.push(drone1);
                robot.drones.push(drone2);
                robot.drones.push(drone3);
            }
        } else if (robot.name == "Ultimate Purple Hexagon") {
            let names = ["Pascal", "Kestrel", "Beak", "Armadillo", "Good Guy", "Defender", "Starter"];

            for (let i = 0; i < names.length; i++) {
                let data = dronesData.find(e => e.name == names[i]);
                let drone = new DRONEAJDOIASJDISAOJDAOSDJ(data);

                if (data.name.includes("Dux")) continue;

                for (let t = 0; t < drone.maxLevel; t++) {
                    upgradeDrone(drone, false, false, true);
                }

                robot.drones.push(drone);
            }
        }

        if (pilot && pilot.skills && pilot.skills.length) {
            for (let i = 0; i < pilot.skills.length; i++) {
                let skill = pilot.skills[i];
                if (skill) {
                    if (skill.onlyFor && robot.name.includes(skill.onlyFor)) {
                        doPilotSkillInject(skill, statAdjustments, robot);
                    } else if (skill.robotOwner && skill.robotOwner == robot.name) {
                        doPilotSkillInject(skill, statAdjustments, robot);
                    } else if (skill.legendary && !skill.onlyFor) {
                        doPilotSkillInject(skill, statAdjustments, robot);
                    }
                }
            }
        }
        for (let i = 0; i < robot.modules.length; i++) {
            let module = robot.modules[i];
            if (module.healthIncrease) {
                statAdjustments.health += module.healthIncrease;
            }
            if (module.dmgIncrease) {
                statAdjustments.dmg += module.dmgIncrease;
            }
        }
        if (robot.isMe && player.league <= 300 && (player.gameMode == 3 || player.gameMode == 2)) {
            statAdjustments.dmg += 10;
            statAdjustments.health += 5;
            statAdjustments.speed *= 3;
        }
        for (let i in statAdjustments) {
            statAdjustments[i] = Math.max(statAdjustments[i], 0.001);
        }
        if (robot.name == "Ultimate Gray Circle") {
            robot.effects.push({
                name: "forcefield",
                data: {
                    resistance: .9,
                    maxhealth: 200e3,
                    health: 200e3
                },
                rechargeTime: 5e3,
                lastTime: 1,
                lastForever: true
            });
        } else if (robot.name == "Orange Triangle") {
            robot.effects.push({
                name: "forcefield",
                data: {
                    resistance: .9,
                    min: .667,
                    maxhealth: robot.maxhealth,
                    health: robot.maxhealth
                },
                rechargeTime: 15e3,
                lastTime: 1,
                lastForever: true
            });
        } else if (robot.name == "Yellow Heptagon") {
            robot.effects.push({
                name: "forcefield",
                data: {
                    resistance: .9,
                    min: .75,
                    maxhealth: 300e3 * (robot.lynxV2 ? 1.45 : 1),
                    health: 300e3 * (robot.lynxV2 ? 1.45 : 1)
                },
                rechargeTime: 6e3,
                lastTime: 1,
                lastForever: true
            });
        } else if (robot.name == "Ultimate Brown Pentagon") {
            robot.effects.push({
                name: "anti defense mig",
                lastTime: 1,
                lastForever: true
            });
        } else if (robot.name == "Teal Pentagon") {
            robot.effects.push({
                name: "forcefield",
                data: {
                    resistance: .99,
                    min: .9,
                    maxhealth: robot.maxhealth * 2,
                    health: robot.maxhealth * 2
                },
                rechargeTime: 8e3,
                lastTime: 1,
                lastForever: true
            });
        } else if (robot.name == "Polygon") {
            robot.effects.push({
                name: "anti defense mig",
                lastTime: 1,
                lastForever: true
            });
            robot.effects.push({
                name: "stampede",
                a: true,
                lastForever: true,
                lastTime: 1
            });
            /*robot.effects.push({
                name: "reflector",
                return: 1,
                block: .8,
                lastForever: true,
                lastTime: 1
            });
            robot.effects.push({
                name: "forcefield",
                data: {
                    resistance: .8,
                    min: .667,
                    maxhealth: robot.health * 5,
                    health: robot.health * 5
                },
                rechargeTime: 500,
                lastTime: 1,
                lastForever: true
            });*/
        }
    }
    function adjustStats(robot, statAdjustments) {
        let { health, speed, dmg } = statAdjustments;
        robot.normalMaxHealth = robot.health = robot.maxhealth = parseInt(removeDecimals(robot.maxhealth * health)) + (robot.additionalHealth || 0);
        robot.speed *= speed;
        dmg += (robot.baseDamageIncrease || 0);
        if (robot.abilities.length) {
            for (let i = 0; i < robot.abilities.length; i++) {
                let ability = robot.abilities[i];
                if (ability.dmg) {
                    ability.dmg *= dmg + (robot.extraAbilityDamageAddM || 0);
                }
                if (ability.dotDamage) {
                    ability.dotDamage *= dmg + (robot.extraAbilityDamageAddM || 0);
                }
            }
        }
        for (let i = 0; i < robot.weapons.length; i++) {
            let weapon = robot.weapons[i];
            weapon.dmg *= dmg;
            if (weapon.dotDamage) {
                weapon.dotDamage *= dmg;
            }
        }
        if (robot.name == "White Octagon") {
            let newWeapon = new weapon({
                tier: 4,
                industryName: "Octagon",
                name: "Skyward",
                type: "Heavy",
                projType: "energy",
                desc: "",
                dmg: robot.abilities[0].dmg,
                imageSource: "./images/weapons/flux.png",
                fireRate: 100,
                ammo: 101,
                reload: robot.abilities[0].reload,
                range: 2e3,
                cost: { sliver: 1e300, gold: 1e300 }
            });
            newWeapon.level = robot.level;
            newWeapon.slot = 2;
            newWeapon.unbreakable = true;
            newWeapon.notActive = true;
            robot.weapons.push(newWeapon);
        } else if (robot.name == "Light Gray Heptagon") {
            let newWeapon = new weapon({
                tier: 4,
                industryName: "Heptagon",
                name: "Comet Laser",
                type: "Heavy",
                projType: "energy",
                desc: "",
                continuousReload: true,
                dmg: robot.abilities[0].dmg / 5,
                healBackOnDamage: robot.superCometSplash ? 1.2 : .6,
                imageSource: "./images/weapons/aramis.png",
                fireRate: 125,
                ammo: 1e300,
                reload: 1,
                range: 600,
                cost: { sliver: 1e300, gold: 1e300 }
            });
            if (robot.superCometSplash) {
                newWeapon.defenseBypass = 1;
                newWeapon.motherShipCharge = 0.003;
            }
            newWeapon.level = robot.level;
            newWeapon.slot = 3;
            newWeapon.unbreakable = true;
            newWeapon.notActive = true;
            robot.weapons.push(newWeapon);
        }
        if (robot.name == "Ultimate Gray Circle" || robot.name == "Dark Gray Circle" || (!robot.name.includes("Red") && robot.name.includes("Orange Circle"))) {
            robot.effects.push({
                name: "reflector",
                return: robot.reflectorData.return,
                block: robot.reflectorData.resistance,
                lastForever: true,
                lastTime: 1
            });
        }
    }
    function setUpBotData(orginalRobot, weapons, modules, microchips, isAlly, gameMode, spawnLocations, isBluebell, drone) {
        let robot = new shape(orginalRobot, null, true);
        robot.effects = [];
        robot.level = orginalRobot.level;
        robot.USED = false;
        let leagueIndex = (player.league / 4700) * 100;
        if (orginalRobot.activeModuleIndex == null || orginalRobot.activeModuleIndex == undefined) {
            if (leagueIndex >= 100 && isBluebell) {
                robot.activeModuleIndex = activeModuleData.findIndex(e => e.name == (Math.random() > .5 ? "Unstable Conduit" : "Repairing Conduit"));
            } else if (leagueIndex >= 50) {
                robot.activeModuleIndex = Math.floor(activeModuleData.length * Math.random());
            } else {
                robot.activeModuleIndex = activeModuleData.findIndex(e => e.name == "Repair Unit");
            }
        }
        setRobotSids(robot);
        setRobotLocation(robot, isAlly, gameMode, spawnLocations);
        setWeaponData(robot, weapons);
        setModuleData(robot, modules);
        let statAdjustments = {
            dmg: 1,
            speed: 1,
            health: 1,
            negDmg: 1,
            negSpeed: 1,
            negHealth: 1
        };
        robot.isMe = orginalRobot.isMe;
        robot.playersIndexSid = orginalRobot.playersIndexSid;
        setStatAdjustments(statAdjustments, robot, microchips, drone);
        setShieldsData(robot);
        adjustStats(robot, statAdjustments);
        return robot;
    }
    function doDroneDataForBots(data) {
        if (!data) return null;
        if (data.drone) {
            let droneData = dronesData.find(e => e.name == data.drone);
            let Drone = new drone(droneData);
            let mainSkill = droneData.abilities[0];
            let e = typeof mainSkill.main == "object" ? mainSkill.main[0] : mainSkill.main;
            if (e == "dmg") e = "damage";
            let levels = mainSkill[e + "Data"].level.length;
            for (let i = 0; i < levels - 1; i++) {
                upgradeDrone(Drone, null, null, true);
            }
            return Drone;
        } else if (typeof data == "number") {
            let droneData = dronesData.filter(e => e.tier == data && !e.dontShow);
            droneData = droneData[Math.floor(Math.random() * droneData.length)];
            let Drone = new drone(droneData);
            let mainSkill = droneData.abilities[0];
            let e = typeof mainSkill.main == "object" ? mainSkill.main[0] : mainSkill.main;
            if (e == "dmg") e = "damage";
            let levels = mainSkill[e + "Data"].level.length;
            for (let i = 0; i < levels - 1; i++) {
                upgradeDrone(Drone, null, null, true);
            }
            return Drone;
        }
        return null;
    }
    const colors = ["Blue", "Green", "Yellow", "Orange", "Purple", "Pink", "Brown", "Black", "White", "Gray", "Cyan", "Magenta", "Teal", "Maroon", "Navy", "Olive", "Silver", "Gold", "Indigo"];
    function makeMothershipData(name) {
        let shape = undefined;
        if (name.includes("bell") && !name.includes("Red")) {
            if (name == "Bluebell" || Math.random() > .5) {
                shape = new mothership(mothershipData.find(e => e.name == "Black Oval"));
                for (let i = 0; i < shape.maxlevel - 1; i++) {
                    upgradeMothership(shape);
                }
                shape.turrets.push({ ...turretsData.find(e => e.name == "Nuclear Attack Cannon") });
                shape.turrets.push({ ...turretsData.find(e => e.name == "Life Saver") });
                shape.turrets.push({ ...turretsData.find(e => e.name == "Anti-Jamming Support") });
                shape.turrets.push({ ...turretsData.find(e => e.name == "Durability Extender") });
                shape.turrets.push({ ...turretsData.find(e => e.name == "Durability Extender") });
            } else {
                shape = new mothership(mothershipData.find(e => e.name == "Purple Rectangle"));
                for (let i = 0; i < shape.maxlevel - 1; i++) {
                    upgradeMothership(shape);
                }
                shape.turrets.push({ ...turretsData.find(e => e.name == "Nuclear Attack Cannon") });
                shape.turrets.push({ ...turretsData.find(e => e.name == "Nuclear Attack Cannon") });
                shape.turrets.push({ ...turretsData.find(e => e.name == "Durability Extender") });
                shape.turrets.push({ ...turretsData.find(e => e.name == "Durability Extender") });
            }
        } else if (name.includes("Redbell")) {
            shape = new mothership(mothershipData.find(e => e.name == "Gray Oval"));
            for (let i = 0; i < shape.maxlevel - 1; i++) {
                upgradeMothership(shape);
            }
            shape.turrets.push({ ...turretsData.find(e => e.name == "Life Saver") });
            shape.turrets.push({ ...turretsData.find(e => e.name == "Yellow Shield Self System") });
            shape.turrets.push({ ...turretsData.find(e => e.name == "Durability Extender") });
        } else {
            if (player.league >= 5e3) {
                if (player.league >= 6e3) {
                    let ship = mothershipData.find(e => e.name == "Gray Oval");
                    shape = new mothership(ship);
                    for (let i = 0; i < shape.maxlevel - 1; i++) {
                        upgradeMothership(shape);
                    }
                } else {
                    let n = (Math.random() > .5 ? "Green Oval" : "Gray Oval");
                    let ship = mothershipData.find(e => e.name == n);
                    shape = new mothership(ship);
                    for (let i = 0; i < shape.maxlevel - 1; i++) {
                        upgradeMothership(shape);
                    }
                }
            } else if (player.league >= 4e3) {
                let ship = mothershipData.find(e => e.name == "Green Oval");
                shape = new mothership(ship);
                for (let i = 0; i < shape.maxlevel - 1; i++) {
                    upgradeMothership(shape);
                }
            } else if (player.league >= 3e3) {
                let ship = mothershipData.find(e => e.name == "Black Rectangle");
                shape = new mothership(ship);
                for (let i = 0; i < shape.maxlevel - 1; i++) {
                    upgradeMothership(shape);
                }
            }
        }
        return shape;
    }
    function doPilotStuffForSetUpPlayers(leagueName, name, orginalRobot) {
        let indx = 0;
        let skills = 0;
        if (player.league >= 5500) {
            indx = pilotsData.findIndex(e => name.includes(e.legendarySkill?.onlyFor));
            if (indx === -1) {
                indx = 0;
            }
            skills = 8;
        } else if (leagueName == "Champion") {
            skills = 6;
        } else if (leagueName == "Master") {
            skills = Math.randInt(2, 5);
        } else if (leagueName == "Expert") {
            skills = 2;
        }
        let pilotName = pilotsData[indx].name;
        let skillsList = [
            "Armor Expert",
            "Tough Guy",
            "Cautious Pilot",
            "Mechanic",
            "Road Hog", "Road Hog",
            "Deft Survivor",
            "Stubborn Warrior"
        ];
        if (pilotName) {
            let Pilot = new pilot(pilotsData.find(e => e.name == pilotName));
            for (let i = 0; i < skills; i++) {
                let skilldata = pilotSkillList.find(e => e.name == skillsList[i]);
                if (skilldata) {
                    let newSkill = new skill(skilldata, null, orginalRobot);
                    for (let f = 0; f < 3; f++) {
                        upgradePilotSkill(newSkill);
                    }
                    Pilot.skills.push(newSkill);
                }
            }
            return Pilot;
        }
    }
    function setUpPlayersData(gameMode, spawnLocations) {
        inGameSids = -1;
        document.getElementById("money3Display").style.display = "none";
        document.getElementById("hangerUI").append(document.getElementById("money3Display"));
        let shapes = player.shapes.filter(e => e.slot != null);
        players[0] = {
            name: "player",
            isAlly: true,
            robotIndex: -1,
            robots: [],
            titanCharge: 1,
            mothership: {
                current: 0,
                data: player.motherships.find(e => e.using) ? { ...player.motherships.find(e => e.using) } : null
            }
        };
        for (let i = 0; i < 9; i++) {
            let orginalRobot = shapes.find(e => e.slot == i);
            if (orginalRobot) {
                let robot = new shape(orginalRobot, null, true);
                robot.effects = [];
                robot.level = orginalRobot.level;
                robot.isMe = true;
                robot.USED = false;
                setRobotSids(robot);
                setRobotLocation(robot, true, gameMode, spawnLocations);
                let weapons = player.weapons.filter(e => e.owner == orginalRobot.sid);
                setWeaponData(robot, weapons);
                let modules = player.modules.filter(e => e.owner == orginalRobot.sid);
                setModuleData(robot, modules);
                let statAdjustments = {
                    dmg: 1,
                    speed: 1,
                    health: 1,
                    negDmg: 1,
                    negSpeed: 1,
                    negHealth: 1
                };
                for (let i = 0; i < robot.modules.length; i++) {
                    let module = robot.modules[i];
                    if (module.name == "Titan Charger") {
                        players[0].titanCharge += module.titanCharge;
                    }
                }
                robot.playersIndexSid = 0;
                setStatAdjustments(statAdjustments, robot, player.pilots.find(e => e.owner == orginalRobot.sid), player.drones.find(e => e.owner == orginalRobot.sid));
                setShieldsData(robot);
                adjustStats(robot, statAdjustments);
                players[0].robots.push(robot);
            } else {
                players[0].robots.push(null);
            }
        }
        if (hasPlayers()) {
            let moduleIndex = Math.round((player.league / 5e3) * 100);
            let amount = gameMode == 4 ? 9 : gameMode == 7 ? 6 : 11;
            let preselectBots = {
                "Bluebell": 0,
                "Redbell": 0
            };
            let onlyPreselect = false;
            if (player.league >= 5e3 && Math.random() < .25) {
                onlyPreselect = true;
            }
            let amounnnt = 5;
            for (let i = 0; i < amount; i++) {
                let isAlly = gameMode == 7 ? false : gameMode == 4 ? false : i < 5 ? true : false;
                let name = generateRandomName();
                let isBluebell = false;
                if (onlyPreselect) {
                    if (isAlly) {
                        if (amounnnt) {
                            amounnnt--;
                            isBluebell = true;
                            name = "Redbell " + ((preselectBots.Redbell++) + 1);
                        }
                    } else {
                        isBluebell = true;
                        name = colors[preselectBots.Bluebell] + "bell";
                        preselectBots.Bluebell++;
                    }
                } else if (player.league >= 5e3 && preselectBots.Bluebell == 0 && !isAlly) {
                    name = "Bluebell";
                    isBluebell = true;
                    preselectBots.Bluebell++;
                } else if (player.league >= 5e3 && preselectBots.Redbell == 0 && isAlly) {
                    name = "Redbell";
                    isBluebell = true;
                    preselectBots.Redbell++;
                }
                players[1 + i] = {
                    name: name,
                    isBluebell: isBluebell,
                    isAlly: gameMode == 4 ? (name + i) : isAlly,
                    robotIndex: 0,
                    robots: [],
                    mothership: {
                        current: 0,
                        data: makeMothershipData(name)
                    }
                };
            }
            for (let tt = 0; tt < amount; tt++) {
                let isAlly = gameMode == 4 ? false : tt < 5 ? true : false;
                let robotAmount = Math.min(8, players[0].robots.filter(e => e).length);
                for (let i = 0; i < robotAmount + (players[tt + 1].isBluebell ? 1 : players[0].robots.find(e => e && e.titan) ? 1 : 0); i++) {
                    if (players[tt + 1].isBluebell) {
                        let level = players[tt + 1].name.includes("Redbell") ? 11 : 13;
                        let data = players[tt + 1].name.includes("Redbell") ? (redBell[i] || redBell[i - 1]) : blueBell[i];
                        let ShapeData = shapeData.find(e => e.name == data.name);
                        let orginalRobot = new shape(ShapeData, null, true);
                        level = (orginalRobot.titan ? 24 : level);
                        for (let i = 0; i < level; i++) {
                            upgradeShape(orginalRobot, true);
                        }
                        let weapons = [];
                        if (orginalRobot.hardpoints.heavy) {
                            let possibleWeapon = weaponData.find(e => e.name == data.weapons.heavy);
                            let tmpWeapon = new weapon(possibleWeapon);
                            for (let t = 0; t < level; t++) {
                                upgradeWeapon(tmpWeapon, null, null, true);
                            }
                            for (let i = 0; i < orginalRobot.hardpoints.heavy; i++) {
                                let newWeapon = new weapon(tmpWeapon);
                                newWeapon.level = tmpWeapon.level;
                                newWeapon.fireRateDecrease = 0;
                                newWeapon.reload *= .5;
                                weapons.push(newWeapon);
                            }
                        }
                        if (orginalRobot.hardpoints.light) {
                            let possibleWeapon = weaponData.find(e => e.name == data.weapons.light);
                            let tmpWeapon = new weapon(possibleWeapon);
                            for (let t = 0; t < level; t++) {
                                upgradeWeapon(tmpWeapon, null, null, true);
                            }
                            for (let i = 0; i < orginalRobot.hardpoints.light; i++) {
                                let newWeapon = new weapon(tmpWeapon);
                                newWeapon.level = tmpWeapon.level;
                                newWeapon.fireRateDecrease = 0;
                                newWeapon.reload *= .5;
                                weapons.push(newWeapon);
                            }
                        }
                        let modules = [];
                        for (let i = 0; i < data.modules.length; i++) {
                            let Module = new module(moduleData.find(e => e.name == (data.modules[i] || "Balance Unit")), null, null);
                            for (let t = 0; t < (orginalRobot.titan ? 24 : 5); t++) {
                                upgradeModule(Module, null, null, true);
                            }
                            modules.push(Module);
                        }
                        let DDrone = doDroneDataForBots(data);
                        let pilotInfo = [];
                        if (data.pilotName) {
                            let Pilot = new pilot(pilotsData.find(e => e.name == data.pilotName));
                            if (data.skills) {
                                for (let ii = 0; ii < data.skills.length; ii++) {
                                    let skillName = data.skills[ii];
                                    let skilldata = pilotSkillList.find(e => e.name == skillName);
                                    if (skilldata) {
                                        let newSkill = new skill(skilldata, null, orginalRobot);
                                        for (let f = 0; f < 3; f++) {
                                            upgradePilotSkill(newSkill);
                                        }
                                        Pilot.skills.push(newSkill);
                                    }
                                }
                            }
                            pilotInfo = Pilot;
                        }
                        orginalRobot.playersIndexSid = (tt + 1);
                        orginalRobot.activeModuleIndex = data.activeModuleIndex;
                        players[1 + tt].robots.push(setUpBotData(orginalRobot, weapons, modules, pilotInfo, isAlly, gameMode, spawnLocations, (players[tt + 1].name.includes("Redbell") ? true : "true"), DDrone));
                    } else {
                        let tier = leagueToTier() - 1;
                        let weapont = leagueToTier("weapon") - 1;
                        let level = Math.min(leagueToLevel() * (i == 8 ? 2 : 1), 25) - 1;
                        let possibleShapes = shapeData.filter(e => e.tier == tier && (i == 8 ? e.titan : !e.titan));
                        possibleShapes = possibleShapes[Math.floor(possibleShapes.length * Math.random())];
                        let orginalRobot = new shape(possibleShapes, null, true);
                        for (let i = 0; i < level; i++) {
                            upgradeShape(orginalRobot, true);
                        }
                        let weapons = [];
                        let possibleWeapons = weaponData.filter(e => e.tier == weapont);
                        let allHeavy = possibleWeapons.filter(e => e.type == "Heavy" && (i == 8 ? e.titan : !e.titan));
                        let allLight = possibleWeapons.filter(e => e.type == "Light" && (i == 8 ? e.titan : !e.titan));
                        if (orginalRobot.hardpoints.heavy) {
                            let possibleWeapon = allHeavy[Math.floor(Math.random() * allHeavy.length)];
                            let tmpWeapon = new weapon(possibleWeapon);
                            for (let t = 0; t < level; t++) {
                                upgradeWeapon(tmpWeapon, null, null, true);
                            }
                            for (let i = 0; i < orginalRobot.hardpoints.heavy; i++) {
                                let newWeapon = new weapon(tmpWeapon);
                                newWeapon.level = tmpWeapon.level;
                                newWeapon.fireRateDecrease = 0;
                                weapons.push(newWeapon);
                            }
                        }
                        if (orginalRobot.hardpoints.light) {
                            let possibleWeapon = allLight[Math.floor(Math.random() * allLight.length)];
                            let tmpWeapon = new weapon(possibleWeapon);
                            for (let t = 0; t < level; t++) {
                                upgradeWeapon(tmpWeapon, null, null, true);
                            }
                            for (let i = 0; i < orginalRobot.hardpoints.light; i++) {
                                let newWeapon = new weapon(tmpWeapon);
                                newWeapon.level = tmpWeapon.level;
                                newWeapon.fireRateDecrease = 0;
                                weapons.push(newWeapon);
                            }
                        }
                        let modules = [];
                        let moduleHardpoints = orginalRobot.moduleHardpoints;
                        if (i == 8) {
                            if (moduleIndex >= 75) {
                                for (let i = 0; i < moduleHardpoints; i++) {
                                    let Module = new module(moduleData.find(e => e.name == "Grand Balance Reactor"), null, null);
                                    for (let t = 0; t < 24; t++) {
                                        upgradeModule(Module, null, null, true);
                                    }
                                    modules.push(Module);
                                }
                                for (let i = 0; i < 2; i++) {
                                    let Module = new module(moduleData.find(e => e.name == "Titan Repair Amplifier"), null, null);
                                    for (let t = 0; t < 24; t++) {
                                        upgradeModule(Module, null, null, true);
                                    }
                                    modules.push(Module);
                                }
                            } else if (moduleIndex >= 75) {
                                for (let i = 0; i < moduleHardpoints; i++) {
                                    let Module = new module(moduleData.find(e => e.name == "Grand Balance Reactor"), null, null);
                                    for (let t = 0; t < 24; t++) {
                                        upgradeModule(Module, null, null, true);
                                    }
                                    modules.push(Module);
                                }
                            } else if (moduleIndex >= 50) {
                                for (let i = 0; i < moduleHardpoints; i++) {
                                    let Module = new module(moduleData.find(e => e.name == "Titan Armor Kit"), null, null);
                                    for (let t = 0; t < 24; t++) {
                                        upgradeModule(Module, null, null, true);
                                    }
                                    modules.push(Module);
                                }
                            } else {
                                for (let i = 0; i < moduleHardpoints; i++) {
                                    let Module = new module(moduleData.find(e => e.name == "Titan Armor Kit"), null, null);
                                    for (let t = 0; t < 4; t++) {
                                        upgradeModule(Module, null, null, true);
                                    }
                                    modules.push(Module);
                                }
                            }
                        } else if (moduleIndex >= 75) {
                            if (moduleIndex >= 100) moduleHardpoints -= 2;
                            for (let i = 0; i < moduleHardpoints; i++) {
                                let Module = new module(moduleData.find(e => e.name == "Balance Unit"), null, null);
                                for (let t = 0; t < 5; t++) {
                                    upgradeModule(Module, null, null, true);
                                }
                                modules.push(Module);
                            }
                            if (moduleIndex >= 100) {
                                let name = (Math.random() < .5 ? "Repair Amplifier" : "Last Stand")
                                let Module = new module(moduleData.find(e => e.name == name), null, null);
                                for (let t = 0; t < 5; t++) {
                                    upgradeModule(Module, null, null, true);
                                }
                                modules.push(Module);
                                Module = new module(moduleData.find(e => e.name == "Nuclear Amplifier"), null, null);
                                for (let t = 0; t < 5; t++) {
                                    upgradeModule(Module, null, null, true);
                                }
                                modules.push(Module);
                            }
                        } else if (moduleIndex >= 50) {
                            for (let i = 0; i < moduleHardpoints; i++) {
                                let Module = new module(moduleData.find(e => e.name == "Balance Unit"), null, null);
                                for (let t = 0; t < 2; t++) {
                                    upgradeModule(Module, null, null, true);
                                }
                                modules.push(Module);
                            }
                        } else if (moduleIndex >= 25) {
                            for (let i = 0; i < moduleHardpoints; i++) {
                                let Module = new module(moduleData.find(e => e.name == "Heavy Armor Plating"), null, null);
                                for (let t = 0; t < 5; t++) {
                                    upgradeModule(Module, null, null, true);
                                }
                                modules.push(Module);
                            }
                        } else if (moduleIndex >= 13) {
                            for (let i = 0; i < moduleHardpoints; i++) {
                                let Module = new module(moduleData.find(e => e.name == "Armor Plating"), null, null);
                                for (let t = 0; t < 5; t++) {
                                    upgradeModule(Module, null, null, true);
                                }
                                modules.push(Module);
                            }
                        }
                        let leagueName = getLeagueName(player.league);
                        let droneTier = undefined;
                        if (player.league >= 6500 && Math.random() < .5) {
                            droneTier = 4;
                        } else if (leagueName == "Champion") {
                            droneTier = 3;
                        } else if (leagueName == "Master") {
                            droneTier = Math.random() > .5 ? 1 : 2;
                        } else if (leagueName == "Expert") {
                            droneTier = 2;
                        }
                        let DDrone = i == 8 ? null : doDroneDataForBots(droneTier);
                        let pilotInfo = i == 8 ? null : doPilotStuffForSetUpPlayers(leagueName, orginalRobot.name, orginalRobot);
                        orginalRobot.playersIndexSid = (tt + 1);
                        let botData = setUpBotData(orginalRobot, weapons, modules, pilotInfo, isAlly, gameMode, spawnLocations, false, DDrone);
                        if (i == 8) {
                            let indx = Math.floor((robotAmount - 2) * Math.random());
                            players[1 + tt].robots.splice((Math.random() < .5 ? 3 : 2), 0, botData);
                        } else {
                            players[1 + tt].robots.push(botData);
                        }
                    }
                }
            }
        }
        updateChooseSlots();
    }
    var buildings = [];
    var beaconPoints = {
        ally: 0,
        enemy: 0
    };
    function setUpCollisionBlocks() {
        for (let i = 0; i < buildings.length; i++) {
            let building = buildings[i];
            if (building.name == "wall rect") {
                let width = building.width;
                let height = building.height;
                let middleX = building.x + (building.width / 2);
                let middleY = building.y + (building.height / 2);
                let onlyDir1 = ((building.y + height >= mapInfo.y - 50) ? -(Math.PI / 2) : (building.y <= 50) ? Math.PI / 2 : null);
                let onlyDir2 = ((building.x + width >= mapInfo.x - 50) ? Math.PI : (building.x <= 50) ? 0 : null);
                //building.onlyDir_up_down: 1 - left, 2 - right
                //building.onlyDir_left_right: 1 - top, 2 - bottom
                if (building.x - 30 > 0 && !building.noUpDown) {
                    buildings.push({
                        name: "coll rect",
                        x: building.x - 30,
                        y: building.y + 15,
                        onlyDir: building.onlyDir_up_down1 || building.onlyDir_up_down || onlyDir1,
                        middleY: middleY,
                        height: height - 30,
                        width: 30
                    });
                }
                if (building.x + width + 30 < mapInfo.x && !building.noUpDown) {
                    buildings.push({
                        name: "coll rect",
                        x: building.x + width,
                        y: building.y + 15,
                        middleY: middleY,
                        onlyDir: building.onlyDir_up_down2 || building.onlyDir_up_down0 || onlyDir1,
                        height: height - 30,
                        width: 30
                    });
                }
                if (building.y - 30 > 0) {
                    buildings.push({
                        name: "coll rect",
                        x: building.x,
                        y: building.y - 30,
                        middleX: middleX,
                        onlyDir: building.onlyDir_left_right1 || building.onlyDir_left_right || onlyDir2,
                        height: 30,
                        width: width
                    });
                }
                if (building.y + height + 30 < mapInfo.y) {
                    buildings.push({
                        name: "coll rect",
                        x: building.x,
                        y: building.y + height,
                        middleX: middleX,
                        onlyDir: building.onlyDir_left_right2 || building.onlyDir_left_right || onlyDir2,
                        height: 30,
                        width: width
                    });
                }
            }
        }
    }
    var noBeacons = [3, 4, 9];
    function setMapBuildings(mapID, NoBeacons) {
        player.mapID = mapID;
        if (mapID == 0) {
            if (!noBeacons.includes(player.gameMode) && !NoBeacons) {
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: (mapInfo.x / 2) - 4e3,
                    y: mapInfo.y / 2
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: (mapInfo.x / 2) - 2e3,
                    y: mapInfo.y / 2
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x / 2,
                    y: mapInfo.y / 2
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: (mapInfo.x / 2) + 2e3,
                    y: mapInfo.y / 2
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: (mapInfo.x / 2) + 4e3,
                    y: mapInfo.y / 2
                });
            }
            buildings.push({
                name: "border rect",
                opacity: 1,
                antiAvoid: true,
                x: 0,
                y: 0,
                width: 3e3,
                height: 2e3
            });
            buildings.push({
                name: "border rect",
                antiAvoid: true,
                opacity: 1,
                x: mapInfo.x / 2 - 1000,
                y: 0,
                width: 2e3,
                height: 2e3
            });
            buildings.push({
                name: "border rect",
                antiAvoid: true,
                opacity: 1,
                x: mapInfo.x / 2 - 1000,
                y: mapInfo.y - 2e3,
                width: 2e3,
                height: 2e3
            });
            buildings.push({
                name: "border rect",
                antiAvoid: true,
                opacity: 1,
                x: mapInfo.x - 3e3,
                y: 0,
                width: 3e3,
                height: 2e3
            });
            buildings.push({
                name: "border rect",
                antiAvoid: true,
                opacity: 1,
                x: 0,
                y: mapInfo.y - 2e3,
                width: 3e3,
                height: 2e3
            });
            buildings.push({
                name: "border rect",
                antiAvoid: true,
                opacity: 1,
                x: mapInfo.x - 3e3,
                y: mapInfo.y - 2e3,
                width: 3e3,
                height: 2e3
            });
            buildings.push({
                name: "rect",
                color: "#808080",
                opacity: 1,
                x: 3e3 - 1500,
                y: 500,
                width: 1500,
                height: 1000
            });
            buildings.push({
                name: "rect",
                color: "#808080",
                opacity: 1,
                x: 3e3 - 1500,
                y: mapInfo.y - 1500,
                width: 1500,
                height: 1000
            });
            buildings.push({
                name: "wall rect",
                x: 1280,
                y: mapInfo.y / 2 - 625,
                width: 300,
                height: 1250
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x - 1280,
                y: mapInfo.y / 2 - 625,
                width: 300,
                height: 1250
            });
            buildings.push({
                name: "wall rect",
                x: 10e3 - 2e3,
                y: 1800,
                width: 1500,
                height: 200
            });
            buildings.push({
                name: "wall rect",
                x: 3e3,
                y: 1800,
                width: 1500,
                height: 200
            });
            buildings.push({
                name: "wall rect",
                x: 3e3,
                y: mapInfo.y - 2e3,
                width: 1500,
                height: 200
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x - 4500,
                y: mapInfo.y - 2e3,
                width: 1500,
                height: 200
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x / 2 - 1e3,
                y: mapInfo.y - 3500,
                onlyDir_up_down: -(Math.PI / 2),
                width: 200,
                height: 1500
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x / 2 + 800,
                y: 2e3,
                onlyDir_up_down: (Math.PI / 2),
                width: 200,
                height: 1500
            });
            buildings.push({
                name: "wall rect",
                x: 9500,
                y: mapInfo.x / 2 - 3750,
                onlyDir_up_down: -(Math.PI / 2),
                width: 200,
                height: 1500
            });
            buildings.push({
                name: "wall rect",
                x: 2800,
                y: 2000,
                onlyDir_up_down: (Math.PI / 2),
                width: 200,
                height: 1500
            });
        } else if (mapID == 1 && !noBeacons.includes(player.gameMode)) {
            if (!NoBeacons) {
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x / 2,
                    y: mapInfo.y / 4
                });
            }
            if (NoBeacons == "middle" || !noBeacons.includes(player.gameMode)) {
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x / 2,
                    y: mapInfo.y / 2
                });
            }
            if (!NoBeacons) {
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x / 2,
                    y: (mapInfo.y / 4) * 3
                });
            }
            if (!NoBeacons) {
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x / 4,
                    y: mapInfo.y / 2
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: (mapInfo.x / 4) * 3,
                    y: mapInfo.y / 2
                });
            }
        } else if (mapID == 2) {
            if (!noBeacons.includes(player.gameMode) && !NoBeacons) {
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: 6750,
                    y: 2250
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: 2e3,
                    y: mapInfo.y / 2
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x / 2,
                    y: mapInfo.y / 2
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: (mapInfo.x / 6) * 5,
                    y: mapInfo.y / 2
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: 6750,
                    y: mapInfo.y - 2250
                });
            }
            //left
            buildings.push({
                name: "wall rect",
                width: 1500,
                height: 400,
                x: 300,
                y: mapInfo.y / 2 - 200
            });
            buildings.push({
                name: "wall rect",
                width: 500,
                height: 200,
                x: 2e3 - 250,
                y: mapInfo.y / 2 - 1e3
            });
            buildings.push({
                name: "wall rect",
                width: 500,
                height: 200,
                x: 2e3 - 250,
                y: mapInfo.y / 2 + 800
            });
            //middle
            buildings.push({
                name: "wall rect",
                width: 2e3,
                height: 200,
                noUpDown: true,
                x: mapInfo.x / 2 - 1e3,
                y: mapInfo.y / 2 - 800
            });
            buildings.push({
                name: "wall rect",
                width: 2e3,
                height: 200,
                noUpDown: true,
                x: mapInfo.x / 2 - 1e3,
                y: mapInfo.y / 2 + 800
            });
            buildings.push({
                name: "wall rect",
                onlyDir_left_right: Math.PI,
                onlyDir_up_down2: Math.PI / 2,
                width: 200,
                height: 650,
                x: mapInfo.x / 2 - 1200,
                y: mapInfo.y / 2 - 800
            });
            buildings.push({
                name: "wall rect",
                onlyDir_left_right: Math.PI,
                onlyDir_up_down2: -Math.PI / 2,
                width: 200,
                height: 650,
                x: mapInfo.x / 2 - 1200,
                y: mapInfo.y / 2 + 350
            });
            buildings.push({
                name: "wall rect",
                onlyDir_left_right: 0.000000001,
                onlyDir_up_down1: Math.PI / 2,
                width: 200,
                height: 650,
                x: mapInfo.x / 2 + 1e3,
                y: mapInfo.y / 2 - 800
            });
            buildings.push({
                name: "wall rect",
                onlyDir_left_right: 0.000000001,
                onlyDir_up_down1: -Math.PI / 2,
                width: 200,
                height: 650,
                x: mapInfo.x / 2 + 1e3,
                y: mapInfo.y / 2 + 350
            });
            //city locatino:
            let x_1 = ((mapInfo.x / 6) * 5) - 1e3;
            buildings.push({
                name: "wall rect",
                width: 300,
                height: 1500,
                x: x_1,
                y: mapInfo.y / 2 - 750
            });
            buildings.push({
                name: "wall rect",
                width: 600,
                height: 600,
                x: x_1,
                y: mapInfo.y / 2 - 1750
            });
            buildings.push({
                name: "wall rect",
                width: 600,
                height: 600,
                x: x_1,
                y: mapInfo.y / 2 + 1250
            });
            buildings.push({
                name: "wall rect",
                width: mapInfo.x - (x_1 + 1e3),
                height: 600,
                x: x_1 + 1e3,
                y: mapInfo.y / 2 + 1250
            });
            buildings.push({
                name: "wall rect",
                width: mapInfo.x - (x_1 + 1200),
                height: 600,
                x: x_1 + 1e3,
                y: 3600
            });
            buildings.push({
                name: "wall rect",
                width: 500,
                height: 500,
                x: mapInfo.x - 900,
                y: mapInfo.y / 2 + 350
            });
            buildings.push({
                name: "wall rect",
                width: 500,
                height: 500,
                x: mapInfo.x - 900,
                y: mapInfo.y / 2 - 550
            });
            buildings.push({
                name: "wall rect",
                width: 500,
                height: 500,
                x: 8600 - 250,
                y: 5e3 - 250
            });
            //a beacon:
            buildings.push({
                width: 1500,
                height: 250,
                name: "wall rect",
                x: 6000,
                y: 1500
            });
            buildings.push({
                width: 250,
                height: 1e3,
                name: "wall rect",
                x: 5800,
                y: 2150
            });
            buildings.push({
                width: 250,
                height: 1e3,
                name: "wall rect",
                x: 7500,
                y: 2150
            });
            //e beacon:
            buildings.push({
                width: 1500,
                height: 250,
                name: "wall rect",
                x: 6000,
                y: 10250
            });
            buildings.push({
                width: 250,
                height: 1e3,
                name: "wall rect",
                x: 5800,
                y: 8850
            });
            buildings.push({
                width: 250,
                height: 1e3,
                name: "wall rect",
                x: 7500,
                y: 8850
            });
            buildings.push({
                width: 2e3,
                height: 250,
                name: "wall rect",
                x: 1200,
                y: 8e3
            });
            buildings.push({
                name: "pond",
                x: 0,
                y: 0,
                scale: 4e3
            });
        } else if (mapID == 3) {
            if (!noBeacons.includes(player.gameMode) && !NoBeacons) {
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: 1200,
                    y: 1200
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: 1200,
                    y: mapInfo.y - 1200
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x / 2,
                    y: mapInfo.y / 2
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x - 1200,
                    y: mapInfo.y - 1200
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x - 1200,
                    y: 1200
                });
            }
            buildings.push({
                name: "wall rect",
                x: 600,
                y: 2000,
                width: 1800,
                height: 200
            });
            buildings.push({
                name: "wall rect",
                x: 2200,
                y: 300,
                width: 200,
                height: 1400
            });
            buildings.push({
                name: "pond",
                scale: 800,
                x: mapInfo.x / 2,
                y: mapInfo.y / 2
            })
            buildings.push({
                name: "wall rect",
                x: 0,
                y: mapInfo.y - 2200,
                width: 2e3,
                height: 200
            });
            buildings.push({
                name: "wall rect",
                x: 2400,
                y: mapInfo.y - 2200,
                width: 200,
                height: 1800
            });
            buildings.push({
                name: "wall rect",
                x: 2150,
                y: mapInfo.y / 2 - 900,
                width: 250,
                height: 1800
            });
            buildings.push({
                name: "wall rect",
                x: 3200,
                y: mapInfo.y / 2 - 950,
                width: 200,
                height: 1900
            });
            buildings.push({
                name: "wall rect",
                x: 3800,
                y: mapInfo.y / 2 - 400,
                width: 200,
                height: 800
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x - 2150,
                y: mapInfo.y / 2 - 900,
                width: 250,
                height: 1800
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x - 3200,
                y: mapInfo.y / 2 - 950,
                width: 200,
                height: 1900
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x - 3800,
                y: mapInfo.y / 2 - 400,
                width: 200,
                height: 800
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x - 2200,
                y: mapInfo.y - 2000,
                width: 1800,
                height: 200
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x - 2200,
                y: mapInfo.y - 1400,
                width: 200,
                height: 1400
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x - 2200,
                y: 2000,
                width: 1800,
                height: 200
            });
            buildings.push({
                name: "wall rect",
                x: mapInfo.x - 2200,
                y: 300,
                width: 200,
                height: 1400
            });
        } else if (mapID == 4) {
            buildings.push({
                name: "hill",
                x: mapInfo.x / 2,
                y: mapInfo.y / 2,
                scale: 1000
            });
            if (!noBeacons.includes(player.gameMode) && !NoBeacons) {
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: 2250,
                    y: 2250
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x - 2250,
                    y: 2250
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x / 2,
                    y: mapInfo.y / 2
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: 2250,
                    y: mapInfo.y - 2250
                });
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x - 2250,
                    y: mapInfo.y - 2250
                });
            } else if (NoBeacons == "middle") {
                buildings.push({
                    name: "beacon",
                    antiAvoid: true,
                    x: mapInfo.x / 2,
                    y: mapInfo.y / 2
                });
            }
            buildings.push({
                name: "pond",
                x: mapInfo.x / 2,
                y: mapInfo.y / 2,
                scale: 1500
            });
            buildings.push({
                name: "water",
                x: 0,
                y: mapInfo.y / 2 - 500,
                width: mapInfo.x,
                height: 1e3
            });
            buildings.push({
                name: "water",
                x: mapInfo.y / 2 - 500,
                y: 0,
                width: 1e3,
                height: mapInfo.y
            });
            buildings.push({
                name: "wall rect",
                x: 3e3 - 150,
                y: 6750,
                width: 300,
                height: 2e3
            });
            buildings.push({
                name: "wall rect",
                x: 6725,
                y: 6800,
                width: 2e3,
                height: 300
            });
            buildings.push({
                name: "wall rect",
                x: 6800,
                y: 1250,
                width: 300,
                height: 2e3
            });
            buildings.push({
                name: "wall rect",
                x: 1250,
                y: 3000,
                width: 2e3,
                height: 300
            });
        }
        setUpCollisionBlocks();
    }
    var mapInfoData = [{
        id: 0,
        name: "Space Shuttle",
        x: 12500,
        y: 6e3

    }, {
        id: 1,
        name: "Void",
        x: 6e3,
        y: 6e3
    }, {
        id: 2,
        name: "Rome",
        x: 10e3,
        y: 12e3
    }, {
        id: 3,
        name: "Training Grounds",
        x: 10e3,
        y: 7e3
    }, {
        id: 4,
        name: "Lost Forest",
        x: 10e3,
        y: 10e3
    }];
    function buildMap(name, noBeacons) {
        let map = name ? mapInfoData.find(e => e.name == name) : mapInfoData[Math.floor(Math.random() * mapInfoData.length)];
        let spawnid = Math.randInt(0, 1);
        document.getElementById("mapName").style.color = map.id == 1 ? "#fff" : "#000";
        document.getElementById("mapName").innerHTML = `Map: ${map.name}${player.gameMode == 3 ? "" : ` (ID: ${spawnid})`}`;
        let spawnLocations = [];
        mapInfo.x = map.x;
        mapInfo.y = map.y;
        setMapBuildings(map.id, noBeacons);
        if (map.id == 0 || map.id == 3) {
            spawnLocations = [{
                x: 250,
                y: mapInfo.y / 2
            }, {
                x: mapInfo.x - 250,
                y: mapInfo.y / 2
            }]
        } else {
            if (map.id == 4) {
                spawnLocations = [{
                    x: 500,
                    y: 500
                }, {
                    x: mapInfo.x - 500,
                    y: mapInfo.y - 500
                }];
            } else {
                spawnLocations = [{
                    x: mapInfo.x / 2,
                    y: 1e3
                }, {
                    x: mapInfo.x / 2,
                    y: mapInfo.y - 1e3
                }];
            }
        }
        return [spawnLocations, spawnid];
    }
    function setUpGame(gameMode, gameData, gameDataIndx) {
        players = [];
        enemies = [];
        player.gameMode = gameMode;
        let spawnLocations;
        if (gameMode == 2 || gameMode == 9 || gameMode == 4 || gameMode == 7) {
            if (gameMode == 7) {
                mapInfo.x = mapInfo.y = 4e3;
                buildings.push({
                    name: "wall rect",
                    x: mapInfo.x / 2 - 250,
                    y: mapInfo.y / 2 - 250,
                    scale: 500,
                    width: 500,
                    height: 500
                });
                while (buildings.length < 4) {
                    let x = mapInfo.x * Math.random();
                    let y = mapInfo.y * Math.random();
                    let scale = Math.randInt(200, 800);
                    if (!buildings.find(e => dist(e, { x: x, y: y }) <= e.scale + scale)) {
                        buildings.push({
                            name: "pond",
                            scale: Math.randInt(200, 800),
                            x: mapInfo.x * Math.random(),
                            y: mapInfo.y * Math.random()
                        });
                    }
                }
            } else {
                document.getElementById("mapName").style.display = "block";
                spawnLocations = buildMap();
                beaconPoints = {
                    ally: 0,
                    enemy: 0
                };
            }
        } else if (gameMode == 6) {
            mapInfo.x = mapInfo.y = 1e3;
            enemies.push(new enemy({
                health: 150e3,
                scale: 100,
                name: "Low Health",
                speed: 0,
                dummy: true,
                x: 100,
                y: 100
            }, {}));
            enemies.push(new enemy({
                health: 250e3,
                scale: 100,
                name: "Med Health",
                speed: 0,
                dummy: true,
                x: 500,
                y: 500
            }, {}));
            enemies.push(new enemy({
                health: 350e3,
                scale: 100,
                name: "High Health",
                speed: 0,
                dummy: true,
                x: 900,
                y: 900
            }, {}));
            enemies.push(new enemy({
                health: 1e9,
                scale: 100,
                name: "Test Dummy",
                speed: 0,
                dummy: true,
                x: 100,
                y: 900
            }, {}));
        } else {
            document.getElementById("sideDisplay").innerHTML = "";
            document.getElementById("sideDisplay").style.display = "none";
            if (gameData.map.name) {
                document.getElementById("mapName").style.display = "block";
                spawnLocations = buildMap(gameData.map.name, gameData.map.noBeacons);
                if (!gameData.spawnPoints) {
                    spawnLocations = undefined;
                }
                if (gameData.bossName) {
                    enemies.push(new enemy(exterminationEnemies.find(e => e.name == gameData.bossName), gameData.bossModifiers || {}));
                }
            } else {
                mapInfo.x = gameData.map.x;
                mapInfo.y = gameData.map.y;
            }
            player.exterminationData = { ...gameData };
            player.exterminationData.indx = gameDataIndx;
        }
        setUpPlayersData(gameMode, spawnLocations);
        resize();
    }
    document.getElementById("goBackToHanger").onclick = function () {
        document.getElementById("money3Display").style.display = "none";
        document.getElementById("hangerUI").append(document.getElementById("money3Display"));
        document.getElementById("hangerUI").style.display = "block";
        document.getElementById("sideDisplay").style.display = "block";
        document.getElementById("goToBattle").style.display = "block";
        document.getElementById("gameModesDisplay").style.display = "none";
        document.getElementById("sideDisplay").innerHTML = "";
        this.style.display = "none";
    }
    function enterBarForShape(type, shape) {
        let text = "";
        let Shape = shapeData.find(item => item.name == shape.name);
        let maxwidth = window.innerWidth >= 1442 ? 500 : window.innerWidth >= 1374 ? 450 : window.innerWidth >= 1311 ? 400 : window.innerWidth >= 1245 ? 350 : window.innerWidth >= 1182 ? 300 : 250;
        maxwidth += 281.25;
        if (type == "health") {
            let maxhealth = Shape.healthData.base;
            for (let i = 0; i < Shape.healthData.level.length; i++) {
                maxhealth += Shape.healthData.level[i];
            }
            let MK1 = maxhealth;
            if (!shape.titan) maxhealth *= 1.2;
            let MK2 = maxhealth;
            if (!shape.titan) maxhealth *= 1.05;
            let indexAdjust = ((shape.health / maxhealth) * maxwidth) / maxwidth;
            let indexAdjusted = (((shape.health + (shape.level == 13 ? (maxhealth - MK2) : shape.level == 12 ? (MK2 - MK1) : Shape.healthData.level[shape.level])) / maxhealth) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Health: ${abbreviateNumber(shape.health)}
            <div style="display: ${Shape.healthData.level[shape.level] ? "block" : shape.level == 13 ? "block" : shape.level == 12 ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${shape.titan ? abbreviateNumber(Shape.healthData.level[shape.level]) : shape.level == 13 ? abbreviateNumber(maxhealth - MK2) : shape.level == 12 ? abbreviateNumber(MK2 - MK1) : abbreviateNumber(Shape.healthData.level[shape.level])}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "additional health norm" && Shape.additionalHealthData) {
            let maxhealth = Shape.additionalHealthData.base;
            for (let i = 0; i < Shape.additionalHealthData.level.length; i++) {
                maxhealth += Shape.additionalHealthData.level[i];
            }
            let indexAdjust = ((shape.additionalHealth / maxhealth) * maxwidth) / maxwidth;
            let indexAdjusted = (((shape.additionalHealth + Shape.healthData.level[shape.level]) / maxhealth) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Additional Health: ${abbreviateNumber(shape.additionalHealth)}
            <div style="display: ${Shape.additionalHealthData.level[shape.level] ? "block" : shape.level == 13 ? "block" : shape.level == 12 ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${abbreviateNumber(Shape.additionalHealthData.level[shape.level])}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "speed") {
            let maxspeed = Shape.speed;
            for (let i = 0; i < Shape.speedLevel.length; i++) {
                maxspeed += Shape.speedLevel[i];
            }
            let Mk1 = Mk2 = maxspeed;
            let indexAdjust = ((shape.speed / maxspeed) * maxwidth) / maxwidth;
            let indexAdjusted = (((shape.speed + (shape.level == 13 ? (maxspeed - Mk2) : shape.level == 12 ? (Mk2 - Mk1) : Shape.speedLevel[shape.level])) / maxspeed) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Speed: ${Math.round(shape.speed * 1e6) / 1e3}
            <div style="display: ${Shape.speedLevel[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Math.round(Shape.speedLevel[shape.level] * 1e6) / 1e3}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "ability damage" && shape.abilities.find(e => e.dmg)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (ability.dmg) {
                    let maxspeed = parent.damageData.base;
                    for (let i = 0; i < parent.damageData.level.length; i++) {
                        maxspeed += parent.damageData.level[i];
                    }
                    let MK1 = maxspeed;
                    if (!shape.titan) maxspeed *= 1.2;
                    let MK2 = maxspeed;
                    if (!shape.titan) maxspeed *= 1.05;
                    let indexAdjust = ((ability.dmg / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.dmg + (shape.level == 13 ? maxspeed - MK2 : shape.level == 12 ? MK2 - MK1 : parent.damageData.level[shape.level])) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Damage <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${abbreviateNumber(ability.dmg)}
                    <div style="display: ${parent.damageData.level[shape.level] ? "block" : shape.level == 13 ? "block" : shape.level == 12 ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${shape.titan ? abbreviateNumber(parent.damageData.level[shape.level]) : shape.level == 13 ? abbreviateNumber(maxspeed - MK2) : shape.level == 12 ? abbreviateNumber(MK2 - MK1) : abbreviateNumber(parent.damageData.level[shape.level])}
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "shield hp" && shape.baseShielding) {
            let maxspeed = Shape.shieldData.base;
            for (let i = 0; i < Shape.shieldData.level.length; i++) {
                maxspeed += Shape.shieldData.level[i];
            }
            let MK1 = maxspeed;
            if (!shape.titan) maxspeed *= 1.2;
            let Mk2 = maxspeed;
            if (!shape.titan) maxspeed *= 1.05;
            let indexAdjust = ((shape.baseShielding.health / maxspeed) * maxwidth) / maxwidth;
            let indexAdjusted = (((shape.baseShielding.health + (shape.level == 13 ? maxspeed - Mk2 : shape.level == 12 ? Mk2 - MK1 : Shape.shieldData.level[shape.level])) / maxspeed) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Shield Durability: ${abbreviateNumber(shape.baseShielding.health)}
            <div style="display: ${Shape.shieldData.level[shape.level] ? "block" : shape.level == 13 ? "block" : shape.level == 12 ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${shape.titan ? abbreviateNumber(Shape.shieldData.level[shape.level]) : shape.level == 13 ? abbreviateNumber(maxspeed - Mk2) : shape.level == 12 ? abbreviateNumber(Mk2 - MK1) : abbreviateNumber(Shape.shieldData.level[shape.level])}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "built-in defense points" && Shape.builtInDefensePointsData) {
            let maxspeed = Shape.builtInDefensePointsData.base;
            for (let i = 0; i < Shape.builtInDefensePointsData.level.length; i++) {
                maxspeed += Shape.builtInDefensePointsData.level[i];
            }
            let indexAdjust = ((shape.builtInDefensePoints / maxspeed) * maxwidth) / maxwidth;
            let indexAdjusted = (((shape.builtInDefensePoints + Shape.builtInDefensePointsData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Defense Points: ${shape.builtInDefensePoints}
            <div style="display: ${Shape.builtInDefensePointsData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Shape.builtInDefensePointsData.level[shape.level]}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "ability dot damage" && shape.abilities.find(e => e.dotDamage)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (ability.dotDamage) {
                    let maxspeed = parent.dotData.base;
                    for (let i = 0; i < parent.dotData.level.length; i++) {
                        maxspeed += parent.dotData.level[i];
                    }
                    let MK1 = maxspeed;
                    if (!shape.titan) maxspeed *= 1.2;
                    let MK2 = maxspeed;
                    if (!shape.titan) maxspeed *= 1.05;
                    let indexAdjust = ((ability.dotDamage / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.dotDamage + (shape.level == 13 ? maxspeed - MK2 : shape.level == 12 ? MK2 - MK1 : parent.dotData.level[shape.level])) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability DoT Damage <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${abbreviateNumber(ability.dotDamage)}
                    <div style="display: ${parent.dotData.level[shape.level] ? "block" : shape.level == 13 ? "block" : shape.level == 12 ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${shape.titan ? abbreviateNumber(parent.dotData.level[shape.level]) : shape.level == 13 ? abbreviateNumber(maxspeed - MK2) : shape.level == 12 ? abbreviateNumber(MK2 - MK1) : abbreviateNumber(parent.dotData.level[shape.level])}
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "ashield hp" && shape.abilities.find(e => e.shieldHp)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (ability.shieldHp) {
                    let maxspeed = parent.shieldHpData.base;
                    for (let i = 0; i < parent.shieldHpData.level.length; i++) {
                        maxspeed += parent.shieldHpData.level[i];
                    }
                    let MK1 = maxspeed;
                    if (!shape.titan) maxspeed *= 1.2;
                    let MK2 = maxspeed;
                    if (!shape.titan) maxspeed *= 1.05;
                    let indexAdjust = ((ability.shieldHp / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.shieldHp + (shape.level == 13 ? maxspeed - MK2 : shape.level == 12 ? MK2 - MK1 : parent.shieldHpData.level[shape.level])) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Shield Durability <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${abbreviateNumber(ability.shieldHp)}
                    <div style="display: ${parent.shieldHpData.level[shape.level] ? "block" : shape.level == 13 ? "block" : shape.level == 12 ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${shape.titan ? abbreviateNumber(parent.shieldHpData.level[shape.level]) : shape.level == 13 ? abbreviateNumber(maxspeed - MK2) : shape.level == 12 ? abbreviateNumber(MK2 - MK1) : abbreviateNumber(parent.shieldHpData.level[shape.level])}
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "healing aura" && Shape.healingAuraData) {
            let maxhealth = Shape.healingAuraData.base;
            for (let i = 0; i < Shape.healingAuraData.level.length; i++) {
                maxhealth += Shape.healingAuraData.level[i];
            }
            let MK1 = maxhealth;
            if (!shape.titan) maxhealth *= 1.2;
            let MK2 = maxhealth;
            if (!shape.titan) maxhealth *= 1.05;
            let indexAdjust = ((shape.healingAura / maxhealth) * maxwidth) / maxwidth;
            let indexAdjusted = (((shape.healingAura + (shape.level == 13 ? (maxhealth - MK2) : shape.level == 12 ? (MK2 - MK1) : Shape.healingAuraData.level[shape.level])) / maxhealth) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Healing Aura Power: ${abbreviateNumber(shape.healingAura)}
            <div style="display: ${Shape.healingAuraData.level[shape.level] ? "block" : shape.level == 13 ? "block" : shape.level == 12 ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${shape.titan ? abbreviateNumber(Shape.healingAuraData.level[shape.level]) : shape.level == 13 ? abbreviateNumber(maxhealth - MK2) : shape.level == 12 ? abbreviateNumber(MK2 - MK1) : abbreviateNumber(Shape.healingAuraData.level[shape.level])}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "lasting time" && Shape.abilities && Shape.abilities.find(e => e.lastingTimeData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.lastingTimeData) {
                    let maxspeed = parent.lastingTimeData.base;
                    for (let i = 0; i < parent.lastingTimeData.level.length; i++) {
                        maxspeed += parent.lastingTimeData.level[i];
                    }
                    let indexAdjust = ((ability.lastingTime / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.lastingTime + parent.lastingTimeData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Duration <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${ability.lastingTime / 1000} sec
                    <div style="display: ${parent.lastingTimeData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${parent.lastingTimeData.level[shape.level] / 1000} sec
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "defense points ability" && Shape.abilities && Shape.abilities.find(e => e.abilityDefensePointsData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.abilityDefensePointsData) {
                    let maxspeed = parent.abilityDefensePointsData.base;
                    for (let i = 0; i < parent.abilityDefensePointsData.level.length; i++) {
                        maxspeed += parent.abilityDefensePointsData.level[i];
                    }
                    let indexAdjust = ((ability.abilityDefensePoints / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.abilityDefensePoints + parent.abilityDefensePointsData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability ${ability.defensePointToReflector ? "Reflector Blocked (In Defense Points)" : "Defense Points"} <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${ability.abilityDefensePoints}
                    <div style="display: ${parent.abilityDefensePointsData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${parent.abilityDefensePointsData.level[shape.level]}
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "abilityHealthMulti" && Shape.abilities && Shape.abilities.find(e => e.abilityHealthMultiData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.abilityHealthMultiData) {
                    let maxspeed = parent.abilityHealthMultiData.base;
                    for (let i = 0; i < parent.abilityHealthMultiData.level.length; i++) {
                        maxspeed += parent.abilityHealthMultiData.level[i];
                    }
                    let indexAdjust = ((ability.abilityHealthMulti / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.abilityHealthMulti + parent.abilityHealthMultiData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Health Multiplier <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${ability.abilityHealthMulti * 100}%
                    <div style="display: ${parent.abilityHealthMultiData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${parent.abilityHealthMultiData.level[shape.level] * 100}%
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "ability effect acc" && Shape.abilities && Shape.abilities.find(e => e.effectIncreaseData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.effectIncreaseData) {
                    let maxspeed = parent.effectIncreaseData.base;
                    for (let i = 0; i < parent.effectIncreaseData.level.length; i++) {
                        maxspeed += parent.effectIncreaseData.level[i];
                    }
                    let indexAdjust = ((ability.effectIncrease / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.effectIncrease + parent.effectIncreaseData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Effect Accumulation <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${ability.effectIncrease * 100}%
                    <div style="display: ${parent.effectIncreaseData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${parent.effectIncreaseData.level[shape.level] * 100}%
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "ability suppression" && Shape.abilities && Shape.abilities.find(e => e.suppressionPowerData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.suppressionPowerData) {
                    let maxspeed = parent.suppressionPowerData.base;
                    for (let i = 0; i < parent.suppressionPowerData.level.length; i++) {
                        maxspeed += parent.suppressionPowerData.level[i];
                    }
                    let indexAdjust = ((ability.suppressionPower / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.suppressionPower + parent.suppressionPowerData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Suppression Power <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${Math.round(ability.suppressionPower * 1e3) / 10}%
                    <div style="display: ${parent.suppressionPowerData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${parent.suppressionPowerData.level[shape.level] * 100}%
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "ability healing power" && Shape.abilities && Shape.abilities.find(e => e.healingPowerData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.healingPowerData) {
                    let maxspeed = parent.healingPowerData.base;
                    for (let i = 0; i < parent.healingPowerData.level.length; i++) {
                        maxspeed += parent.healingPowerData.level[i];
                    }
                    let indexAdjust = ((ability.healingPower / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.healingPower + parent.healingPowerData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Healing Power <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${abbreviateNumber(ability.healingPower)}
                    <div style="display: ${parent.healingPowerData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${abbreviateNumber(parent.healingPowerData.level[shape.level])}
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "additionalHealthData" && Shape.abilities && Shape.abilities.find(e => e.additionalHealthData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.additionalHealthData) {
                    let maxspeed = parent.additionalHealthData.base;
                    for (let i = 0; i < parent.additionalHealthData.level.length; i++) {
                        maxspeed += parent.additionalHealthData.level[i];
                    }
                    let indexAdjust = ((ability.additionalHealth / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.additionalHealth + parent.additionalHealthData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Additional Health <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${abbreviateNumber(ability.additionalHealth)}
                    <div style="display: ${parent.additionalHealthData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${abbreviateNumber(parent.additionalHealthData.level[shape.level])}
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "executionThresholdData" && Shape.abilities && Shape.abilities.find(e => e.executionThresholdData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.executionThresholdData) {
                    let maxspeed = parent.executionThresholdData.base;
                    for (let i = 0; i < parent.executionThresholdData.level.length; i++) {
                        maxspeed += parent.executionThresholdData.level[i];
                    }
                    let indexAdjust = ((ability.executionThreshold / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.executionThreshold + parent.executionThresholdData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Execution Threshold <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${(ability.executionThreshold * 100)}%
                    <div style="display: ${parent.executionThresholdData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${(parent.executionThresholdData.level[shape.level] * 100)}%
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "effectAccumulationData" && Shape.abilities && Shape.abilities.find(e => e.effectAccumulationData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.effectAccumulationData) {
                    let maxspeed = parent.effectAccumulationData.base;
                    for (let i = 0; i < parent.effectAccumulationData.level.length; i++) {
                        maxspeed += parent.effectAccumulationData.level[i];
                    }
                    let indexAdjust = ((ability.effectAccumulation / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.effectAccumulation + parent.effectAccumulationData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Effect Accumulation <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${ability.effectAccumulation}
                    <div style="display: ${parent.effectAccumulationData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${parent.effectAccumulationData.level[shape.level]}
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "healingPercent" && Shape.abilities && Shape.abilities.find(e => e.healingPercentData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.healingPercentData) {
                    let maxspeed = parent.healingPercentData.base;
                    for (let i = 0; i < parent.healingPercentData.level.length; i++) {
                        maxspeed += parent.healingPercentData.level[i];
                    }
                    let indexAdjust = ((ability.healingPercent / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.healingPercent + parent.healingPercentData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Repair Power <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${(ability.healingPercent * 100)}%
                    <div style="display: ${parent.healingPercentData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${(parent.healingPercentData.level[shape.level] * 100)}%
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "healingMulti" && Shape.healingMultiData) {
            let maxspeed = Shape.healingMultiData.base;
            for (let i = 0; i < Shape.healingMultiData.level.length; i++) {
                maxspeed += Shape.healingMultiData.level[i];
            }
            let indexAdjust = ((shape.healingMulti / maxspeed) * maxwidth) / maxwidth;
            let indexAdjusted = (((shape.healingMulti + Shape.healingMultiData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Healing Effectiveness: ${shape.healingMulti * 100}%
            <div style="display: ${Shape.healingMultiData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Shape.healingMultiData.level[shape.level] * 100}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "ability effect duration" && Shape.abilities && Shape.abilities.find(e => e.abilityEffectDurationData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.abilityEffectDurationData) {
                    let maxspeed = parent.abilityEffectDurationData.base;
                    for (let i = 0; i < parent.abilityEffectDurationData.level.length; i++) {
                        maxspeed += parent.abilityEffectDurationData.level[i];
                    }
                    let indexAdjust = ((ability.abilityEffectDuration / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.abilityEffectDuration + parent.abilityEffectDurationData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Duration <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${ability.abilityEffectDuration / 1000} sec
                    <div style="display: ${parent.abilityEffectDurationData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${parent.abilityEffectDurationData.level[shape.level] / 1000} sec
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "healingPercent" && Shape.abilities && Shape.abilities.find(e => e.damageIncreaseData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.damageIncreaseData) {
                    let maxspeed = parent.damageIncreaseData.base;
                    for (let i = 0; i < parent.damageIncreaseData.level.length; i++) {
                        maxspeed += parent.damageIncreaseData.level[i];
                    }
                    let indexAdjust = ((ability.damageIncrease / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.damageIncrease + parent.damageIncreaseData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Damage Increase <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${(ability.damageIncrease * 100)}%
                    <div style="display: ${parent.damageIncreaseData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${(parent.damageIncreaseData.level[shape.level] * 100)}%
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "durabilityLimitData" && Shape.abilities && Shape.abilities.find(e => e.durabilityLimitData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.durabilityLimitData) {
                    let maxspeed = parent.durabilityLimitData.base;
                    for (let i = 0; i < parent.durabilityLimitData.level.length; i++) {
                        maxspeed += parent.durabilityLimitData.level[i];
                    }
                    let indexAdjust = ((ability.durabilityLimit / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.durabilityLimit + parent.durabilityLimitData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Durability Bonus Limit <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${abbreviateNumber(ability.durabilityLimit)}
                    <div style="display: ${parent.durabilityLimitData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${abbreviateNumber(parent.durabilityLimitData.level[shape.level])}
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        } else if (type == "deathmark" && Shape.abilities && Shape.abilities.find(e => e.deathmarkData)) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let parent = Shape.abilities[i];
                let ability = shape.abilities[i];
                if (parent.deathmarkData) {
                    let maxspeed = parent.deathmarkData.base;
                    for (let i = 0; i < parent.deathmarkData.level.length; i++) {
                        maxspeed += parent.deathmarkData.level[i];
                    }
                    let indexAdjust = ((ability.deathmark / maxspeed) * maxwidth) / maxwidth;
                    let indexAdjusted = (((ability.deathmark + parent.deathmarkData.level[shape.level]) / maxspeed) * maxwidth) / maxwidth;
                    text += `
                    <div style="position: relative; width: ${maxwidth}px;">
                    Ability Deathmark Power <span style="color: ${tierColor({ tier: i })}">(#${i + 1})</span>: ${(ability.deathmark * 100)}%
                    <div style="display: ${parent.deathmarkData.level[shape.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
                    +${(parent.deathmarkData.level[shape.level] * 100)}%
                    </div>
                    </div>
                    <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                    </div>
                    <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                    </div>
                    </div>
                    `;
                }
            }
        }
        return text;
    }
    var text = [];
    var textIndex = 0;
    function addText(x, y, value, life, color) {
        if (!settingToggles.dmgHealText) return;
        value = Math.abs(value);
        let dirs = [-0.78, -2.34, -0.39, -1.17, -1.95];
        let hi = text.find(e => color == e.color && dist({ x, y }, e) <= 80);
        if (hi) {
            hi.value += value;
            if (hi.stroke == null) hi.stroke = 0;
            hi.stroke += 5;
        } else {
            text.push({
                x: x,
                y: y,
                value: value,
                dir: dirs[textIndex % 5],
                life: life,
                color: color
            });
        }
        textIndex++;
    }
    function upgradeShape(shape, noEz) {
        let Shape = shapeData.find(item => item.name == shape.name);
        let healthIncrease = Shape.healthData.level[shape.level];
        if (shape.titan) {
            if (healthIncrease) {
                shape.health += healthIncrease;
                shape.maxhealth += healthIncrease;
            }
            let speedIncrease = Shape.speedLevel[shape.level];
            if (speedIncrease) shape.speed += speedIncrease;
        } else {
            if (shape.level < 12) {
                shape.sellPrice += sliverUpgradesByTier[shape.tier].shapes[shape.level] * .75;
                shape.health += healthIncrease;
                shape.maxhealth += healthIncrease;
                let speedIncrease = Shape.speedLevel[shape.level];
                shape.speed += speedIncrease;
            } else {
                shape.health *= shape.level == 13 ? 1.05 : 1.2;
                shape.maxhealth *= shape.level == 13 ? 1.05 : 1.2;
            }
        }
        if (shape.abilities) {
            for (let i = 0; i < shape.abilities.length; i++) {
                let ability = shape.abilities[i];
                let allFather = Shape.abilities[i];
                if (ability.shieldHp) {
                    let increase = allFather.shieldHpData.level[shape.level];
                    if (shape.level < 12 || shape.titan) {
                        ability.shieldHp += increase;
                    } else {
                        ability.shieldHp *= shape.level == 13 ? 1.05 : 1.2;
                    }
                }
                if (shape.level < 12 || shape.titan) {
                    if (allFather.healingPercentData) {
                        let increase = allFather.healingPercentData.level[shape.level];
                        ability.healingPercent += increase;
                        ability.healingPercent = Math.round(ability.healingPercent * 1e3) / 1e3;
                    }
                    if (allFather.damageIncreaseData) {
                        let increase = allFather.damageIncreaseData.level[shape.level];
                        ability.damageIncrease += increase;
                        ability.damageIncrease = Math.round(ability.damageIncrease * 1e3) / 1e3;
                    }
                    if (allFather.abilityEffectDurationData) {
                        let increase = allFather.abilityEffectDurationData.level[shape.level];
                        ability.abilityEffectDuration += increase;
                    }
                    if (allFather.effectAccumulationData) {
                        let increase = allFather.effectAccumulationData.level[shape.level];
                        ability.effectAccumulation += increase;
                    }
                    if (allFather.deathmarkData) {
                        let increase = allFather.deathmarkData.level[shape.level];
                        ability.deathmark += increase;
                        ability.deathmark = Math.round(ability.deathmark * 1e3) / 1e3;
                    }
                    if (allFather.executionThresholdData) {
                        let increase = allFather.executionThresholdData.level[shape.level];
                        ability.executionThreshold += increase;
                    }
                    if (allFather.durabilityLimitData) {
                        let increase = allFather.durabilityLimitData.level[shape.level];
                        ability.durabilityLimit += increase;
                    }
                    if (allFather.additionalHealthData) {
                        let increase = allFather.additionalHealthData.level[shape.level];
                        ability.additionalHealth += increase;
                    }
                    if (allFather.healingPowerData) {
                        let increase = allFather.healingPowerData.level[shape.level];
                        ability.healingPower += increase;
                    }
                    if (allFather.suppressionPowerData) {
                        let increase = allFather.suppressionPowerData.level[shape.level];
                        ability.suppressionPower += increase;
                        ability.suppressionPower = Math.round(ability.suppressionPower * 1e3) / 1e3;
                    }
                    if (allFather.effectIncreaseData) {
                        let increase = allFather.effectIncreaseData.level[shape.level];
                        ability.effectIncrease += increase;
                        ability.effectIncrease = Math.round(ability.effectIncrease * 1e3) / 1e3;
                    }
                    if (allFather.abilityHealthMultiData) {
                        let increase = allFather.abilityHealthMultiData.level[shape.level];
                        ability.abilityHealthMulti += increase;
                        ability.abilityHealthMulti = Math.round(ability.abilityHealthMulti * 1e3) / 1e3;
                    }
                    if (allFather.lastingTimeData) {
                        let increase = allFather.lastingTimeData.level[shape.level];
                        ability.lastingTime += increase;
                    }
                    if (allFather.abilityDefensePointsData) {
                        let increase = allFather.abilityDefensePointsData.level[shape.level];
                        ability.abilityDefensePoints += increase;
                    }
                }
                if (ability.dmg) {
                    let increase = allFather.damageData.level[shape.level];
                    if (shape.level < 12 || shape.titan) {
                        ability.dmg += increase;
                    } else {
                        ability.dmg *= shape.level == 13 ? 1.05 : 1.2;
                    }
                }
                if (ability.dotDamage) {
                    let increase = allFather.dotData.level[shape.level];
                    if (shape.level < 12 || shape.titan) {
                        ability.dotDamage += increase;
                    } else {
                        ability.dotDamage *= shape.level == 13 ? 1.05 : 1.2;
                    }
                }
            }
        }
        if (Shape.additionalHealthData) {
            let increase = Shape.additionalHealthData.level[shape.level];
            if (increase) {
                shape.additionalHealth += increase;
            }
        }
        if (Shape.healingAuraData) {
            if (shape.level < 12) {
                let increase = Shape.healingAuraData.level[shape.level];
                shape.healingAura += increase;
            } else {
                shape.healingAura *= shape.level == 13 ? 1.05 : 1.2;
            }
        }
        if (Shape.healingMultiData) {
            let increase = Shape.healingMultiData.level[shape.level];
            if (increase) {
                shape.healingMulti += increase;
                shape.healingMulti = Math.round(shape.healingMulti * 1e3) / 1e3;
            }
        }
        if (Shape.builtInDefensePointsData) {
            let increase = Shape.builtInDefensePointsData.level[shape.level];
            if (increase) shape.builtInDefensePoints += increase;
        }
        if (shape.baseShielding) {
            if (shape.level < 12 || shape.titan) {
                let increase = Shape.shieldData.level[shape.level];
                shape.baseShielding.health += increase;
            } else {
                shape.baseShielding.health *= shape.level == 13 ? 1.05 : 1.2;
            }
        }
        shape.level++;
        if (shape.slot != null && !noEz) {
            document.getElementById("slot" + shape.slot).click();
            document.getElementById("upgradeShape").click();
        }
        if (!noEz) updateSlots();
        if (!noEz) saveGameData();
    }
    class microchip {
        constructor(data, ownerSID = undefined, slot = undefined) {
            this.owner = ownerSID;
            this.slot = slot;
            this.name = data.name;
            this.desc = data.desc;
            this.main = data.main;
            this.fontSize = data.fontSize;
            this.imageSource = data.imageSource;
            this.cantUseAbility = data.cantUseAbility;
            this.healthIncrease = data.healthIncreaseData ? data.healthIncreaseData[0] : data.healthIncrease;
            this.dmgIncrease = data.dmgIncreaseData ? data.dmgIncreaseData[0] : data.dmgIncrease;
            this.speedIncrease = data.speedIncreaseData ? data.speedIncreaseData[0] : data.speedIncrease;
            this.mechanicHeal = data.mechanicHealData ? data.mechanicHealData[0] : data.mechanicHeal;
            this.onKillDefense = data.onKillDefenseData ? data.onKillDefenseData[0] : data.onKillDefense;
            this.onKillSpeed = data.onKillSpeedData ? data.onKillSpeedData[0] : data.onKillSpeed;
            this.onLowDefense = data.onLowDefenseData ? data.onLowDefenseData[0] : data.onLowDefense;
            this.onLowSpeed = data.onLowSpeedData ? data.onLowSpeedData[0] : data.onLowSpeed;
            this.onAbilityEndFix = data.onAbilityEndFixData ? data.onAbilityEndFixData[0] : data.onAbilityEndFix;
            this.extraShieldHealth = data.extraShieldHealthData ? data.extraShieldHealthData[0] : data.extraShieldHealth;
            this.onAbilityUseFix = data.onAbilityUseFixData ? data.onAbilityUseFixData[0] : data.onAbilityUseFix;
            this.extraAbilityDamage = data.extraAbilityDamageData ? data.extraAbilityDamageData[0] : data.extraAbilityDamage;
            this.onAbilityUseDefense = data.onAbilityUseDefenseData ? data.onAbilityUseDefenseData[0] : data.onAbilityUseDefense;
            this.onAbilityUseAttack = data.onAbilityUseAttackData ? data.onAbilityUseAttackData[0] : data.onAbilityUseAttack;
            this.onKillHeal = data.onKillHealData ? data.onKillHealData[0] : data.onKillHeal;
            this.onAbilityUseSpeed = data.onAbilityUseSpeedData ? data.onAbilityUseSpeedData[0] : data.onAbilityUseSpeed;
            this.legendChip = data.legendChip;
            this.needShield = data.needShield;
            this.needAbility = data.needAbility;
            this.level = 0;
        }
    }
    class pilot {
        constructor(data, ownerSID) {
            this.name = data.name;
            this.tier = data.tier;
            this.industryName = data.industryName;
            this.story = [...data.story];
            this.owner = ownerSID;
            this.level = 1;
            this.skills = [];
            this.titan = data.titan;
            this.hasLegendarySkills = 0;
            if (data.legendarySkill) {
                if (data.legendarySkill[0]) {
                    this.hasLegendarySkills = data.legendarySkill.length;
                    for (let i = 0; i < data.legendarySkill.length; i++) {
                        this.skills.push({ ...data.legendarySkill[i] });
                        this.skills[i].level = 3;
                        this.skills[i].slot = i;
                        this.skills[i].legendary = true;
                        this.hasLegendarySkill = true;
                    }
                } else {
                    this.hasLegendarySkills = 1;
                    this.skills.push({ ...data.legendarySkill });
                    this.skills[0].level = 3;
                    this.skills[0].slot = 0;
                    this.skills[0].legendary = true;
                    this.hasLegendarySkill = true;
                }
            }
            if (this.titan) {
                this.maxLevel = 10;
            } else {
                this.maxLevel = 7;
            }
        }
    }
    var pilotTierCost = [0, 20e3, 0, 45e3, 205e3];
    var pilotsData = [{
        tier: 1,
        name: "Everest Oded",
        industryName: "Hexagon",
        story: [
            `Everest Oded's determination to become the greatest pilot wasn't unheard of. Many inspiring pilots had walked down his path, only to meet failure. Everest, however, was aware that, while he shared the same path, he understood the challenges ahead-at least, he believed he did.`,
            `On Jan 33, 102, he was summoned to receive a reward from a high-ranking member of the Industry. Seizing the opportunity to advance in the Industry, he brought his best-equipped shape. However, upon arrival, he was given only a rundown shape. "What a pity," he thought, but little did he know that this unexpected twist would lead to an unforeseen test of his skills and resourcefulness.`,
            `"Let's at least repair it," he thought. The sound of banging metal echoed from his pod. Repairing the shape wasn't difficult for Everest; he finished in a matter of minutes. Adding extra armor plating was also no problem for him. When Everest completed the repair, the modifications he made exceeded its normal boundaries. He jumped into the cockpit already to use the newly repaired modified shape.`,
            `Jan 67, 102. Everest was under fire. "What a fucking surprise", he thought. He always does this to himself, always getting into situations where he has to fight multiple enemy shapes. Shots fired, he ejects from his current shape and enters into the modified one.`,
            `The engines roared. Everest quickly runs into the center of the onslaught. He exchanges shots with the enemies. One of them goes down, then the other. Minimal damage received. "That shape seems to be a lot stronger than the original," one of his many allies said. "I know," he responds, with the biggest smile across his face.`
        ],
        legendarySkill: {
            name: "Everest's Knowhow",
            main: "healthIncrease",
            imageSource: "./images/modules/armor_plating.png",
            desc: "Increases the durability of the shape.",
            healthIncrease: .1
        }
    }, {
        tier: 3,
        name: "Mosi Kristoffer",
        industryName: "Circle",
        story: [
            `"You should change your shape," someone said. That was a phrase he despised. Yes, his shape wasn't the newest top-end model anymore, but it still got the job done. Running into the center of the onslaught and getting out, his favorite shape could still handle it without much difficulty.`
        ],
        legendarySkill: {
            name: "Mosi's Stampede",
            main: "stampedeV2",
            onlyFor: "Tan Circle",
            imageSource: "./images/abilities/full_action.png",
            desc: "Tan Circle gains defense points for every DoT effect it gains during its ability.",
            stampedeV2: 1
        }
    }, {
        tier: 3,
        name: "Eleanor Thorne",
        story: [],
        industryName: "Heptagon",
        legendarySkill: {
            name: "Thorne's Precision",
            main: "dmgPercentage",
            onlyFor: "Purple Heptagon",
            imageSource: "./images/modules/nuclear_reactor.png",
            desc: "Purple Heptagon's ability deals additional damage percentage.",
            dmgPercentage: .2
        }
    }, {
        tier: 3,
        name: "Elijah Forge",
        story: [],
        industryName: "Hexagon",
        legendarySkill: {
            name: "Forge's Breakthrough",
            main: "chargeIncrease",
            onlyFor: "Cyan Hexagon",
            imageSource: "./images/abilities/shapeshift.png",
            desc: "Cyan Hexagon has increased ability charges and ability cooldown is decreased by 20%.",
            chargeIncrease: 1
        }
    }, {
        tier: 3,
        name: "Caleb Sterling",
        industryName: "Circle",
        story: [],
        legendarySkill: {
            name: "Caleb's Knowledge",
            main: "mechanicHeal",
            onlyFor: "Orange Circle",
            imageSource: "./images/modules/self_fix_unit.png",
            desc: "Orange Circle repairs a large portion of its durability every second.",
            mechanicHeal: .05
        }
    }, {
        tier: 3,
        name: "Sebastian Wren",
        industryName: "Pentagon",
        story: [],
        legendarySkill: {
            name: "Sebastian's Fortitude",
            main: "additionalHealth",
            onlyFor: "Light Blue Heptagon",
            imageSource: "./images/abilities/full_action.png",
            desc: "Light Blue Heptagon gains additional health during flight.",
            additionalHealth: 175e3
        }
    }, {
        tier: 3,
        name: "Indra",
        story: [],
        industryName: "Hexagon",
        legendarySkill: {
            name: "Indra's Prowess",
            main: "chargeIncrease",
            onlyFor: "Magenta Hexagon",
            imageSource: "./images/abilities/shapeshift.png",
            desc: "Magenta Hexagon has increased ability charges and gains extra defense points (50).",
            chargeIncrease: 2
        }
    }, {
        tier: 3,
        name: "Alexander Nguyen",
        story: [],
        industryName: "Pentagon",
        legendarySkill: {
            name: "Alexander's Tactics",
            main: "onAbilityUseStealth",
            onlyFor: "Dark Green Pentagon",
            imageSource: "./images/stealth.png",
            desc: "Dark Green Pentagon gains stealth for every activation of its ability.",
            onAbilityUseStealth: 2e3
        }
    }, {
        tier: 3,
        name: "Xavier Sinclair",
        industryName: "Circle",
        story: [],
        legendarySkill: {
            name: "Savage!",
            main: "abilitySpeedDecrease",
            onlyFor: "Dark Tan Circle",
            imageSource: "./images/abilities/shapeshift.png",
            desc: "Dark Tan Circle has a decreased ability cooldown.",
            abilitySpeedDecrease: .25
        }
    }, {
        tier: 3,
        name: "Xavier Howard",
        industryName: "Octagon",
        story: [],
        legendarySkill: {
            name: "Howard Brilliance!",
            main: "domainRangeIncrease",
            onlyFor: "Red Octagon",
            imageSource: "./images/abilities/shapeshift.png",
            desc: "Red Octagon has a increased domain radius and its ability deals 15% more damage.",
            domainRangeIncrease: .5,
            extraAbilityDamage: .15
        }
    }, {
        tier: 3,
        name: "Bernadette",
        industryName: "Pentagon",
        story: [],
        legendarySkill: {
            name: "Bernadette's Stamina",
            main: "healthIncrease",
            onlyFor: "Brown Pentagon",
            imageSource: "./images/modules/heavy_armor_plating.png",
            desc: "Brown Pentagon gains extra durability but loses its shield.",
            healthIncrease: .5
        }
    }, {
        tier: 3,
        name: "Alexander Davis",
        industryName: "Heptagon",
        story: [],
        legendarySkill: {
            name: "Cooling Matrix",
            main: "abilitySpeedDecrease",
            onlyFor: "Orange Heptagon",
            imageSource: "./images/abilities/shapeshift.png",
            desc: "Orange Heptagon has a decreased ability cooldown.",
            abilitySpeedDecrease: .34
        }
    }, {
        tier: 3,
        name: "Victoria",
        industryName: "Octagon",
        story: [],
        legendarySkill: {
            name: "Forcefield",
            main: "skywardV2",
            onlyFor: "White Octagon",
            imageSource: "./images/abilities/shapeshift.png",
            desc: "White Octagon has increased forcefield durability.",
            skywardV2: 3.5
        }
    }, {
        tier: 3,
        name: "Chris",
        industryName: "Triangle",
        story: [],
        legendarySkill: {
            name: "Chris's Kindliness",
            main: "chargeIncrease",
            onlyFor: "Blue Triangle",
            imageSource: "./images/abilities/shapeshift.png",
            desc: "Blue Triangle gains additional ability charges.",
            chargeIncrease: 2
        }
    }, {
        tier: 3,
        name: "B4R-0N-N3T",
        industryName: "Pentagon",
        story: [],
        legendarySkill: {
            name: "Fortification",
            main: "abilityDefenseIncrease",
            onlyFor: "Brown Pentagon",
            imageSource: "./images/modules/heavy_armor_plating.png",
            desc: "Brown Pentagon gains extra defense points during ability and gains 575% more shield durability.",
            abilityDefenseIncrease: 50,
            extraShieldHealth: 5.75
        }
    }, {
        tier: 3,
        name: "Raptor",
        industryName: "Heptagon",
        story: [],
        legendarySkill: {
            name: "EMP Blast",
            main: "cometSplashV2",
            onlyFor: "Light Gray Heptagon",
            imageSource: "./images/icons/emp.png",
            desc: "Light Gray Heptagon gains increased durability (60%) and its AoE Effect applies 6 seconds of EMP.",
            cometSplashV2: 1,
            healthIncrease: .6
        }
    }, {
        tier: 4,
        name: "Everest Oded (Titans)",
        industryName: "Hexagon",
        story: [],
        titan: true,
        legendarySkill: [{
            name: "Everest's Knowhow",
            main: "healthIncrease",
            imageSource: "./images/modules/armor_plating.png",
            desc: "Increases the durability of the titan.",
            healthIncrease: .07
        }, {
            name: "Everest's Quick Thinking",
            main: "speedIncrease",
            imageSource: {
                name: "speed"
            },
            desc: "Increases the movement speed of the titan.",
            speedIncrease: .07
        }, {
            name: "Everest's Adaptability",
            main: "abilitySpeedDecrease",
            imageSource: "./images/abilities/shapeshift.png",
            desc: "The titan has a decreased ability cooldown.",
            abilitySpeedDecrease: .1
        }]
    }, {
        tier: 4,
        name: "Chris Kristoffer (Titans: Luchador)",
        industryName: "Hexagon",
        story: [],
        titan: true,
        legendarySkill: [{
            name: "1st Factor",
            main: "healthIncrease",
            onlyFor: "Luchador",
            imageSource: "./images/modules/armor_plating.png",
            desc: "Luchador has increased durability.",
            healthIncrease: .25
        }, {
            name: "2nd Factor",
            main: "chargeIncrease",
            imageSource: "./images/abilities/shapeshift.png",
            onlyFor: "Luchador",
            desc: "Luchador's secondary ability has increased amount of total charges.",
            chargeIncrease: 2
        }, {
            name: "3rd Factor",
            main: "superMechanic",
            onlyFor: "Luchador",
            imageSource: "./images/modules/self_fix_unit.png",
            desc: "Luchador repairs a part of it's durability and gray damage each second.",
            superMechanic: .007
        }]
    }, {
        tier: 4,
        name: "Sebastian Wren (Titans: Eiffel)",
        industryName: "Pentagon",
        story: [],
        titan: true,
        legendarySkill: [{
            name: "1st Factor",
            main: "additionalHealth",
            onlyFor: "Eiffel",
            imageSource: "./images/modules/armor_plating.png",
            desc: "Eiffel has increased durability during its flight.",
            additionalHealth: 375e3
        }, {
            name: "2nd Factor",
            main: "debutDurationIncrease",
            imageSource: {
                name: "timer"
            },
            onlyFor: "Eiffel",
            desc: "Increases the duration of Eiffel's secondary ability.",
            debutDurationIncrease: 4e3
        }, {
            name: "3rd Factor",
            main: "superMechanic",
            onlyFor: "Eiffel",
            imageSource: "./images/modules/self_fix_unit.png",
            desc: "Eiffel repairs a part of it's durability and gray damage each second.",
            superMechanic: .001
        }]
    }, {
        tier: 4,
        name: "Eleanor Thorne (Titans: Bersagliere)",
        story: [],
        industryName: "Heptagon",
        titan: true,
        legendarySkill: [{
            name: "1st Factor",
            main: "shieldBreakOnDefenseBreach",
            onlyFor: "Bersagliere",
            imageSource: "./images/icons/shield_break.png",
            desc: "Bersagliere gains a shield breaking effect upon activation of its primary ability.",
            shieldBreakOnDefenseBreach: 1
        }, {
            name: "2nd Factor",
            main: "speedIncrease",
            onlyFor: "Bersagliere",
            imageSource: {
                name: "speed"
            },
            desc: "Bersagliere gains increased movement speed.",
            speedIncrease: .375
        }, {
            name: "3rd Factor",
            main: "moreDamageOnNuclearRocketShot",
            onlyFor: "Bersagliere",
            imageSource: "./images/modules/nuclear_reactor.png",
            desc: "Bersagliere gains a temporary damage bonus for every activation of its secondary ability.",
            moreDamageOnNuclearRocketShot: .15
        }]
    }, {
        tier: 4,
        name: "Caleb Sterling (Titans: Arthur)",
        industryName: "Circle",
        story: [],
        titan: true,
        legendarySkill: [{
            name: "1st Factor",
            main: "extraShieldHealth",
            onlyFor: "Arthur",
            imageSource: "./images/modules/fortifier.png",
            desc: "Arthur gains increased physical shield durability.",
            extraShieldHealth: 3.5
        }, {
            name: "2nd Factor",
            main: "speedIncrease",
            onlyFor: "Arthur",
            imageSource: {
                name: "speed"
            },
            desc: "Arthur gains increased movement speed.",
            speedIncrease: 1
        }, {
            name: "3rd Factor",
            main: "superMechanic",
            onlyFor: "Arthur",
            imageSource: "./images/modules/self_fix_unit.png",
            desc: "Arthur repairs its durability and gray damage each second.",
            superMechanic: 0.028
        }]
    }, {
        tier: 3,
        name: "R4PT0R",
        industryName: "Heptagon",
        story: [],
        legendarySkill: {
            name: "Natural Hunter",
            main: "extraAbilityDamage",
            onlyFor: "Light Gray Heptagon",
            imageSource: "./images/modules/nuclear_reactor.png",
            desc: "Light Gray Heptagon deals more ability damage and has a decreased ability cooldown. It's built-in weapons mitigate defense points as well and charge the mothership.",
            extraAbilityDamage: 1.6,
            superCometSplash: true,
            abilitySpeedDecrease: .3
        }
    }, {
        tier: 3,
        name: "Lynx",
        industryName: "Heptagon",
        story: [],
        legendarySkill: {
            name: "Hunter",
            main: "abilityDurationIncrease",
            onlyFor: "Yellow Heptagon",
            imageSource: "./images/abilities/shapeshift.png",
            desc: "Yellow Heptagon has a increased ability duration and increases forcefield durability by 45%.",
            lynxV2: true,
            abilityDurationIncrease: 2e3
        }
    }, {
        tier: 3,
        name: "Phantom",
        industryName: "Circle",
        story: [],
        legendarySkill: {
            name: "Mass Hunter",
            main: "abilityDurationIncrease",
            onlyFor: "Veronica Circle",
            imageSource: "./images/abilities/shapeshift.png",
            desc: "Yellow Heptagon has a increased ability duration and increased resistance during ability (+150 Defense Points).",
            blinkVV2: true,
            abilityDurationIncrease: 4e3
        }
    }, {
        tier: 3,
        name: "Sux",
        industryName: "Triangle",
        story: [],
        legendarySkill: {
            name: "Mastermind",
            main: "mastermindV2",
            onlyFor: "Grayish Blue Triangle",
            imageSource: "./images/icons/emp.png",
            desc: "Grayish Blue Triangle gains stealth during half of the ability and 200 defense points for the entire ability.",
            mastermindV2: 1
        }
    }];
    class skill {
        constructor(data, slot, robot) {
            this.level = 1;
            this.needTitan = data.needTitan;
            this.name = data.name;
            this.desc = data.desc;
            this.slot = slot;
            this.robotOwner = robot.name;
            this.needShield = data.needShield;
            this.main = data.main;
            this.needAbilityDmg = data.needAbilityDmg;
            this.needAbility = data.needAbility;
            this.imageSource = data.imageSource;
            this.onAbilityUseSpeed = data.onAbilityUseSpeedData ? data.onAbilityUseSpeedData[0] : data.onAbilityUseSpeed;
            this.healthIncrease = data.healthIncreaseData ? data.healthIncreaseData[0] : data.healthIncrease;
            this.dmgIncrease = data.dmgIncreaseData ? data.dmgIncreaseData[0] : data.dmgIncrease;
            this.onLowDefense = data.onLowDefenseData ? data.onLowDefenseData[0] : data.onLowDefense;
            this.onAbilityUseFix = data.onAbilityUseFixData ? data.onAbilityUseFixData[0] : data.onAbilityUseFix;
            this.speedIncrease = data.speedIncreaseData ? data.speedIncreaseData[0] : data.speedIncrease;
            this.mechanicHeal = data.mechanicHealData ? data.mechanicHealData[0] : data.mechanicHeal;
            this.onLowSpeed = data.onLowSpeedData ? data.onLowSpeedData[0] : data.onLowSpeed;
            this.onAbilityUseDefense = data.onAbilityUseDefenseData ? data.onAbilityUseDefenseData[0] : data.onAbilityUseDefense;
            this.increaseDurationOfPositiveEffects = data.increaseDurationOfPositiveEffectsData ? data.increaseDurationOfPositiveEffectsData[0] : data.increaseDurationOfPositiveEffects;
            this.extraAbilityDamage = data.extraAbilityDamageData ? data.extraAbilityDamageData[0] : data.extraAbilityDamage;
            this.extraShieldHealth = data.extraShieldHealthData ? data.extraShieldHealthData[0] : data.extraShieldHealth;
            this.getAbilityBackAtHalfHealth = data.getAbilityBackAtHalfHealth;
            if (this.getAbilityBackAtHalfHealth) {
                this.level = 4;
            }
        }
    }
    var SKILLLSKDAJIOSDJASJOIDJOISDJ = skill;
    var pilotSkillList = [{
        name: "Armor Expert",
        desc: "The shape has increased durability.",
        main: "healthIncrease",
        imageSource: "./images/modules/armor_plating.png",
        healthIncreaseData: [.02, .04, .06, .08]
    }, {
        name: "Generalist",
        desc: "The titan has increased durability, movement speed, and weapon damage output.",
        main: "healthIncrease",
        needTitan: true,
        imageSource: "./images/abilities/shapeshift.png",
        healthIncreaseData: [.008, .01, .02, .035],
        dmgIncreaseData: [.008, .01, .02, .035],
        speedIncreaseData: [.008, .01, .02, .035]
    }, {
        name: "Powerman",
        desc: "The titan has increased durability and weapon damage output.",
        main: "healthIncrease",
        needTitan: true,
        imageSource: "./images/abilities/shapeshift.png",
        healthIncreaseData: [.004, .005, .01, .0175],
        dmgIncreaseData: [.004, .005, .01, .0175]
    }, {
        name: "All Rounder",
        desc: "The titan has increased movement speed and weapon damage output.",
        main: "speedIncrease",
        needTitan: true,
        imageSource: "./images/abilities/shapeshift.png",
        speedIncreaseData: [.004, .005, .01, .0175],
        dmgIncreaseData: [.004, .005, .01, .0175]
    }, {
        name: "Master Gunsmith",
        desc: "The shape has increased weapon damage output.",
        main: "dmgIncrease",
        imageSource: "./images/modules/nuclear_reactor.png",
        dmgIncreaseData: [.012, .024, .035, .05]
    }, {
        name: "Stubborn Warrior",
        desc: "The shape has increased defense points, when it has low durability (30% or below).",
        main: "onLowDefense",
        imageSource: "./images/abilities/full_action.png",
        onLowDefenseData: [9.75, 20, 37.5, 50]
    }, {
        name: "Wonderworker",
        desc: "Upon activating its ability, the shape repairs a part of its durability.",
        main: "onAbilityUseFix",
        needAbility: true,
        imageSource: "./images/modules/self_fix_unit.png",
        onAbilityUseFixData: [.03, .05, .08, .12]
    }, {
        name: "Tough Guy",
        desc: "The robot has increased durability, but has decreased weapon damage output by 10%.",
        main: "healthIncrease",
        imageSource: "./images/modules/armor_plating.png",
        healthIncreaseData: [.06, .09, .12, .15],
        dmgIncreaseData: [-.1, -.1, -.1, -.1]
    }, {
        name: "Cautious Pilot",
        desc: "The robot has increased durability, but has decreased movement speed by 10%.",
        main: "healthIncrease",
        imageSource: "./images/modules/armor_plating.png",
        healthIncreaseData: [.06, .09, .12, .15],
        speedIncreaseData: [-.1, -.1, -.1, -.1]
    }, {
        name: "Mechanic",
        desc: "The robot repairs its durability every second.",
        main: "mechanicHeal",
        imageSource: "./images/modules/self_fix_unit.png",
        mechanicHealData: [.0025, .004, .005, .007]
    }, {
        name: "Stubborn Speedster",
        desc: "The shape has increased movement speed, when it has low durability (30% or below).",
        main: "onLowSpeed",
        imageSource: {
            name: "speed"
        },
        onLowSpeedData: [.1, .2, .3, .4]
    }, {
        name: "Defense Expert",
        desc: "The shape has increased defense points while ability is active.",
        needAbility: true,
        imageSource: "./images/abilities/full_action.png",
        main: "onAbilityUseDefense",
        onAbilityUseDefenseData: [10, 20, 35, 50]
    }, {
        name: "Road Hog",
        desc: "The shape has increased movement speed.",
        imageSource: {
            name: "speed"
        },
        main: "speedIncrease",
        speedIncreaseData: [.02, .05, .08, .12]
    }, {
        name: "Medicine Expert",
        desc: "All positive effects last longer.",
        imageSource: {
            name: "timer"
        },
        main: "increaseDurationOfPositiveEffects",
        increaseDurationOfPositiveEffectsData: [.12, .18, .25, .35]
    }, {
        name: "Thrill Seeker",
        desc: "The shape deals increased damage, but its durability is decreased by 10%.",
        imageSource: "./images/modules/nuclear_reactor.png",
        main: "dmgIncrease",
        dmgIncreaseData: [.025, .05, .1, .15],
        healthIncreaseData: [-.1, -.1, -.1, -.1]
    }, {
        name: "Thrill Hunter",
        desc: "The shape deals increased damage, but its speed is decreased by 10%.",
        imageSource: "./images/modules/nuclear_reactor.png",
        main: "dmgIncrease",
        dmgIncreaseData: [.025, .05, .1, .15],
        speedIncreaseData: [-.1, -.1, -.1, -.1]
    }, {
        name: "Spy",
        desc: "The shape has increased movement speed, but its weapon damage is decreased by 10%.",
        imageSource: {
            name: "speed"
        },
        main: "speedIncrease",
        speedIncreaseData: [.025, .05, .1, .15],
        dmgIncreaseData: [-.1, -.1, -.1, -.1]
    }, {
        name: "Destroyer",
        desc: "The shape's built-in weapons deal increased damage.",
        needAbilityDmg: true,
        imageSource: "./images/modules/nuclear_reactor.png",
        main: "extraAbilityDamage",
        extraAbilityDamageData: [.05, .07, .1, .15]
    }, {
        name: "Shield Expert",
        desc: "Increases the durability of the shape's shields.",
        imageSource: "./images/modules/armor_plating.png",
        needShield: true,
        main: "extraShieldHealth",
        extraShieldHealthData: [.05, .1, .12, .1875]
    }, {
        name: "Movement Expert",
        desc: "The ability gains increased movement speed during the ability.",
        imageSource: {
            name: "speed"
        },
        needAbility: true,
        main: "onAbilityUseSpeed",
        onAbilityUseSpeedData: [.07, .15, .25, .375]
    }, {
        name: "Speed Demon",
        desc: "The shape has increased movement speed, but its durability is decreased by 10%.",
        imageSource: {
            name: "speed"
        },
        main: "speedIncrease",
        speedIncreaseData: [.025, .05, .1, .15],
        healthIncreaseData: [-.1, -.1, -.1, -.1]
    }, {
        name: "Deft Survivor",
        desc: "The shape gains its ability or abilties (or a charge) back when it reaches 50% durability. Can only be used once, and isn't affected when leveled up.",
        main: "getAbilityBackAtHalfHealth",
        imageSource: "./images/abilities/shapeshift.png",
        needAbility: true,
        getAbilityBackAtHalfHealth: 1
    }, {
        name: "Customizing Shield Expert",
        desc: "Increases the durability of the shape's shields but decreases the shape's durability by 10%.",
        imageSource: "./images/modules/armor_plating.png",
        needShield: true,
        main: "extraShieldHealth",
        extraShieldHealthData: [.1, .15, .25, .375],
        healthIncreaseData: [-.1, -.1, -.1, -.1]
    }, {
        name: "Sacrificing Shield Expert",
        desc: "Increases the durability of the shape's shields but decreases the shape's weapon damage by 10%.",
        imageSource: "./images/modules/armor_plating.png",
        needShield: true,
        main: "extraShieldHealth",
        extraShieldHealthData: [.1, .15, .25, .375],
        dmgIncreaseData: [-.1, -.1, -.1, -.1]
    }];
    function displayActiveSkills(pilot, robot) {
        if (!pilot) return 0;
        if (!pilot.skills) return 0;
        if (robot.sid != pilot.owner) return 0;
        let active = 0;
        for (let i = 0; i < pilot.skills.length; i++) {
            let skill = pilot.skills[i];
            if (skill) {
                if (skill.onlyFor && !robot.name.includes(skill.onlyFor)) {
                } else if (skill.robotOwner != robot.name && !skill.legendary) {
                } else {
                    active++;
                }
            }
        }
        return active;
    }
    function showPilotStory(pilot) {
        let level = pilot.level || 1;
        let text = "";
        let done = false;
        for (let i = 0; i < level; i++) {
            text += pilot.story[i] || "";
            if (pilot.story[i]) text += "<br><br>";
        }
        if (level < pilot.story.length) {
            text += "Level up to read more."
        }
        return text;
    }
    function getDisplayPilotSkill(skill) {
        if (["moreDamageOnNuclearRocketShot", "superMechanic", "skywardV2", "domainRangeIncrease", "abilitySpeedDecrease", "dmgPercentage", "onAbilityUseSpeed", "extraShieldHealth", "extraAbilityDamage", "increaseDurationOfPositiveEffects", "speedIncrease", "onLowSpeed", "dmgIncrease", "mechanicHeal", "onAbilityUseFix", "healthIncrease", "dmgIncrease"].includes(skill.main)) {
            if (skill[skill.main] == .007) {
                return `0.7%`;
            } else if (skill[skill.main] == .07) {
                return `7%`;
            } else if (skill[skill.main] == .035) {
                return `3.5%`;
            } else if (skill[skill.main] == .0175) {
                return `1.75%`;
            } else if (skill[skill.main] == .028) {
                return `2.8%`;
            }
            return (skill[skill.main] * 100) + "%";
        } else if (["additionalHealth"].includes(skill.main)) {
            return abbreviateNumber(skill[skill.main]);
        } else if (["abilityDurationIncrease", "debutDurationIncrease", "onAbilityUseStealth"].includes(skill.main)) {
            return (skill[skill.main] / 1e3) + " sec";
        } else {
            return skill[skill.main];
        }
    }
    function possibleSkills(pilot, robot, s) {
        let skills = [];
        for (let i = 0; i < pilotSkillList.length; i++) {
            let skill = pilotSkillList[i];
            if (skill) {
                if (skill.needTitan && !robot.titan) {
                } else if (skill.needAbility && !robot.abilities.length) {
                } else if (skill.needAbilityDmg && (!robot.abilities.length || (robot.abilities.length && !robot.abilities.find(e => e.dmg)))) {
                } else if (skill.needShield && !robot.baseShielding) {
                } else if (!pilot.skills.find(e => !e.legendary && e.name == skill.name)) {
                    skills.push(skill);
                } else if (typeof s == "object" && skill.name == s.name) {
                    skills.push(skill);
                }
            }
        }
        if (s) {
            let tmp = [...skills];
            skills = [];
            tmp.forEach(e => {
                skills.push(new skill(e, null, robot));
            });
        }
        return skills;
    }
    function learnSkill(pilot, slot, robot, name, level = 0) {
        let skills = possibleSkills(pilot, robot);
        if (skills.length) {
            skills = skills.filter(e => e.name != name);
            let Skill = skills[Math.floor(Math.random() * skills.length)];
            let theFuckingSkill = new skill(Skill, slot, robot);
            for (let i = 0; i < level; i++) {
                upgradePilotSkill(theFuckingSkill);
            }
            pilot.skills.push(theFuckingSkill);
            doPilotStuff(robot);
            saveGameData();
        }
    }
    function showPilotSkills(pilot, width, w, addon = 0) {
        if (pilot.skills && pilot.skills.length) {
            if (w == 2 || w == 3) {
                let text = "";
                for (let i = 0; i < (w == 3 ? pilot.skills.length : (7 + addon + (pilot.hasLegendarySkill ? pilot.hasLegendarySkills : 0))); i++) {
                    let skill = w == 3 ? pilot.skills[i] : pilot.skills.find(e => e.slot == (i >= pilot.hasLegendarySkills ? i - pilot.hasLegendarySkills : i) && (i >= pilot.hasLegendarySkills ? !e.legendary : e.legendary));
                    if (skill) {
                        if (!skill.legendary) {
                            text += `
                            <div ${w == 2 ? `id="selectSkill_${skill.slot}"` : `id="chooseSkill_${i}"`} style="margin-left: 20px; cursor: pointer; margin-top: ${i == 0 ? w == 3 ? 10 : 0 : 10}px; color: #fff; position: relative; width: ${width}px; height: 60px; border-radius: 6px; background-color: rgb(255, 255, 255, .4); overflow: hidden;">
                            <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(to right, rgb(0, 0, 0, 0), ${tierColor({ tier: skill.level - 1 })});">
                            </div>
                            <div style="position: absolute; top: 5px; left: 5px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${skill.imageSource}');">
                            ${typeof skill.imageSource == "object" ? `
                            <span class="material-symbols-outlined" style="font-size: 50px; color: #fff;">
                            ${skill.imageSource.name}
                            </span>
                            ` : ""}
                            </div>
                            <div style="position: absolute; display: flex; flex-direction: column; justify-content: center; top: 0px; left: 60px; width: ${width - 50 - (getDisplayPilotSkill(skill).toString().length * 20)}px; height: 100%; overflow-y: scroll;">
                            <div style="font-size: 18px;">${skill.name} / ${skill.robotOwner}</div>
                            <div style="font-size: 12px;">${skill.desc}</div>
                            </div>
                            <div style="position: absolute; top: 13.75px; right: 5px; font-size: 24px;">
                            ${getDisplayPilotSkill(skill)}
                            </div>
                            </div>
                            `;
                        }
                    }
                }
                return text;
            } else if (w) {
                let text = "";
                for (let i = 0; i < (7 + addon + (pilot.hasLegendarySkill ? pilot.hasLegendarySkills : 0)); i++) {
                    let skill = pilot.skills.find(e => e.slot == (i >= pilot.hasLegendarySkills ? i - pilot.hasLegendarySkills : i) && (i >= pilot.hasLegendarySkills ? !e.legendary : e.legendary));
                    if (skill) {
                        if (skill.legendary) {
                            text += `
                            <div style="margin-top: ${i == 0 ? 0 : 10}px; color: #fff; position: relative; width: 100%; height: 60px; border-radius: 6px; background-color: rgb(255, 255, 255, .4); overflow: hidden;">
                            <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(to right, rgb(0, 0, 0, 0) 0%, #ffb700 30%);">
                            </div>
                            <div style="position: absolute; top: 5px; left: 5px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${skill.imageSource}');">
                            ${typeof skill.imageSource == "object" ? `
                            <span class="material-symbols-outlined" style="font-size: 50px; color: #fff;">
                            ${skill.imageSource.name}
                            </span>
                            ` : ""}
                            </div>
                            <div style="position: absolute; display: flex; flex-direction: column; justify-content: center; top: 0px; left: 60px; width: ${width - 60 - (getDisplayPilotSkill(skill).toString().length * 20)}px; height: 100%;">
                            <div style="font-size: 18px;">${skill.name}</div>
                            <div style="font-size: 12px;">${skill.desc}</div>
                            </div>
                            <div style="position: absolute; top: 13.75px; right: 5px; font-size: 24px;">
                            ${getDisplayPilotSkill(skill)}
                            </div>
                            </div>
                            `;
                        } else {
                            text += `
                            <div style="margin-top: ${i == 0 ? 0 : 10}px; color: #fff; position: relative; width: 100%; height: 60px; border-radius: 6px; background-color: rgb(255, 255, 255, .4); overflow: hidden;">
                            <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(to right, rgb(0, 0, 0, 0), ${tierColor({ tier: skill.level - 1 })});">
                            </div>
                            <div style="position: absolute; top: 5px; left: 5px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${skill.imageSource}');">
                            ${typeof skill.imageSource == "object" ? `
                            <span class="material-symbols-outlined" style="font-size: 50px; color: #fff;">
                            ${skill.imageSource.name}
                            </span>
                            ` : ""}
                            </div>
                            <div style="position: absolute; display: flex; flex-direction: column; justify-content: center; top: 0px; left: 60px; width: ${width - 235 - (getDisplayPilotSkill(skill).toString().length * 20)}px; height: 100%; overflow-y: scroll;">
                            <div style="font-size: 18px;">${skill.name} / ${skill.robotOwner}</div>
                            <div style="font-size: 12px;">${skill.desc}</div>
                            </div>
                            <div style="position: absolute; top: 13.75px; right: 175px; font-size: 24px;">
                            ${getDisplayPilotSkill(skill)}
                            </div>
                            <div id="upgradeSkill_${skill.slot}" style="${skill.level == 4 ? "" : "cursor: pointer;"} position: absolute; display: flex; flex-direction: column; justify-content: center; align-items: center; top: 5px; right: 20px; width: 140px; height: 50px; border-radius: 6px; background-color: ${skill.level == 4 ? "#808080" : "#0f0"};">
                            <div style="display: ${skill.level == 4 ? "none" : "block"};">UPGRADE</div>
                            <div style="display: ${skill.level == 4 ? "none" : "block"};">SKILL</div>
                            <div style="display: ${skill.level == 4 ? "block" : "none"};">MAXED</div>
                            </div>
                            </div>
                            `;
                        }
                    } else if (pilot.titan && (i >= pilot.hasLegendarySkills ? i - pilot.hasLegendarySkills : i) < pilot.level) {
                        text += `
                        <div id="learnSkill_${i >= pilot.hasLegendarySkills ? i - pilot.hasLegendarySkills : i}" style="cursor: pointer; margin-top: ${i == 0 ? 0 : 10}px; position: relative; width: 100%; height: 60px; border-radius: 6px; background-color: rgb(255, 255, 255, .4); overflow: hidden;">
                        <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 34px; margin-top: 10px; margin-left: 10px; width: 40px; height: 40px; border: solid; border-radius: 12px;">
                        +
                        </div>
                        <div style="display: flex; flex-direction: column; justify-content: center; position: absolute; top: 0px; left: 60px; width: ${width - 60}px; height: 100%;">
                        Ready to learn a skill
                        </div>
                        </div>
                        `;
                    } else if (!pilot.titan && i <= pilot.level) {
                        text += `
                        <div id="learnSkill_${i >= pilot.hasLegendarySkills ? i - pilot.hasLegendarySkills : i}" style="cursor: pointer; margin-top: ${i == 0 ? 0 : 10}px; position: relative; width: 100%; height: 60px; border-radius: 6px; background-color: rgb(255, 255, 255, .4); overflow: hidden;">
                        <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 34px; margin-top: 10px; margin-left: 10px; width: 40px; height: 40px; border: solid; border-radius: 12px;">
                        +
                        </div>
                        <div style="display: flex; flex-direction: column; justify-content: center; position: absolute; top: 0px; left: 60px; width: ${width - 60}px; height: 100%;">
                        Ready to learn a skill
                        </div>
                        </div>
                        `;
                    } else {
                        text += `
                        <div style="display: flex; flex-direction: column; justify-content: center; margin-top: ${i == 0 ? 0 : 10}px; position: relative; width: 100%; height: 60px; border-radius: 6px; background-color: rgb(255, 255, 255, .4); overflow: hidden;">
                        <div style="margin-left: 10px; font-size: 24px;">UNLOCK at Lvl ${(i >= pilot.hasLegendarySkills ? i - pilot.hasLegendarySkills : i) + 1}</div>
                        </div>
                        `;
                    }
                }
                text += `
                <div style="margin-top: 20px;">
                ${showPilotStory(pilot)}
                </div>
                `;
                return text;
            } else if (!w) {
                let text = "";
                for (let i = 0; i < (7 + addon + (pilot.hasLegendarySkill ? pilot.hasLegendarySkills : 0)); i++) {
                    let skill = pilot.skills.find(e => e.slot == i);
                    if (skill) {
                        text += `
                        <div style="position: relative; margin-top: ${i == 0 ? 0 : 10}px; width: 100%; height: 60px; border-radius: 6px; background-color: rgb(255, 255, 255, .4); overflow: hidden;">
                        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(to right, rgb(0, 0, 0, 0) 0%, ${skill.legendary ? "#ffb700" : tierColor({ tier: skill.level - 1 })} 30%);">
                        </div>
                        <div style="position: absolute; top: 5px; left: 5px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${skill.imageSource}');">
                        ${typeof skill.imageSource == "object" ? `
                        <span class="material-symbols-outlined" style="font-size: 50px; color: #fff;">
                        ${skill.imageSource.name}
                        </span>
                        ` : ""}
                        </div>
                        <div style="position: absolute; display: flex; flex-direction: column; justify-content: center; top: 0px; left: 60px; width: ${width - 60 - (getDisplayPilotSkill(skill).toString().length * 20)}px; height: 100%;">
                        <div style="font-size: 18px;">${skill.name}${skill.robotOwner ? ` / ${skill.robotOwner}` : ""}</div>
                        <div style="font-size: 12px;">${skill.desc}</div>
                        </div>
                        <div style="position: absolute; top: 13.75px; right: 5px; font-size: 24px;">
                        ${getDisplayPilotSkill(skill)}
                        </div>
                        </div>
                        `;
                    }
                }
                return text;
            }
        } else if (pilot.legendarySkill) {
            let skill = pilot.legendarySkill;
            return `
            <div style="position: relative; width: 100%; height: 60px; border-radius: 6px; background-color: rgb(255, 255, 255, .4); overflow: hidden;">
            <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(to right, rgb(0, 0, 0, 0) 0%, #ffb700 30%);">
            </div>
            <div style="position: absolute; top: 5px; left: 5px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${skill.imageSource}');">
            ${typeof skill.imageSource == "object" ? `
            <span class="material-symbols-outlined" style="font-size: 50px; color: #fff;">
            ${skill.imageSource.name}
            </span>
            ` : ""}
            </div>
            <div style="position: absolute; display: flex; flex-direction: column; justify-content: center; top: 0px; left: 60px; width: ${width - 60 - (getDisplayPilotSkill(skill).toString().length * 20)}px; height: 100%;">
            <div style="font-size: 18px;">${skill.name}</div>
            <div style="font-size: 12px;">${skill.desc}</div>
            </div>
            <div style="position: absolute; top: 13.75px; right: 5px; font-size: 24px;">
            ${getDisplayPilotSkill(skill)}
            </div>
            </div>
            `;
        }
    }
    function showPilotDescription(pilot) {
        let element = document.createElement("div");
        element.style = `
        position: absolute;
        top: 12.5%;
        left: 12.5%;
        width: 75%;
        height: 75%;
        border-radius: 6px;
        background-color: rgb(0, 0, 0, .75);
        `;
        let width = window.innerWidth * .75;
        let height = window.innerHeight * .75;
        element.innerHTML = `
        <div style="position: absolute; margin-top: 20px; margin-left: 15px;">
        <div style="display: inline-block; transform: rotate(45deg); width: 30px; height: 30px; background-color: ${tierColor(pilot)};">
        <div style="text-align: center; font-size: 20px; color: #fff; width: 30px; height: 30px; transform: rotate(-45deg);">
        ${pilot.level || 1}
        </div>
        </div>
        </div>
        <div style="position: absolute; color: #fff; font-size: 24px; display: flex; align-items: center; top: 10px; left: 60px; height: 50px; width: 200px;">
        ${pilot.name}
        </div>
        <div id="image____3" style="position: absolute; left: 0px; top: 70px; width: 350px; height: 350px;">
        </div>
        <div style="position: absolute; right: 20px; top: 20px; width: ${width - 370}px; height: 210px; color: #fff; overflow-y: scroll;">
        ${showPilotStory(pilot)}
        </div>
        <div style="position: absolute; overflow-y: scroll; right: 20px; top: 240px; width: ${width - 370}px; height: ${height - 240}px; color: #fff; border-radius: 6px;">
        ${showPilotSkills(pilot, width - 370, 0, pilot.titan ? 3 : 0)}
        </div>
        `;
        document.getElementById("pilotDisplay").appendChild(element);
        element.onclick = function () {
            this.remove();
        };
        let image = getShapeSprite({
            name: pilot.industryName || "Circle",
            color: tierColor(pilot),
            scale: 95,
            increaseLine: 2.5
        }, true);
        image.style = "width: 100%; height: 100%;";
        document.getElementById(`image____3`).appendChild(image);
    }
    var skillUpgradeCost = [0, 1500, 5e3, 15e3];
    var pilotUpgradeCost = [0, 5e3, 10e3, 25e3, 30e3, 55e3, 75e3, 85e3, 95e3, 105e3];
    function upgradePilotSkill(skill) {
        let theskill = pilotSkillList.find(e => e.name == skill.name);
        if (theskill.onLowDefenseData) {
            skill.onLowDefense = theskill.onLowDefenseData[skill.level];
        }
        if (theskill.onAbilityUseSpeedData) {
            skill.onAbilityUseSpeed = theskill.onAbilityUseSpeedData[skill.level];
        }
        if (theskill.increaseDurationOfPositiveEffectsData) {
            skill.increaseDurationOfPositiveEffects = theskill.increaseDurationOfPositiveEffectsData[skill.level];
        }
        if (theskill.extraShieldHealthData) {
            skill.extraShieldHealth = theskill.extraShieldHealthData[skill.level];
        }
        if (theskill.onAbilityUseDefenseData) {
            skill.onAbilityUseDefense = theskill.onAbilityUseDefenseData[skill.level];
        }
        if (theskill.extraAbilityDamageData) {
            skill.extraAbilityDamage = theskill.extraAbilityDamageData[skill.level];
        }
        if (theskill.speedIncreaseData) {
            skill.speedIncrease = theskill.speedIncreaseData[skill.level];
        }
        if (theskill.dmgIncreaseData) {
            skill.dmgIncrease = theskill.dmgIncreaseData[skill.level];
        }
        if (theskill.onLowSpeedData) {
            skill.onLowSpeed = theskill.onLowSpeedData[skill.level];
        }
        if (theskill.mechanicHealData) {
            skill.mechanicHeal = theskill.mechanicHealData[skill.level];
        }
        if (theskill.healthIncreaseData) {
            skill.healthIncrease = theskill.healthIncreaseData[skill.level];
        }
        if (theskill.onAbilityUseFixData) {
            skill.onAbilityUseFix = theskill.onAbilityUseFixData[skill.level];
        }
        skill.level++;
    }
    function upgradeSkill(skill, robot) {
        if (skill.level >= 4) return;
        let element = document.createElement("div");
        element.style = `
        position: absolute;
        top: 12.5%;
        left: 12.5%;
        width: 75%;
        height: 75%;
        border-radius: 6px;
        background-color: rgb(0, 0, 0, .5);
        `;
        let s = 97;
        let height = window.innerHeight * .75;
        let width = window.innerWidth * .75;
        let height2 = height - (s + 10 + 150);
        let theSkill = pilotSkillList.find(e => e.name == skill.name);
        let newSkill = new SKILLLSKDAJIOSDJASJOIDJOISDJ(theSkill, null, robot);
        newSkill[newSkill.main] = theSkill[newSkill.main + "Data"][skill.level];
        let costOfUpgrade = skillUpgradeCost[skill.level] * (robot.titan ? 2 : 1);
        element.innerHTML = `
        <div style="color: #fff; width: 100%; text-align: center; font-size: 30px;">
        SKILL TIER UPGRADE
        </div>
        <div style="color: #fff; width: 100%; margin-top: 15px; text-align: center; font-size: 15px;">
        ${skill.name}
        </div>
        <div style="color: #fff; width: 100%; text-align: center; font-size: 15px;">
        ${skill.desc}
        </div>
        <div id="leaveThisThing" style="cursor: pointer; position: absolute; color: #fff; top: 10px; right: 10px;">
        x
        </div>
        <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; position: absolute; top: ${s + 10}px; height: ${height2}px; width: 100%;">
        <div style="color: #fff;">Current</div>
        <div style="position: relative; width: 350px; height: 60px; background-color: rgb(255, 255, 255, .4); overflow: hidden; border-radius: 6px;">
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(to right, rgb(0, 0, 0, 0), ${tierColor({ tier: skill.level - 1 })});"></div>
        <div style="position: absolute; top: 5px; left: 5px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${skill.imageSource}');">
        ${typeof skill.imageSource == "object" ? `
        <span class="material-symbols-outlined" style="font-size: 50px; color: #fff;">
        ${skill.imageSource.name}
        </span>
        ` : ""}
        </div>
        <div style="color: #fff; position: absolute; top: 0px; right: 5px; font-size: 45px;">
        ${getDisplayPilotSkill(skill)}
        </div>
        </div>
        <br>
        <div style="color: #fff;">Upgraded</div>
        <div style="position: relative; width: 350px; height: 60px; background-color: rgb(255, 255, 255, .4); overflow: hidden; border-radius: 6px;">
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(to right, rgb(0, 0, 0, 0), ${tierColor({ tier: skill.level })});"></div>
        <div style="position: absolute; top: 5px; left: 5px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${skill.imageSource}');">
        ${typeof skill.imageSource == "object" ? `
        <span class="material-symbols-outlined" style="font-size: 50px; color: #fff;">
        ${skill.imageSource.name}
        </span>
        ` : ""}
        </div>
        <div style="color: #fff; position: absolute; top: 0px; right: 5px; font-size: 45px;">
        ${getDisplayPilotSkill(newSkill)}
        </div>
        </div>
        </div>
        <div id="upgradeTheThing" style="cursor: pointer; color: #fff; display: flex; flex-direction: column; justify-content: center; align-items: center; position: absolute; left: ${width / 2 - 125}px; top: ${(height - 150) + 37.5}px; height: 75px; width: 250px; background-color: #0f0; border-radius: 6px;">
        <div style="font-size: 25px;">UPGRADE SKILL</div>
        <div style="display: flex; justify-content: center;">
        <div style="display: inline-block; width: 30px; height: 30px; background-size: 30px 30px; background-image: url('./images/icons/workshop.png');"></div>
        <div style="display: inline-block; font-size: 20px;">${abbreviateNumber(costOfUpgrade)}</div>
        </div>
        </div>
        `;
        document.getElementById("pilotDisplay").appendChild(element);
        document.getElementById("upgradeTheThing").onclick = function () {
            if (player.workshopPoints - costOfUpgrade >= 0) {
                updateMoneyDisplay("workshopPoints", -costOfUpgrade);
                upgradePilotSkill(skill);
                doPilotStuff(robot);
                upgradeSkill(skill, robot);
                saveGameData();
            }
        }
        document.getElementById("leaveThisThing").onclick = function () {
            element.remove();
        }
    }
    function changeSkill(pilot, robot) {
        if (!pilot || !pilot.skills) return;
        let done = false;
        for (let i = 0; i < pilot.skills.length; i++) {
            let skill = pilot.skills[i];
            if (skill && !skill.legendary) {
                done = true;
                break;
            }
        }
        if (!done) return;
        document.getElementById("mainPilotDisplay").style.display = "none";
        let element = document.createElement("div");
        element.style = `
        position: absolute;
        top: 12.5%;
        left: 12.5%;
        width: 75%;
        height: 75%;
        border-radius: 6px;
        background-color: rgb(0, 0, 0, .6);
        `;
        let bwidth = window.innerWidth * .75 * .5;
        let width = window.innerWidth * .75;
        let height = window.innerHeight * .75;
        let randomRollCost = pilot.level * 150;
        let chooseCost = pilot.level * 1500;
        let mode = "random";
        element.innerHTML = `
        <div id="chooseSKILLHA" style="cursor: pointer; position: absolute; right: 10px; top: 15px; display: none; flex-direction: column; align-items: center; justify-content: center; border-radius: 6px; color: #fff; width: 150px; height: 40px; background-color: #0f0;">
        <div>CHOOSE</div>
        <div style="display: flex; justify-content: center;">
        <div style="display: inline-block; width: 20px; height: 20px; background-size: 20px 20px; background-image: url('./images/icons/workshop.png');"></div>
        <div style="display: inline-block; font-size: 15px;">${abbreviateNumber(chooseCost)}</div>
        </div>
        </div>
        <div id="switch" style="color: #fff; cursor: pointer; position: absolute; display: flex; justify-content: center; align-items: center; border-radius: 6px; left: ${width / 2 - 75}px; top: 15px; width: 150px; height: 40px; background-color: rgb(0, 0, 0, .4);">
        CHOOSE SKILL
        </div>
        <div style="position: absolute; margin-top: 20px; margin-left: 15px;">
        <div style="display: inline-block; transform: rotate(45deg); width: 30px; height: 30px; background-color: ${tierColor(pilot)};">
        <div style="text-align: center; font-size: 20px; color: #fff; width: 30px; height: 30px; transform: rotate(-45deg);">
        ${pilot.level}
        </div>
        </div>
        </div>
        <div style="position: absolute; color: #fff; font-size: 20px; display: flex; align-items: center; top: 0px; left: 60px; height: 50px; width: 200px;">
        ${pilot.name}
        </div>
        <div style="position: absolute; color: #fff; font-size: 12px; display: flex; align-items: center; top: 20px; left: 60px; height: 50px; width: 300px;">
        The choosen skill will be replaced
        </div>
        <div style="display: block; position: absolute; height: ${height - 70}px; overflow-y: scroll; width: 50%; top: 70px; left: 0px; background-color: rgb(0, 0, 0, .2);">
        ${showPilotSkills(pilot, bwidth - 40, 2, robot.titan ? 3 : 0)}
        </div>
        <div style="color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; position: absolute; height: ${height - 70}px; width: 50%; top: 70px; right: 0px; background-color: rgb(0, 0, 0, .2);">
        <div id="chooseSkill" style="overflow-y: scroll; display: none; width: 100%; height: 100%;">
        </div>
        <div id="randomSkill" style="font-size: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
        <div>RANDOMLY REPLACE THE PILOT'S LEARNED SKILL</div>
        <div id="randomSkillRoll" style="cursor: pointer; margin-top: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 6px; color: #fff; width: 200px; height: 80px; background-color: #0f0;">
        <div>RANDOM SKILL</div>
        <div style="display: flex; justify-content: center;">
        <div style="display: inline-block; width: 30px; height: 30px; background-size: 30px 30px; background-image: url('./images/icons/workshop.png');"></div>
        <div style="display: inline-block; font-size: 20px;">${abbreviateNumber(randomRollCost)}</div>
        </div>
        </div>
        </div>
        </div>
        `;
        document.getElementById("pilotDisplay").appendChild(element);
        document.getElementById("switch").onclick = function () {
            slotSelected = -1
            if (mode == "random") {
                mode = "choose";
                document.getElementById("chooseSkill").style.display = "block";
                document.getElementById("randomSkill").style.display = "none";
                document.getElementById("chooseSkill").innerHTML = "";
                this.innerHTML = "RANDOM SKILL";
            } else {
                mode = "random";
                this.innerHTML = "CHOOSE SKILL";
                document.getElementById("chooseSkill").style.display = "none";
                document.getElementById("randomSkill").style.display = "flex";
            }
            document.getElementById("chooseSKILLHA").style.display = "none";
            t.forEach(e => {
                e.style.border = "none";
                e.style.marginLeft = 20;
            });
        }
        let elements = [...element.getElementsByTagName("div")];
        let t = [];
        let slotSelected = -1;
        let chooseSelected = -1;
        let SSSSSkills = [];
        for (let i = 0; i < elements.length; i++) {
            let element = elements[i];
            if (element.id && element.id.includes("selectSkill")) {
                t.push(element);
                element.onclick = function () {
                    let id = element.id.split("_")[1];
                    if (element.id.includes("selectSkill")) slotSelected = parseInt(id);
                    t.forEach(e => {
                        if (e == this) {
                            e.style.border = "solid";
                            e.style.borderWidth = 6;
                            e.style.borderColor = "white";
                            e.style.marginLeft = 12;
                        } else {
                            e.style.border = "none";
                            e.style.marginLeft = 20;
                        }
                    });
                    if (element.id.includes("selectSkill")) {
                        chooseSelected = -1;
                        SSSSSkills = possibleSkills(pilot, robot, pilot.skills.find(e => e.slot == id));
                        document.getElementById("chooseSkill").innerHTML = `
                        ${showPilotSkills({
                            skills: SSSSSkills
                        }, bwidth - 40, 3)}
                        `;
                        let ff = [];
                        let Elements = [...document.getElementById("chooseSkill").getElementsByTagName("div")];
                        for (let i = 0; i < Elements.length; i++) {
                            let Element = Elements[i];
                            if (Element.id.includes("chooseSkill")) {
                                ff.push(Element);
                                Element.onclick = function () {
                                    document.getElementById("chooseSKILLHA").style.display = "flex";
                                    chooseSelected = parseInt(Element.id.split("_")[1]);
                                    ff.forEach(e => {
                                        if (e == this) {
                                            e.style.border = "solid";
                                            e.style.borderWidth = 6;
                                            e.style.borderColor = "white";
                                            e.style.marginLeft = 12;
                                        } else {
                                            e.style.border = "none";
                                            e.style.marginLeft = 20;
                                        }
                                    });
                                }
                            }
                        }
                    }
                };
            }
        }
        document.getElementById("chooseSKILLHA").onclick = function () {
            if (slotSelected >= 0 && player.workshopPoints - chooseCost >= 0) {
                let theSkilll = pilot.skills.find(e => !e.legendary && e.slot == slotSelected);
                let indexxxx = pilot.skills.findIndex(e => !e.legendary && e.slot == slotSelected);
                if (!theSkilll.legendary) {
                    updateMoneyDisplay("workshopPoints", -chooseCost);
                    pilot.skills.splice(indexxxx, 1);
                    pilot.skills.push(new skill(SSSSSkills[chooseSelected], slotSelected, robot));
                    doPilotStuff(robot);
                    saveGameData();
                }
            }
        }
        document.getElementById("randomSkillRoll").onclick = function () {
            if (slotSelected >= 0 && player.workshopPoints - randomRollCost >= 0) {
                let theSkilll = pilot.skills.find(e => e.slot == slotSelected);
                let indexxxx = pilot.skills.findIndex(e => e.slot == slotSelected);
                if (!theSkilll.legendary) {
                    updateMoneyDisplay("workshopPoints", -randomRollCost);
                    let name = pilot.skills[indexxxx].name;
                    pilot.skills.splice(indexxxx, 1);
                    learnSkill(pilot, slotSelected, robot, name, Math.floor(Math.random() * 3));
                    doPilotStuff(robot);
                    saveGameData();
                }
            }
        }
    }
    function doPilotInventory(robot) {
        document.getElementById("pilotInventory___").innerHTML = "";
        let filtered = player.pilots.filter(e => e.titan == robot.titan && e.owner == null);
        if (filtered.length == 0) return;
        filtered = filtered.sort((a, b) => b.level - a.level).sort((a, b) => b.tier - a.tier);
        for (let i = 0; i < filtered.length; i++) {
            let pilot = filtered[i];
            let backgroundColor = i % 2 == 0 ? "rgb(0, 0, 0, .2)" : "rgb(255, 255, 255, .4)";
            document.getElementById("pilotInventory___").innerHTML += `
            <div style="position: absolute; top: 0px; left: ${350 * i}px; width: 350px; height: 100%; background-color: ${backgroundColor};">
            <div style="position: absolute; margin-top: 20px; margin-left: 15px;">
            <div style="display: inline-block; transform: rotate(45deg); width: 30px; height: 30px; background-color: ${tierColor(pilot)};">
            <div style="text-align: center; font-size: 20px; color: #fff; width: 30px; height: 30px; transform: rotate(-45deg);">
            ${pilot.level}
            </div>
            </div>
            </div>
            <div style="position: absolute; color: ${i % 2 == 0 ? "#fff" : "#000"}; font-size: 24px; display: flex; align-items: center; top: 10px; left: 60px; height: 50px; width: 200px;">
            ${pilot.name}
            </div>
            <div id="image__13${i}" style="position: absolute; left: 0px; top: 70px; width: 350px; height: 350px;">
            </div>
            <div id="showDe_sc_${i}" style="position: absolute; cursor: pointer; color: #fff; font-size: 30px; right: 10px; text-align: center; top: 70px; width: 40px; height: 40px; border-radius: 100%; background-color: rgb(255, 255, 255, .6);">
            i
            </div>
            <div id="selecttoequip${i}" style="font-size: 30px; color: #fff; position: absolute; cursor: pointer; display: flex; flex-direction: column; justify-content: center; align-items: center; bottom: 10px; left: 20px; width: ${350 - (20 * 2)}px; height: 60px; border-radius: 6px; background-color: #0f0;">
            ASSIGN
            </div>
            </div>
            </div>
            `;
        }
        for (let i = 0; i < filtered.length; i++) {
            let Pilot = filtered[i];
            let image = getShapeSprite({
                name: Pilot.industryName,
                color: tierColor(Pilot),
                scale: 95,
                increaseLine: 2.5
            }, true);
            image.style = "width: 100%; height: 100%;";
            document.getElementById(`image__13${i}`).appendChild(image);
            document.getElementById(`showDe_sc_${i}`).onclick = function () {
                showPilotDescription(Pilot);
            }
            document.getElementById(`selecttoequip${i}`).onclick = function () {
                let old = player.pilots.find(e => e.owner == robot.sid);
                if (old) {
                    old.owner = null;
                }
                Pilot.owner = robot.sid;
                saveGameData();
                doPilotStuff(robot);
            }
        }
    }
    for (let i = 0; i < pilotsData.length; i++) {
        if (!pilotsData[i].titan) {
            pilotsData[i].titan = false;
        }
    }
    function doPilotStuff(robot) {
        document.getElementById("sideDisplay").style.display = "none";
        if (document.getElementById("pilotDisplay")) {
            document.getElementById("pilotDisplay").remove();
        }
        let element = document.createElement("div");
        element.id = "pilotDisplay";
        element.style = `
        position: absolute;
        top: 0px;
        left: 0px;
        width: 100%;
        height: 100%;
        background-color: rgb(0, 0, 0, .2);
        `;
        let thePilot = player.pilots.find(e => e.titan == robot.titan && e.owner == robot.sid);
        if (!thePilot) {
            thePilot = {
                xp: {},
                level: 0
            };
        }
        let mainDisplayWidth = window.innerWidth - 300;
        let barWidth = mainDisplayWidth - 400;
        let height = window.innerHeight - 100;
        element.innerHTML = `
        <div id="inventoryButton_" style="cursor: pointer; display: none; position: absolute; top: 20px; left: ${window.innerWidth / 2 - 180}px; text-align: center; font-size: 35px; width: 175px; height: 50px; border-radius: 6px; background-color: rgb(0, 0, 0, .2);">
        Inventory
        </div>
        <div id="trainingCenterButton_" style="cursor: pointer; display: none; position: absolute; top: 20px; left: ${window.innerWidth / 2 + 5}px; text-align: center; font-size: 17px; width: 175px; height: 50px; border-radius: 6px; background-color: rgb(0, 0, 0, .2);">
        Training<br>Center
        </div>
        <div id="trainingCenter" style="display: none; position: absolute; left: 200px; top: ${window.innerHeight / 2 - 250}px; width: ${window.innerWidth - 400}px; height: 500px; overflow-x: scroll; background-color: rgb(0, 0, 0, .2); border-radius: 2px;">
        </div>
        <div id="pilotInventory___" style="display: none; position: absolute; left: 0px; top: ${window.innerHeight / 2 - 250}px; width: 100%; height: 500px; overflow-x: scroll; background-color: rgb(0, 0, 0, .2); border-radius: 2px;">
        </div>
        <div id="mainPilotDisplay" style="display: none; position: absolute; left: 150px; top: 50px; height: ${window.innerHeight - 100}; width: ${window.innerWidth - 300}px; background-color: rgb(0, 0, 0, .2);">
        <div style="position: absolute; margin-top: 20px; margin-left: 15px;">
        <div style="display: inline-block; transform: rotate(45deg); width: 30px; height: 30px; background-color: ${tierColor(thePilot)};">
        <div style="text-align: center; font-size: 20px; color: #fff; width: 30px; height: 30px; transform: rotate(-45deg);">
        ${thePilot.level}
        </div>
        </div>
        </div>
        <div style="position: absolute; color: #fff; font-size: 24px; display: flex; align-items: center; top: 10px; left: 60px; height: 50px; width: 200px;">
        ${thePilot.name}
        </div>
        <div id="image____2" style="position: absolute; left: 0px; top: 70px; width: 350px; height: 350px;">
        </div>
        <div style="position: absolute; right: 20px; top: 20px; height: 60px; width: ${barWidth}px; background-color: rgb(0, 0, 0, .3); border-radius: 6px;">
        <div style="border: solid; border-radius: 100%; border-width: 4px; color: ${tierColor({ tier: 1 })}; margin-top: 5px; margin-left: 5px; border-color: ${tierColor({ tier: 1 })}; font-size: 30px; text-align: center; width: 40px; height: 40px;">
        i
        </div>
        <div style="position: absolute; display: flex; flex-direction: column; justify-content: center; left: 63px; top: 0px; width: ${barWidth - 63}px; height: 100%;">
        <div style="position: relative; width: 20px; height: 20px;">
        <div style="position: absolute; top: 0px; font-size: 15px;">Operates:</div>
        <div style="position: absolute; color: #fff; display: flex; align-items: center; justify-content: center; left: 75px; top: -5px; width: 30px; height: 30px; border-radius: 100%; background-color: ${tierColor(robot)};">
        ${robot.level >= 13 ? 1 : robot.level}
        </div>
        <div style="color: #fff; position: absolute; top: 0px; left: 110px; width: 300px; font-size: 15px;">
        ${robot.sid == thePilot.owner ? robot.level >= 13 ? `${robot.name} <span style="color: #${levelToMKColor(robot.level)};">${levelToMKText(robot.level)}</span>` : robot.name : ""}
        </div>
        </div>
        <div style="position: relative; font-size: 15px; margin-top: 5px; width: ${barWidth - 63}px; height: 20px;">
        Active Skills: <strong><span style="color: #0f0;">${displayActiveSkills(thePilot, robot)}</span>/${thePilot.level + (thePilot.hasLegendarySkill ? thePilot.hasLegendarySkills : 0)}</strong>
        </div>
        <div id="changeASkill" style="cursor: pointer; display: flex; align-items: center; font-size: 16px; justify-content: center; position: absolute; color: #fff; top: 5px; right: 5px; width: 150px; height: 50px; background-color: #02bfbf; border-radius: 6px;">
        CHANGE A SKILL
        </div>
        </div>
        </div>
        <div style="position: absolute; right: 20px; top: 90px; width: ${barWidth}px; height: ${height - 100}px; overflow-y: scroll;">
        ${showPilotSkills(thePilot, barWidth, true, robot.titan ? 3 : 0)}
        </div>
        <div id="upgradePilot" style="cursor: pointer; color: #fff; display: flex; flex-direction: column; justify-content: center; align-items: center; position: absolute; left: 20px; bottom: 20px; width: 330px; height: 60px; background-color: ${thePilot.level < thePilot.maxLevel ? "#0f0" : "#808080"}; border-radius: 6px;">
        <div style="display: ${thePilot.level < thePilot.maxLevel ? "block" : "none"}">
        <div style="font-size: 25px;">UPGRADE PILOT</div>
        <div style="display: flex; justify-content: center;">
        <div style="display: inline-block; width: 30px; height: 30px; background-size: 30px 30px; background-image: url('./images/icons/workshop.png');"></div>
        <div style="display: inline-block; font-size: 20px;">${abbreviateNumber(pilotUpgradeCost[thePilot.level] * (robot.titan ? 4 : 1))}</div>
        </div>
        </div>
        <div style="font-size: 30px; display: ${thePilot.level >= thePilot.maxLevel ? "block" : "none"}">
        MAXED
        </div>
        </div>
        <div id="changePilot___" style="font-size: 40px; cursor: pointer; color: #fff; display: flex; flex-direction: column; justify-content: center; align-items: center; position: absolute; left: 20px; bottom: 90px; width: 330px; height: 60px; background-color: #0f0; border-radius: 6px;">
        CHANGE
        </div>
        <div id="closePilotTab" style="font-size: 40px; cursor: pointer; color: #fff; display: flex; flex-direction: column; justify-content: center; align-items: center; position: absolute; left: 20px; bottom: 160px; width: 330px; height: 60px; background-color: #808080; border-radius: 6px;">
        CLOSE
        </div>
        </div>
        </div>
        `;
        document.body.appendChild(element);
        let elements = [...element.getElementsByTagName("div")];
        for (let i = 0; i < elements.length; i++) {
            let element = elements[i];
            if (element.id.includes("learnSkill")) {
                let id = element.id.split("_")[1];
                element.onclick = function () {
                    learnSkill(thePilot, parseInt(id), robot);
                };
            } else if (element.id.includes("upgradeSkill")) {
                let id = element.id.split("_")[1];
                element.onclick = function () {
                    upgradeSkill(thePilot.skills.find(e => !e.legendary && e.slot == parseInt(id)), robot);
                };
            }
        }
        document.getElementById("upgradePilot").onclick = function () {
            if (thePilot.level < thePilot.maxLevel && player.workshopPoints - (pilotUpgradeCost[thePilot.level] * (robot.titan ? 4 : 1)) >= 0) {
                updateMoneyDisplay("workshopPoints", -(pilotUpgradeCost[thePilot.level] * (robot.titan ? 4 : 1)));
                thePilot.level++;
                doPilotStuff(robot);
                saveGameData();
            }
        }
        document.getElementById("changeASkill").onclick = function () {
            changeSkill(thePilot, robot);
        }
        let image = getShapeSprite({
            name: thePilot.industryName || "Circle",
            color: tierColor(thePilot),
            scale: 95,
            increaseLine: 2.5
        }, true);
        image.style = "width: 100%; height: 100%;";
        document.getElementById(`image____2`).appendChild(image);
        let filteredData = pilotsData.filter(e => e.titan == robot.titan);
        for (let i = 0; i < filteredData.length; i++) {
            let pilot = filteredData[i];
            let backgroundColor = i % 2 == 0 ? "rgb(0, 0, 0, .2)" : "rgb(255, 255, 255, .4)";
            document.getElementById("trainingCenter").innerHTML += `
            <div style="position: absolute; top: 0px; left: ${350 * i}px; width: 350px; height: 100%; background-color: ${backgroundColor};">
            <div style="position: absolute; margin-top: 20px; margin-left: 15px;">
            <div style="display: inline-block; transform: rotate(45deg); width: 30px; height: 30px; background-color: ${tierColor(pilot)};">
            <div style="text-align: center; font-size: 20px; color: #fff; width: 30px; height: 30px; transform: rotate(-45deg);">
            1
            </div>
            </div>
            </div>
            <div style="position: absolute; color: ${i % 2 == 0 ? "#fff" : "#000"}; font-size: ${pilot.name.length >= 25 ? 18 : 24}px; display: flex; align-items: center; top: 10px; left: 60px; height: 50px; width: 200px;">
            ${pilot.name}
            </div>
            <div id="image_1${i}" style="position: absolute; left: 0px; top: 70px; width: 350px; height: 350px;">
            </div>
            <div id="showDesc_${i}" style="position: absolute; cursor: pointer; color: #fff; font-size: 30px; right: 10px; text-align: center; top: 70px; width: 40px; height: 40px; border-radius: 100%; background-color: rgb(255, 255, 255, .6);">
            i
            </div>
            <div id="hire_p${i}" style="position: absolute; cursor: pointer; display: flex; flex-direction: column; justify-content: center; align-items: center; bottom: 10px; left: 20px; width: ${350 - (20 * 2)}px; height: 90px; border-radius: 6px; background-color: #0f0;">
            <div style="font-size: 30px;">HIRE</div>
            <div style="display: flex; justify-content: center;">
            <div style="display: inline-block; width: 30px; height: 30px; background-size: 30px 30px; background-image: url('./images/icons/workshop.png');"></div>
            <div style="display: inline-block; font-size: 20px;">${abbreviateNumber(pilotTierCost[pilot.tier])}</div>
            </div>
            </div>
            </div>
            `;
        }
        for (let i = 0; i < filteredData.length; i++) {
            let Pilot = filteredData[i];
            let image = getShapeSprite({
                name: Pilot.industryName,
                color: tierColor(Pilot),
                scale: 95,
                increaseLine: 2.5
            }, true);
            image.style = "width: 100%; height: 100%;";
            document.getElementById(`image_1${i}`).appendChild(image);
            document.getElementById(`showDesc_${i}`).onclick = function () {
                showPilotDescription(Pilot);
            }
            document.getElementById(`hire_p${i}`).onclick = function () {
                if (player.workshopPoints - pilotTierCost[Pilot.tier] >= 0) {
                    updateMoneyDisplay("workshopPoints", -pilotTierCost[Pilot.tier]);
                    if (player.pilots.find(e => e.owner == robot.sid)) {
                        let s = player.pilots.find(e => e.owner == robot.sid);
                        s.owner = null;
                    }
                    player.pilots.push(new pilot(Pilot, robot.sid));
                    document.getElementById("sideDisplay").style.display = "block";
                    element.remove();
                    saveGameData();
                }
            }
        }
        document.getElementById("trainingCenterButton_").onclick = function () {
            document.getElementById("trainingCenter").style.display = "block";
            document.getElementById("pilotInventory___").style.display = "none";
        }
        document.getElementById("inventoryButton_").onclick = function () {
            if (player.pilots.find(e => e.owner == null)) {
                document.getElementById("trainingCenter").style.display = "none";
                document.getElementById("pilotInventory___").style.display = "block";
                doPilotInventory(robot);
            }
        }
        document.getElementById("changePilot___").onclick = function () {
            document.getElementById("hangerUI").append(document.getElementById("moneyDisplay"));
            document.getElementById("trainingCenterButton_").style.display = "block";
            document.getElementById("inventoryButton_").style.display = "block";
            document.getElementById("trainingCenter").style.display = "none";
            document.getElementById("mainPilotDisplay").style.display = "none";
            if (!player.pilots.find(e => e.titan == robot.titan && e.owner == null)) {
                document.getElementById("trainingCenterButton_").click();
            } else {
                document.getElementById("pilotInventory___").style.display = "block";
                doPilotInventory(robot);
            }
        }
        if (player.pilots.length == 0 || !player.pilots.find(e => e.titan == robot.titan && e.owner == robot.sid)) {
            document.getElementById("trainingCenter").style.display = "block";
            document.getElementById("inventoryButton_").style.display = "block";
            document.getElementById("trainingCenterButton_").style.display = "block";
            console.log("hi there")
            if (player.pilots.find(e => e.titan == robot.titan && e.owner == null)) {
                document.getElementById("inventoryButton_").click();
            } else {
                document.getElementById("trainingCenterButton_").click();
            }
        } else if (thePilot) {
            document.body.append(document.getElementById("moneyDisplay"));
            document.getElementById("mainPilotDisplay").style.display = "block";
        }
        document.getElementById("closePilotTab").onclick = function () {
            document.getElementById("sideDisplay").style.display = "block";
            document.getElementById("hangerUI").append(document.getElementById("moneyDisplay"));
            element.remove();
        }
    }
    function returnStyledName(data, text) {
        if (data.name && (data.name.includes("ULTIMATE") || data.name.includes("Ultimate"))) {
            text = text.replaceAll("Ultimate", "<span style='color: #ffff00;'>ULTIMATE</span>");
            text = text.replaceAll("ULTIMATE", "<span style='color: #ffff00;'>ULTIMATE</span>");
        }
        return text;
    }
    class drone {
        constructor(data, ownerSID = null) {
            this.industryName = data.industryName;
            this.name = data.name;
            this.owner = ownerSID;
            this.level = 1;
            this.desc = data.desc;
            this.tier = data.tier;
            this.effects = [];
            this.visualData = { ...data.visualData };
            this.abilities = [];
            for (let i = 0; i < data.abilities.length; i++) {
                let _ = data.abilities[i];
                if (_) {
                    let obj = {
                        name: _.name,
                        reload: _.reload,
                        desc: _.desc,
                        icon: _.icon,
                        main: _.main,
                        limit: _.limit
                    };
                    obj.unlockAtLevel = _.unlockAtLevel;
                    if (_.reloadData) {
                        obj.reload = _.reloadData.base;
                    }
                    if (_.name == "On Block: Fix" || _.name == "On Mild Damage: Fix" || _.name == "On High Damage: Fix") {
                        obj.required = _.required;
                        obj.in = _.in;
                        obj.healing = _.healingData ? _.healingData.base : _.healing;
                    } else if (["On Mild Damage: [P_Shield]", "On High Damage: [P_Shield]", "On Low Durability: [Y_Shield]", "On Mild Damage: [B_Shield]"].includes(_.name)) {
                        obj.required = _.required;
                        obj.in = _.in;
                        obj.duration = _.duration;
                        obj.oneTimeUse = _.oneTimeUse;
                        obj.type = _.type;
                        obj.shielding = _.shieldingData ? _.shieldingData.base : _.shielding;
                    } else if (obj.name == "On Deployment: Durability") {
                        obj.healthIncrease = _.healthIncreaseData ? _.healthIncreaseData.base : _.healthIncrease;
                    } else if (obj.name == "On Deployment: Damage") {
                        obj.dmgIncrease = _.dmgIncreaseData ? _.dmgIncreaseData.base : _.dmgIncrease;
                    } else if (["On Kill: Defense", "On Beacon Capture: Defense"].includes(obj.name)) {
                        obj.defenseIncrease = _.defenseIncreaseData ? _.defenseIncreaseData.base : _.defenseIncrease;
                    } else if (obj.name == "On High Damage: Stealth" || obj.name == "On First Hit: Stealth") {
                        obj.required = _.required;
                        obj.in = _.in;
                        obj.stealthTime = _.stealthTimeData ? _.stealthTimeData.base : _.stealthTime;
                    } else if (obj.name == "On Threshold: Fix%" || obj.name == "On Threshold: Resist") {
                        obj.grayDamageHeal_p = _.grayDamageHeal_pData ? _.grayDamageHeal_pData.base : _.grayDamageHeal_p;
                        obj.healPower = _.healPowerData ? _.healPowerData.base : _.healPower;
                        obj.defenseIncrease = _.defenseIncreaseData ? _.defenseIncreaseData.base : _.defenseIncrease;
                    } else if (obj.name == "On Kill: Damage" || obj.name == "On Block: Damage") {
                        obj.onKillDamage = _.onKillDamageData ? _.onKillDamageData.base : _.onKillDamage;
                    } else if (obj.name == "On Kill: Speed") {
                        obj.onKillSpeed = _.onKillSpeedData ? _.onKillSpeed.base : _.onKillSpeed;
                    } else if (obj.name == "On Kill: Fix") {
                        obj.grayDamageHeal_p = _.grayDamageHeal_pData ? _.grayDamageHeal_pData.base : _.grayDamageHeal_p;
                        obj.onKillFix = _.onKillFixData ? _.onKillFixData.base : _.onKillFix;
                    } else if (_.weapon) {
                        obj.weapon = true;
                        obj.reload = _.reload;
                        obj.range = _.range;
                        obj.spread = _.spread;
                        obj.dmg = _.damageData ? _.damageData.base : _.dmg;
                        obj.deathmark = _.deathmarkData ? _.deathmarkData.base : _.deathmark;
                    } else if (obj.name == "On Module Use: More Durability With DOT" || obj.name == "On Module Use: Block") {
                        obj.dmg = obj.name == "On Module Use: Block" ? 50 : 45e3;
                    } else if (obj.name == "Additional Damage Depending DoT") {
                        obj.dmgIncrease = _.dmgIncrease;
                        obj.dmgDependingDoT = _.dmgDependingDoT;
                    } else if (obj.name == "On Module Use: Damage") {
                        obj.onActiveModuleUseDamage = _.onActiveModuleUseDamage;
                    } else if (obj.name == "On Deployment: Protect Hull") {
                        obj.hullIntegrity = _.hullIntegrity;
                    } else if (obj.name == "On Module Use: Resist") {
                        obj.defenseIncrease = _.defenseIncrease;
                    }
                    this.abilities.push(obj);
                }
            }
            if (this.tier == 0) {
                this.cost = 1e3;
                this.maxLevel = 3;
            } else if (this.tier == 1) {
                this.cost = 5e3;
                this.maxLevel = 6;
            } else if (this.tier == 2) {
                this.cost = 25e3;
                this.maxLevel = 9;
            } else if (this.tier == 3) {
                this.cost = 75e3;
                this.maxLevel = 12;
            } else {
                this.cost = 125e3;
                this.maxLevel = 15;
            }
        }
    }
    var dronesData = [{
        tier: 0,
        industryName: "Circle",
        name: "Starter",
        desc: "The first drone ever made. It may be small, but it still has potential.",
        visualData: {
            scale: 25,
            color: "#808080",
            name: "Circle"
        },
        abilities: [{
            name: "On Mild Damage: Fix",
            desc: "After the shape takes X amount of damage, instantly repairs X durability.",
            required: 70e3,
            in: 5e3,
            icon: "./images/modules/self_fix_unit.png",
            reload: 5e3,
            main: "healing",
            healingData: {
                base: 12e3,
                level: [0, 1e3, 2e3]
            }
        }]
    }, {
        tier: 0,
        name: "Defender",
        industryName: "Pentagon",
        desc: "You like your gadgets big and powerful? Then it's Defender you want. It's huge (well, for a drone) and a trusted ally that always has your back.",
        visualData: {
            scale: 35,
            color: "#00f",
            name: "Circle"
        },
        abilities: [{
            name: "On Mild Damage: [B_Shield]",
            desc: "After the shape takes X amount of damage, activates a blue shield.",
            required: 70e3,
            in: 5e3,
            icon: "./images/modules/fortifier.png",
            reload: 5e3,
            main: "shielding",
            type: "energy",
            shieldingData: {
                base: 20e3,
                level: [0, 5e3, 5e3]
            }
        }]
    }, {
        tier: 1,
        name: "Good Guy",
        industryName: "Pentagon",
        desc: "All you need to stop a bad guy with a gun is a Good Guy with an yellow shield.",
        visualData: {
            scale: 25,
            color: "#00ffff",
            name: "Pentagon"
        },
        abilities: [{
            name: "On Low Durability: [Y_Shield]",
            desc: "After the shape drops to or below 30%, activates a yellow shield.",
            icon: "./images/modules/fortifier.png",
            oneTimeUse: true,
            main: "shielding",
            type: "yellow",
            shieldingData: {
                base: 12e3,
                level: [0, 1600, 1600, 1600, 1600, 1600]
            }
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .03
        }]
    }, {
        tier: 2,
        name: "Nebula",
        industryName: "Pentagon",
        desc: "When the engineers of the Pentagon Industry took a long time to perfect Nebula and they did it, let's not say what it cost. And now this drone will help you defeat the Ego of your enemies!",
        visualData: {
            scale: 25,
            color: "#800080",
            name: "Pentagon"
        },
        abilities: [{
            name: "On Mild Damage: Fix",
            desc: "After the shape takes X amount of damage, instantly repairs X durability.",
            icon: "./images/modules/self_fix_unit.png",
            main: "healing",
            required: 70e3,
            in: 5e3,
            reload: 5e3,
            healingData: {
                base: 30e3,
                level: [0, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750]
            }
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .05
        }, {
            name: "On High Damage: [P_Shield]",
            unlockAtLevel: 9,
            desc: "After the shape takes X amount of damage, activates a purple shield.",
            required: 150e3,
            in: 5e3,
            duration: 1e3,
            icon: "./images/modules/fortifier.png",
            reload: 20e3,
            main: "shielding",
            type: "purple",
            shielding: 1
        }]
    }, {
        tier: 3,
        name: "Armadillo",
        industryName: "Pentagon",
        desc: "Do you need more protection? Then you've come to the right place! Our Armadillo can easily help you survive the next machine gun fire or a missile blast to your shape. It doesn't matter what style of play you choose. He likes capturing beacons and destroying enemies in all of them.",
        visualData: {
            scale: 25,
            color: "#ffff00",
            name: "Pentagon"
        },
        abilities: [{
            name: "On Mild Damage: Fix",
            desc: "After the shape takes X amount of damage, instantly repairs X durability.",
            icon: "./images/modules/self_fix_unit.png",
            main: "healing",
            required: 70e3,
            in: 5e3,
            reload: 10e3,
            healingData: {
                base: 30e3,
                level: [0, 3750, 3750, 3750, 3750, 3750, 13750, 13750, 13750, 13750, 13800, 32450]
            }
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .1
        }, {
            name: "On Beacon Capture: Defense",
            unlockAtLevel: 9,
            desc: "The shape gains extra defense points per beacon capture.",
            icon: "./images/modules/fortifier.png",
            main: "defenseIncrease",
            reload: 5e3,
            defenseIncrease: 30
        }, {
            name: "On Kill: Defense",
            desc: "The shape gains extra defense points per kill.",
            unlockAtLevel: 12,
            icon: "./images/modules/fortifier.png",
            main: "defenseIncrease",
            reload: 5e3,
            defenseIncrease: 30
        }]
    }, {
        tier: 3,
        name: "Beak",
        industryName: "Heptagon",
        desc: "Beak is your support at the forefront of the attack. At the first sign of danger, the drone uses a built-in stealth system.",
        visualData: {
            scale: 25,
            color: "#008080",
            name: "Heptagon"
        },
        abilities: [{
            name: "On High Damage: Stealth",
            desc: "After the shape takes X amount of damage, instantly repairs X durability.",
            icon: "./images/stealth.png",
            main: "stealthTime",
            required: 150e3,
            in: 10e3,
            reload: 10e3,
            stealthTimeData: {
                base: 400,
                level: [0, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 600]
            }
        }, {
            name: "On Deployment: Damage",
            desc: "Increases the shape's weapon damage output by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/nuclear_reactor.png",
            main: "dmgIncrease",
            dmgIncrease: .07
        }, {
            name: "On First Hit: Stealth",
            unlockAtLevel: 9,
            desc: "When the shape takes damage for the first time, activates a one time use stealth.",
            icon: "./images/stealth.png",
            main: "stealthTime",
            stealthTime: 2e3
        }, {
            name: "On High Damage: Fix",
            unlockAtLevel: 12,
            desc: "After the shape takes X amount of damage, instantly repairs X durability.",
            icon: "./images/modules/self_fix_unit.png",
            main: "healing",
            required: 150e3,
            in: 5e3,
            reload: 10e3,
            healing: 175e3
        }]
    }, {
        dontSell: true,
        tier: 4,
        name: "Pascal",
        industryName: "Circle",
        desc: "",
        visualData: {
            scale: 30,
            color: "#ffb400",
            name: "Circle"
        },
        abilities: [{
            name: "On Threshold: Fix%",
            desc: "The shape restores a percentage of its durability and gray damage once, upon reaching a threshold of 70%/50%/30% durability.",
            icon: "./images/modules/self_fix_unit.png",
            main: ["healPower", "grayDamageHeal_p"],
            reload: 20e3,
            healPowerData: {
                base: .11,
                level: [0, .01, .01, .01, .01, .01, .01, .01, .01, .02, .02, .02, .02, .02, .02]
            },
            grayDamageHeal_pData: {
                base: .02,
                level: [0, .01, .01, .01, .01, .02, .03, .03, .03, .03, .05, .05, .06, .06, .08]
            }
        }, {
            name: "On Deployment: Damage",
            desc: "Increases the shape's weapon damage output by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/nuclear_reactor.png",
            main: "dmgIncrease",
            dmgIncrease: .05
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 9,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .07
        }, {
            name: "On Kill: Damage",
            desc: "The shape gains a permanent damage boost for each kill.",
            unlockAtLevel: 12,
            icon: "./images/modules/nuclear_amplifier.png",
            main: "onKillDamage",
            reload: 5e3,
            onKillDamage: .05
        }, {
            name: "On Threshold: Resist",
            desc: "The power of the shape's defense system is increased upon reaching a threshold of 70%/50%/30% durability.",
            unlockAtLevel: 15,
            reload: 20e3,
            icon: "./images/modules/heavy_armor_plating.png",
            main: "defenseIncrease",
            defenseIncrease: 100
        }]
    }, {
        tier: 4,
        name: "Hiruko",
        industryName: "Triangle",
        desc: "",
        visualData: {
            scale: 30,
            color: "#808080",
            name: "Triangle"
        },
        abilities: [{
            weapon: true,
            name: "Imitating Frag Shotgun",
            desc: "Miniature version of the well known cluster shotgun: Brisant.",
            icon: "./images/weapons/shatter.png",
            main: "dmg",
            spread: 15,
            reload: 500,
            range: 2e3,
            damageData: {
                base: 5250,
                level: [0, 656, 656, 656, 656, 656, 656, 1313, 1313, 1313, 1313, 1313, 1313, 2625, 2625]
            },
        }, {
            name: "On Deployment: Damage",
            desc: "Increases the shape's weapon damage output by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/nuclear_reactor.png",
            main: "dmgIncrease",
            dmgIncrease: .05
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 9,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .05
        }, {
            name: "On Module Use: More Durability With DOT",
            desc: "Increases the shape's durability by 45,000, but gains a DoT effect.",
            unlockAtLevel: 12,
            main: "dmg",
            icon: "./images/weapons/sting.png",
        }, {
            name: "Additional Damage Depending DoT",
            icon: "./images/modules/nuclear_reactor.png",
            unlockAtLevel: 15,
            limit: 50,
            desc: "The shape gains additional damage for every DoT Effect it is under.",
            main: "dmgDependingDoT",
            dmgIncrease: .15,
            dmgDependingDoT: .005
        }]
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Triangle",
        name: "Kestrel",
        desc: "",
        visualData: {
            scale: 35,
            color: "#ffff00",
            name: "Triangle"
        },
        abilities: [{
            weapon: true,
            name: "Deathmark Affector",
            desc: "The drone fires a energy shell that affects enemies with the Deathmark effect for 15 seconds.",
            icon: "./images/modules/nuclear_amplifier.png",
            main: ["deathmark", "dmg"],
            reload: 2e3,
            range: 2e3,
            damageData: {
                base: 200,
                level: [0, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100]
            },
            deathmarkData: {
                base: .01,
                level: [0, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01]
            }
        }, {
            name: "On Deployment: Damage",
            desc: "Increases the shape's weapon damage output by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/nuclear_reactor.png",
            main: "dmgIncrease",
            dmgIncrease: .03
        }, {
            name: "On Deployment: Damage",
            desc: "Increases the shape's weapon damage output by X%.",
            unlockAtLevel: 9,
            icon: "./images/modules/nuclear_reactor.png",
            main: "dmgIncrease",
            dmgIncrease: .04
        }, {
            name: "On Kill: Speed",
            desc: "Upon getting a kill, the shape gets increased movement speed for the rest of the match.",
            unlockAtLevel: 12,
            reload: 5e3,
            limit: 5,
            icon: {
                name: "speed"
            },
            main: "onKillSpeed",
            onKillSpeed: .2
        }, {
            name: "On Kill: Fix",
            desc: "Upon getting a kill, the shape repairs a part of its durability and restores some gray damage.",
            unlockAtLevel: 15,
            reload: 5e3,
            icon: "./images/modules/self_fix_unit.png",
            main: "onKillFix",
            onKillFix: .17,
            grayDamageHeal_p: .5
        }]
    }, {
        dontSell: true,
        tier: 4,
        industryName: "Heptagon",
        name: "Bulwark",
        desc: "",
        visualData: {
            scale: 35,
            color: "#ffa500",
            name: "Heptagon"
        },
        abilities: [{
            weapon: true,
            name: "On Block: Fix",
            desc: ".",
            icon: "./images/modules/self_fix_unit.png",
            main: "healing",
            healingData: {
                base: 2e3,
                level: [0, 125, 125, 125, 125, 250, 250, 250, 250, 250, 250, 250, 500, 500, 500]
            }
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .03
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 9,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .03
        }, {
            name: "On Module Use: Block",
            desc: ".",
            unlockAtLevel: 12,
            icon: "./images/icons/block.png",
            main: "dmg"
        }, {
            name: "On Block: Damage",
            desc: "The shape gains a permanent damage boost for each block.",
            unlockAtLevel: 15,
            icon: "./images/modules/nuclear_amplifier.png",
            main: "onKillDamage",
            limit: 50,
            onKillDamage: .005
        }]
    }, {
        tier: 2,
        name: "Patron",
        industryName: "Heptagon",
        desc: "!",
        visualData: {
            scale: 25,
            color: "#00ffff",
            name: "Heptagon"
        },
        abilities: [{
            name: "On Blind: Remove",
            desc: "",
            icon: "./images/abilities/shapeshift.png",
            main: "reload",
            reloadData: {
                base: 40e3,
                level: [0, -1e3, -1e3, -2e3, -2e3, -2e3, -3e3, -4e3, -5e3]
            }
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .05
        }, {
            name: "On Deployment: Damage",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 9,
            icon: "./images/modules/nuclear_reactor.png",
            main: "dmgIncrease",
            dmgIncrease: .05
        }]
    }, {
        tier: 4,
        industryName: "Heptagon",
        name: "Hawkeye",
        desc: "",
        visualData: {
            scale: 35,
            color: "#ababab",
            name: "Heptagon"
        },
        abilities: [{
            weapon: true,
            name: "Imitating Comet Laser",
            desc: "Smaller version of the Athos family of weapons. 100% of the damage dealt will be turned into healing as well.",
            icon: "./images/weapons/athos.png",
            main: "dmg",
            reload: 200,
            range: 800,
            damageData: {
                base: 2e3,
                level: [0, 250, 250, 250, 250, 350, 350, 350, 550, 550, 550, 550, 750, 750, 1e3]
            }
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .03
        }, {
            name: "On Reflector: Shield Break",
            desc: "Once the shape has reflector, the shape gains a 15 second shield break.",
            unlockAtLevel: 9,
            icon: "./images/icons/shield_break.png",
            main: "dmg",
            dmg: 1
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 12,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .04
        }, {
            name: "On Deployment: Protect Hull",
            desc: "The shape gains minor protection from gray damage from all sources.",
            unlockAtLevel: 15,
            icon: "./images/modules/damage_controller.png",
            main: "hullIntegrity",
            hullIntegrity: .35
        }]
    }, {
        dontSell: true,
        tier: 4,
        name: "Superman",
        industryName: "Square",
        desc: "",
        visualData: {
            scale: 30,
            color: "#00ffff",
            name: "Square"
        },
        abilities: [{
            name: "On Mild Damage: Fix",
            desc: "Upon taking a mild amount of damage in some time, the drone will repair a fixed amount of durability.",
            icon: "./images/modules/self_fix_unit.png",
            main: "healing",
            required: 70e3,
            in: 3e3,
            reload: 2e3,
            healingData: {
                base: 60e3,
                level: [0, 5e3, 5e3, 6e3, 6e3, 7e3, 7e3, 8e3, 8e3, 9e3, 9e3, 10e3, 10e3, 12e3, 12e3]
            }
        }, {
            name: "On Deployment: Damage",
            desc: "Increases the shape's weapon damage output by X%.",
            unlockAtLevel: 4,
            icon: "./images/modules/nuclear_reactor.png",
            main: "dmgIncrease",
            dmgIncrease: .07
        }, {
            name: "On Deployment: Durability",
            desc: "Increases the shape's max durability by X%.",
            unlockAtLevel: 9,
            icon: "./images/modules/armor_plating.png",
            main: "healthIncrease",
            healthIncrease: .07
        }, {
            name: "On Module Use: Resist",
            desc: "Upon activating the shape's active module, the shape's defense system is increased.",
            unlockAtLevel: 12,
            icon: "./images/modules/defense_amplifier.png",
            main: "defenseIncrease",
            defenseIncrease: 100
        }, {
            name: "On Module Use: Damage",
            desc: "Upon activating the shape's active module, the shape's ongoing weapon damage output is increased.",
            unlockAtLevel: 14,
            icon: "./images/modules/nuclear_amplifier.png",
            main: "onActiveModuleUseDamage",
            onActiveModuleUseDamage: .75
        }, {
            name: "On Mild Damage: [P_Shield]",
            unlockAtLevel: 15,
            desc: "Upon damage a mild amount of damage in a some time, the drone will activate a temporary purple shield. When the shield becomes active, it repairs 25% of the shape's total gray damage.",
            required: 70e3,
            in: 3e3,
            duration: 1e3,
            icon: "./images/modules/fortifier.png",
            reload: 60e3,
            main: "shielding",
            type: "purple",
            shielding: 1
        }]
    }, {
        dontShow: true,
        tier: 4,
        industryName: "Triangle",
        name: "Dux Drone #1",
        desc: "",
        visualData: {
            scale: 35,
            color: "#ababab",
            name: "Triangle"
        },
        abilities: [{
            weapon: true,
            name: "Dux Drone",
            desc: "",
            icon: "./images/weapons/athos.png",
            main: "dmg",
            reload: 100,
            range: 1600
        }]
    }, {
        dontShow: true,
        tier: 4,
        industryName: "Triangle",
        name: "Dux Drone #2",
        desc: "",
        visualData: {
            scale: 35,
            color: "#f00",
            name: "Triangle"
        },
        abilities: [{
            weapon: true,
            name: "Dux Drone",
            desc: "",
            icon: "./images/weapons/athos.png",
            main: "dmg",
            reload: 150,
            range: 1600
        }]
    }, {
        dontShow: true,
        tier: 4,
        industryName: "Triangle",
        name: "Dux Drone #3",
        desc: "",
        visualData: {
            scale: 35,
            color: "#fff",
            name: "Triangle"
        },
        abilities: [{
            weapon: true,
            name: "Dux Drone #3",
            desc: "",
            icon: "./images/weapons/athos.png",
            main: "dmg",
            reload: 25,
            range: 1600
        }]
    }];
    checkIfDev();
    updateWorkshopDataStuff();
    var DRONEAJDOIASJDISAOJDAOSDJ = drone;
    function upgradeDrone(drone, currentIndex, drones, noEz, isBOT, shape, inInventory) {
        let Drone = dronesData.find(item => item.name == drone.name);
        if (Drone) {
            let ab1 = Drone.abilities[0];
            if (typeof ab1.main == "object") {
                ab1.main.forEach(e => {
                    let main = e;
                    if (main == "dmg") main = "damage";
                    let dataLocation = main + "Data";
                    let numbers = ab1[dataLocation];
                    if (numbers && numbers.level[drone.level]) {
                        drone.abilities[0][e] += numbers.level[drone.level];
                    }
                });
            } else {
                let main = ab1.main;
                if (main == "dmg") main = "damage";
                let dataLocation = main + "Data";
                let numbers = ab1[dataLocation];
                if (numbers && numbers.level[drone.level]) {
                    drone.abilities[0][ab1.main] += numbers.level[drone.level];
                }
            }
        }
        drone.level++;
        if (!noEz) {
            drones[currentIndex].level++;
            customizeDrones(drone, shape);
            if (!inInventory) {
                document.getElementById("storeButton").click();
            }
            for (let i = 0; i < currentIndex; i++) {
                document.getElementById("goToNext").click();
            }
            document.getElementById("Upgrade").click();
        }
        if (!noEz) updateSlots();
        if (!noEz) saveGameData();
    }
    function getStylesForBarD(value, name, name2) {
        if (name == "On Mild Damage: Fix" || name == "On High Damage: Fix" || name == "On Block: Fix") {
            return abbreviateNumber(value);
        } else if (name == "On Module Use: Damage" || name == "On Deployment: Protect Hull" || name == "On Block: Damage" || name == "On Kill: Fix" || name == "Additional Damage Depending DoT" || name == "On Deployment: Durability" || name == "On Deployment: Damage" || name == "On Kill: Damage") {
            return (value * 100).toFixed(1) + "%";
        } else if (name.includes("On High Damage: [") || name.includes("On Low Durability: [") || name.includes("On Mild Damage: [")) {
            return abbreviateNumber(value);
        } else if (name == "On First Hit: Stealth" || name == "On Blind: Remove") {
            return (value / 1000) + " seconds";
        } else if (name == "On Threshold: Fix%" || name2 == "Deathmark Power" || name == "On Kill: Speed") {
            return (value * 100).toFixed(1) + "%";
        } else if (name == "Imitating Comet Laser" || name == "Imitating Frag Shotgun" || name == "Deathmark Affector") {
            return abbreviateNumber(value);
        } else if (name == "On Reflector: Shield Break") {
            return 1;
        } else {
            return value;
        }
    }
    var mainTextToCommonDisplay = {
        "healPower": "Healing Power",
        "grayDamageHeal_p": "Gray Damage Heal",
        "dmg": "Damage",
        "deathmark": "Deathmark Power"
    };
    function enterBarForDrone(name, index, data, level) {
        let text = "";
        let Drone = dronesData.find(item => item.name == name);
        let Data = Drone.abilities[index];
        if (typeof Data.main == "object") {
            Data.main.forEach(e => {
                let main = e;
                if (main == "dmg") main = "damage";
                let dataLocation = main + "Data";
                let numbers = Data[dataLocation];
                let currentNumber = data[e];
                let maxwidth = window.innerWidth >= 1442 ? 500 : window.innerWidth >= 1374 ? 450 : window.innerWidth >= 1311 ? 400 : window.innerWidth >= 1245 ? 350 : window.innerWidth >= 1182 ? 300 : 250;
                let maxdmg = numbers.base;
                for (let i = 0; i < numbers.level.length; i++) {
                    maxdmg += numbers.level[i];
                }
                let indexAdjust = ((Math.abs(currentNumber) / maxdmg) * maxwidth) / maxwidth;
                let indexAdjusted = (((Math.abs(currentNumber) + Math.abs(numbers.level[level])) / maxdmg) * maxwidth) / maxwidth;
                text += `
                <div style="position: relative; width: ${maxwidth}px;">
                ${data.name} (${mainTextToCommonDisplay[e]}): ${getStylesForBarD(data[e], data.name, mainTextToCommonDisplay[e])}
                <div style="display: ${numbers.level[level] ? "block" : "none"}; position: absolute; top: 0px; right: 0px; color: #00ff00;">
                +${getStylesForBarD(numbers.level[level], data.name, mainTextToCommonDisplay[e])}
                </div>
                </div>
                <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
                <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
                </div>
                <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
                </div>
                </div>
                `;
            });
        } else {
            let main = Data.main;
            if (main == "dmg") main = "damage";
            let dataLocation = main + "Data";
            let numbers = Data[dataLocation];
            let currentNumber = data[Data.main];
            let maxwidth = window.innerWidth >= 1442 ? 500 : window.innerWidth >= 1374 ? 450 : window.innerWidth >= 1311 ? 400 : window.innerWidth >= 1245 ? 350 : window.innerWidth >= 1182 ? 300 : 250;
            let maxdmg = numbers.base;
            for (let i = 0; i < numbers.level.length; i++) {
                maxdmg += numbers.level[i];
            }
            let indexAdjust = ((Math.abs(currentNumber) / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((Math.abs(currentNumber) + Math.abs(numbers.level[level])) / maxdmg) * maxwidth) / maxwidth;
            if (Data.main == "reload") {
                indexAdjust = 1;
                indexAdjusted = 1;
            }
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            ${data.name}: ${getStylesForBarD(data[Data.main], data.name)}
            <div style="display: ${numbers.level[level] ? "block" : "none"}; position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${getStylesForBarD(numbers.level[level], data.name)}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        }
        return text;
    }
    var droneCost = [0, 2e3, 4e3, 6e3, 8e3, 10e3, 12e3, 14e3, 16e3, 20e3, 24e3, 28e3, 32e3, 36e3, 46e3];
    function returnAbiltiesForDrones(drone) {
        let text = "";
        for (let i = 0; i < drone.abilities.length; i++) {
            let ability = drone.abilities[i];
            text += `
            <span style="color: #fff">${ability.name}</span> - ${ability.desc || "No Description"}<br>
            ${ability.limit ? `Max Effect Stacks: ${ability.limit}<br>` : ""}
            ${ability.hullIntegrity ? `Hull Integrity: ${ability.hullIntegrity * 100}%<br>` : ""}
            ${ability.dmg ? `${ability.name == "On Module Use: More Durability With DOT" ? "Durability Bonus" : "Damage"}: ${styleNumberWithCommas(ability.dmg)}<br>` : ""}
            ${ability.range ? `Range: ${ability.range}PX<br>` : ""}
            ${ability.dmgDependingDoT ? `Damage Bonus: ${Math.round(ability.dmgDependingDoT * 1e3) / 10}%<br>` : ""}
            ${ability.deathmark ? `Deathmark Power: ${ability.deathmark * 100}%<br>` : ""}
            ${ability.healing ? `Healing Power: ${styleNumberWithCommas(ability.healing)}<br>` : ""}
            ${ability.healPower ? `Healing Power: ${Math.round(ability.healPower * 1e3) / 10}%<br>` : ""}
            ${ability.onKillFix ? `Healing Power: ${Math.round(ability.onKillFix * 1e3) / 10}%<br>` : ""}
            ${ability.onKillSpeed ? `Speed Increase: ${Math.round(ability.onKillSpeed * 1e3) / 10}%<br>` : ""}
            ${ability.grayDamageHeal_p ? `Gray Damage Healing: ${Math.round(ability.grayDamageHeal_p * 1e3) / 10}%<br>` : ""}
            ${ability.required ? `Damage Required to Activate: ${styleNumberWithCommas(ability.required)}<br>` : ""}
            ${ability.in ? `Within Time Range Of: ${ability.in / 1e3} sec<br>` : ""}
            ${ability.dmgIncrease ? `Damage Increase: ${Math.round(ability.dmgIncrease * 1e3) / 10}%<br>` : ""}
            ${ability.onKillDamage ? `Damage Increase: ${Math.round(ability.onKillDamage * 1e3) / 10}%<br>` : ""}
            ${ability.healthIncrease ? `Health Increase: ${Math.round(ability.healthIncrease * 1e3) / 10}%<br>` : ""}
            ${ability.defenseIncrease ? `Defense Points Increase: ${ability.defenseIncrease}<br>` : ""}
            ${ability.onActiveModuleUseDamage ? `Damage Increase: ${Math.round(ability.onActiveModuleUseDamage * 1e3) / 10}%<br>` : ""}
            ${ability.reload ? `${ability.weapon ? "Shot Interval" : "Cooldown"}: ${ability.reload / 1e3} sec<br>` : ""}<hr>
            `;
        }
        return text;
    }
    function drawDroneDisplay(modules, index, HA, shape, inInventory) {
        let Weapon = modules[index];
        if (!Weapon) return;
        let newWeapon = dronesData.find(e => Weapon.name == e.name);
        let weapon = new DRONEAJDOIASJDISAOJDAOSDJ(newWeapon);
        for (let i = 0; i < Weapon.level - 1; i++) {
            upgradeDrone(weapon, false, false, true);
        }
        let currentIndex = index;
        document.getElementById("WEAPONdisplay").innerHTML = `
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(rgb(0, 0, 0, 0), ${tierColor(weapon)});">
        </div>
        <div id="weaponImage" style="position: absolute; top: ${window.innerHeight / 2 - 187.5}px; left: ${window.innerWidth / 2 - 187.5}px; height: 375px; width: 375px;">
        </div>
        <div style="display: ${Weapon.amount == "main" ? "none" : "block"};position: absolute; text-align: center; top: ${window.innerHeight / 2 + 187.5}px; left: ${window.innerWidth / 2 - 187.5}px; height: 50px; width: 375px;">
        In Stock: ${!inInventory ? player.drones.filter(e => e.name == Weapon.name).length : Weapon.amount}
        </div>
        <div style="position: absolute; display: flex; align-items: center; font-size: 30px; top: ${window.innerHeight / 2 - 237.5}px; border-radius: 25px; left: ${window.innerWidth / 2 - 187.5}px; height: 50px; width: 375px; background-color: rgb(0, 0, 0, .25);">
        <div style="position: absolute; display: flex; align-items: center; top: 0px; left: 0px; width: 50px; height: 50px; border-radius: 100%; background-color: ${tierColor(weapon)};">
        <div style="width: 100%; color: #fff; font-size: 30px; text-align: center;">${weapon.level}</div>
        </div>
        <div style="width: 100%; text-align: center;">
        <span style="color: #fff">${weapon.name}</span>
        </div>
        <div id="showDescription" style="position: absolute; width: 40px; cursor: pointer; text-align: center; font-size: 30px; color: #fff; height: 40px; background-color: rgb(255, 255, 255, .6); border-radius: 100%; top: 5px; right: 5px;">
        i
        </div>
        </div>
        <div id="Unequip" style="display: ${Weapon.amount == "main" ? "block" : "none"}; position: absolute; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 5}px; bottom: 20px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #f00;">
        UNEQUIP
        </div>
        <div id="Equip" style="display: ${Weapon.amount == "main" ? "none" : inInventory ? "block" : "none"}; position: absolute; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 5}px; bottom: 20px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #0f0;">
        EQUIP
        </div>
        <div id="Upgrade" style="position: absolute; display: ${!inInventory ? "none" : "block"}; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 - 325}px; bottom: 20px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #0f0;">
        UPGRADE
        </div>
        <div id="upgradeMenu" style="z-index: 3; position: absolute; color: #fff; display: none; top: 12.5%; left: 12.5%; width: 75%; height: 75%; background-color: rgb(0, 0, 0, .7);">
        </div>
        <div style="position: absolute; bottom: 100px; left: 12.5%; width: 75%; height: 6px; background-color: #fff; border-radius: 4px; overflow: hidden;">
        <div style="position: absolute; top: 0px; left: ${(1 / modules.length) * 100 * currentIndex}%; width: ${(1 / modules.length) * 100}%; height: 100%; background-color: #00dbcd;">
        </div>
        </div>
        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        <div id="buyDrone" style="position: absolute; display: ${!inInventory ? Weapon.dontSell ? "none" : "block" : "none"}; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 - 125}px; bottom: 20px; cursor: pointer; width: 250px; height: 50px; border-radius: 6px; background-color: ${unlockedAtTier[weapon.tier] > player.profile.level ? "#808080" : "#0f0"};">
        ${unlockedAtTier[weapon.tier] > player.profile.level ? "LOCKED" : "BUY"}
        </div>
        <div id="buyMenu" style="z-index: 13; position: absolute; display: none; color: #fff; top: ${(window.innerHeight / 2) - (225 / 2)}px; left: ${(window.innerWidth / 2) - (425 / 2)}px; width: 425px; height: 225px; background-color: rgb(0, 0, 0, .7);">
        </div>
        `;
        let newThing = new DRONEAJDOIASJDISAOJDAOSDJ(weapon);
        newThing.visualData.scale = weapon.visualData.scale * 10;
        newThing.visualData.increaseLine = 10;
        let image = getShapeSprite(newThing.visualData, true);
        image.style = "width: 100%; height: 100%;";
        document.getElementById("weaponImage").appendChild(image);
        for (let i = 0; i < weapon.abilities.length; i++) {
            let data = weapon.abilities[i];
            if (data) {
                let element = document.createElement("div");
                element.style = `
                position: absolute;
                top: ${(window.innerHeight / 2 - (325 / 2)) + (i >= 4 ? ((i - 4) * 85) : i * 85)}px;
                ${i >= 4 ? "right" : "left"}: ${window.innerWidth / 2 - 487.5}px;
                width: 325px;
                height: 80px;
                background-color: rgb(0, 0, 0, .25);
                border-radius: 6px;
                `;
                let text = "", tex2 = "";
                let main = typeof data.main == "object" ? data.main[0] : data.main;
                text = abbreviateNumber(data[main]);
                if (main == "healing" || main == "onKillFix") {
                    tex2 = `
                    <div style="position: absolute; bottom: 0px;">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                    healing
                    </span>
                    </div>
                    <div style="position: absolute; left: 20px; bottom: -2.5px;">
                    ${main == "onKillFix" ? (text * 100).toFixed(1) + "%" : text}
                    </div>
                    `;
                } else if (main == "shielding" || main == "defenseIncrease") {
                    tex2 = `
                    <div style="position: absolute; bottom: 0px;">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                    shield
                    </span>
                    </div>
                    <div style="position: absolute; left: 20px; bottom: -2.5px;">
                    ${text}
                    </div>
                    `;
                } else if (main == "onKillSpeed" || main == "deathmark" || main == "dmgDependingDoT" || main == "healthIncrease" || main == "dmgIncrease" || main == "onKillDamage") {
                    tex2 = `
                    <div style="position: absolute; bottom: 0px;">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                    ${["deathmark", "dmgDependingDoT", "onKillDamage", "dmgIncrease"].includes(main) ? "destruction" : main == "onKillSpeed" ? "speed" : "health_and_safety"}
                    </span>
                    </div>
                    <div style="position: absolute; left: 20px; bottom: -2.5px;">
                    ${(text * 100).toFixed(1)}%
                    </div>
                    `;
                } else if (main == "stealthTime" || main == "reload") {
                    tex2 = `
                    <div style="position: absolute; bottom: 0px;">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                    ${main == "reload" ? "frame_reload" : "visibility_off"}
                    </span>
                    </div>
                    <div style="position: absolute; left: 20px; bottom: -2.5px; width: 200px;">
                    ${data[main] / 1000} seconds
                    </div>
                    `;
                } else {
                    tex2 = `
                    <div style="position: absolute; bottom: 0px;">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                    ${main == "dmg" || main == "onActiveModuleUseDamage" ? "destruction" : "healing"}
                    </span>
                    </div>
                    <div style="position: absolute; left: 20px; bottom: -2.5px; width: 200px;">
                    ${getStylesForBarD(data[main], data.name)}
                    </div>
                    `;
                }
                element.innerHTML = `
                <div style="position: absolute; left: 0px; top: 0px; width: 80px; height: 80px; background-size: 80px 80px; ${typeof data.icon == "object" ? "" : `background-image: url('${data.icon}');`}">
                ${typeof data.icon == "object" ? `
                <span class="material-symbols-outlined" style="color: #fff; font-size: 80px;">
                ${data.icon.name}
                </span>
                ` : ""}
                ${data.unlockAtLevel > weapon.level ? `
                <div style="position: absolute; top: 5px; left: 5px; width: 30px; height: 30px; background-color: rgb(255, 255, 255, .6); border-radius: 100%;">
                <span class="material-symbols-outlined" style="font-size: 30px;">
                lock
                </span>
                </div>
                ` : ""}
                </div>
                <div style="position: absolute; left: 85px; top: 10px; white-space: nowrap; font-size: 20px; width: 230px; max-height: 27.5px; height: 27.5px; overflow-x: scroll;">
                ${data.name}
                </div>
                <div style="position: absolute; left: 85px; bottom: 15px; font-size: 20px;">
                ${tex2}
                </div>
                `;
                document.getElementById("WEAPONdisplay").appendChild(element);
            }
        }
        document.getElementById("showDescription").onclick = function () {
            let element = document.createElement("div");
            element.style = `
            position: absolute;
            top: 12.5%;
            left: 12.5%;
            width: 75%;
            height: 75%;
            background-color: rgb(0, 0, 0, 0.75);
            z-index: 99;
            border-radius: 6px;
            `;
            let width = window.innerWidth * .75;
            let height = window.innerHeight * .75;
            let box = width / 2 - 80;
            element.innerHTML = `
            <div style="position: absolute; top: 7px; left: 10px; width: ${width - 10}px;">
            <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(shape)};">
            ${weapon.level}
            </div>
            <div style="position: absolute; top: 2px; left: 45px; color: #fff; font-size: 24px;">
            <strong>
            ${returnStyledName(weapon, weapon.name)}
            </strong>
            </div>
            </div>
            <div id="imageShape2" style="position: absolute; top: ${(height / 2) - (box / 2)}px; left: 40px; width: ${box}px; height: ${box}px;">
            </div>
            <div style="position: absolute; color: #a3a3a3; top: 0px; left: ${width / 2}px; width: ${width / 2}px; height: 100%; overflow-y: scroll;">
            <div style="margin-top: 5px;">
            <strong style="color: #fff;">Industry: ${weapon.industryName}</strong><br><br>
            ${returnStyledName(weapon, weapon.desc || "No description")}<br><br>
            ${returnAbiltiesForDrones(weapon)}
            <p></p>
            </div>
            </div>
            `;
            document.getElementById("sideDisplay").append(element);
            element.onclick = function () {
                this.remove();
            }
            if (weapon.specialOf) {
                document.getElementById(`imageShape2`).style.backgroundSize = `${box}px ${box}px`;
                document.getElementById(`imageShape2`).style.backgroundImage = `url('${shape.specialOf}')`;
            } else {
                let ws = new DRONEAJDOIASJDISAOJDAOSDJ(weapon);
                ws.visualData.scale *= 25;
                ws.visualData.increaseLine = 25;
                let image = getShapeSprite(ws.visualData, true);
                image.style = "width: 100%; height: 100%;";
                document.getElementById("imageShape2").appendChild(image);
            }
        }
        document.getElementById("Upgrade").onclick = function () {
            if (!inInventory) return;
            document.body.appendChild(document.getElementById("moneyDisplay"));
            document.getElementById("upgradeMenu").style.display = "block";
            document.getElementById("storeButton").style.display = "none";
            document.getElementById("inventoryButton").style.display = "none";
            let width = window.innerWidth * .75;
            let height = window.innerHeight * .75;
            let box = (width / 2) - 80;
            document.getElementById("upgradeMenu").innerHTML = `
            <div id="lo____l" style="position: absolute; cursor: pointer; top: 5px; right: 10px;">
            x
            </div>
            <div style="position: absolute; top: 7px; left: 10px; width: ${width - 10}px;">
            <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(weapon)};">
            ${weapon.level}
            </div>
            <div style="position: absolute; top: 2px; left: 45px; color: #fff; font-size: 24px;">
            <strong>
            ${weapon.name}
            </strong>
            </div>
            </div>

            <div id="UPGRADE" style="z-index: 5; position: absolute; width: 200px; height: 80px; cursor: pointer; left: ${width / 2 - 100}px; bottom: 10px; background-color: ${weapon.maxLevel > weapon.level ? "#00ff00" : "#808080"};">
            <div style="width: 100%; text-align: center; color: #fff; font-size: ${weapon.maxLevel > weapon.level ? 24 : 40}px; margin-top: ${weapon.maxLevel > weapon.level ? 5 : 10}px;">${weapon.maxLevel > weapon.level ? "UPGRADE" : "MAXED"}</div>
            <div style="display: ${weapon.maxLevel > weapon.level ? "block" : "none"}; width: 100%; text-align: center; font-size: 12px;">${abbreviateNumber(droneCost[weapon.level])} WKSP</div>
            </div>

            <div id="image" style="position: absolute; left: 40px; height: ${box}px; width: ${box}px; top: ${height / 2 - (box / 2)}px;">
            </div>
            <div id="skillText" style="position: absolute; right: 0px; height: ${height - 80}px; width: ${width / 2}px; top: 40px;">
            </div>
            `;
            let e = document.getElementById("skillText");
            let maxwidth = window.innerWidth >= 1442 ? 500 : window.innerWidth >= 1374 ? 450 : window.innerWidth >= 1311 ? 400 : window.innerWidth >= 1245 ? 350 : window.innerWidth >= 1182 ? 300 : 250;
            for (let i = 0; i < weapon.abilities.length; i++) {
                let data = weapon.abilities[i];
                if (data) {
                    if (i == 0) {
                        e.innerHTML += `
                        ${enterBarForDrone(weapon.name, i, data, weapon.level)}
                        `;
                    } else {
                        e.innerHTML += `
                        <div style="position: absolute; width: ${maxwidth}px; top: ${((typeof weapon.abilities[0].main == "object" ? weapon.abilities[0].main.length : 1) * 29.5) + ((i - 1) * 55)}; height: 50px; background-color: rgb(255, 255, 255, .4); border-radius: 6px;">
                        <div style="position: absolute; left: 0px; top: 0px; width: 50px; height: 50px; background-size: 50px 50px; ${typeof data.icon == "object" ? "" : `background-image: url('${data.icon}');`}">
                        ${typeof data.icon == "object" ? `
                        <span class="material-symbols-outlined" style="color: #fff; font-size: 50px;">
                        ${data.icon.name}
                        </span>
                        ` : ""}
                        </div>

                        <div style="position: absolute; left: 55px; top: 2.5px;">
                        ${data.name}<br>
                        ${data.unlockAtLevel > weapon.level ? `Unlock at level: ${data.unlockAtLevel}` : "Unlocked"}
                        </div>
                        <div style="position: absolute; font-size: 35px; right: 5px; top: 0px;">
                        ${getStylesForBarD(data[data.main], data.name)}
                        </div>
                        </div>
                        `;
                    }
                }
            }
            let image = getShapeSprite(newThing.visualData, true);
            image.style = "width: 100%; height: 100%;";
            document.getElementById("image").appendChild(image);
            document.getElementById("UPGRADE").onclick = function () {
                let weapon = player.drones.find(e => e.name == Weapon.name && (Weapon.amount == "main" ? shape.sid == e.owner : true) && e.level == Weapon.level);
                if (weapon.maxLevel > weapon.level && droneCost[weapon.level]) {
                    if (player.workshopPoints - droneCost[weapon.level] >= 0) {
                        updateMoneyDisplay("workshopPoints", -droneCost[weapon.level]);
                        upgradeDrone(weapon, currentIndex, modules, false, false, shape, inInventory);
                    }
                }
            }
            document.getElementById("lo____l").onclick = function () {
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                document.getElementById("upgradeMenu").style.display = "none";
                document.getElementById("storeButton").style.display = "block";
                document.getElementById("inventoryButton").style.display = "block";
            }
        }
        document.getElementById("Equip").onclick = function () {
            let old = player.drones.find(e => e.owner == shape.sid);
            if (old) {
                old.owner = null;
            }
            let neww = player.drones.find(e => e.name == newWeapon.name && e.owner == null && e.level == weapon.level);
            if (neww) {
                neww.owner = shape.sid;
                if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                    document.getElementById("slot" + shape.slot).click();
                    document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                } else {
                    document.getElementById("hangerUI").style.display = "block";
                    document.getElementById("sideDisplay").innerHTML = "";
                    document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                }
            }
        }
        document.getElementById("Unequip").onclick = function () {
            if (Weapon.amount == "main") {
                let thing = player.drones.find(e => e.owner == shape.sid);
                if (thing) {
                    thing.owner = null;
                    if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                        document.getElementById("slot" + shape.slot).click();
                        document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                    } else {
                        document.getElementById("hangerUI").style.display = "block";
                        document.getElementById("sideDisplay").innerHTML = "";
                        document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                    }
                }
            }
        }
        document.getElementById("buyDrone").onclick = function () {
            if (unlockedAtTier[weapon.tier] > player.profile.level) return;
            document.body.appendChild(document.getElementById("moneyDisplay"));
            document.getElementById("buyMenu").style.display = "block";
            document.getElementById("storeButton").style.display = "none";
            document.getElementById("inventoryButton").style.display = "none";
            let num = 60;
            document.getElementById("buyMenu").innerHTML = `
            <div style="width: 100%; text-align: center; font-size: 30px;">
            Confirm Purchase
            </div>
            <hr>
            <div id="lo____l" style="position: absolute; cursor: pointer; top: 5px; right: 10px;">
            x
            </div>

            <div style="position: absolute; top: ${num}px; left: ${425 / 2 - 62.5}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
            <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('./images/icons/workshop.png');">
            </div>
            <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
            ${abbreviateNumber(newThing.cost)}
            </div>
            </div>

            <div id="confirm" style="position: absolute; cursor: pointer; font-size: 24px; text-align: center; bottom: 10px; left: ${425 / 2 - 75}px; width: 150px; border-radius: 6px; height: 40px; background-color: #0f0;">
            Confirm
            </div>
            `;
            document.getElementById("confirm").onclick = function () {
                if (player.workshopPoints - weapon.cost >= 0) {
                    updateMoneyDisplay("workshopPoints", -weapon.cost);
                    let oldWeapon = player.drones.find(e => e.owner == shape.sid);
                    if (oldWeapon) {
                        oldWeapon.owner = null;
                    }
                    player.drones.push(new DRONEAJDOIASJDISAOJDAOSDJ(weapon, shape.sid));
                    if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                        document.getElementById("slot" + shape.slot).click();
                        document.getElementById("dronesButton").click();
                        document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                    } else {
                        document.getElementById("hangerUI").style.display = "block";
                        document.getElementById("sideDisplay").innerHTML = "";
                        document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                    }
                    saveGameData();
                }
            }
            document.getElementById("lo____l").onclick = function () {
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                document.getElementById("buyMenu").style.display = "none";
                document.getElementById("storeButton").style.display = "block";
                document.getElementById("inventoryButton").style.display = "block";
            }
        }
        document.getElementById("backButton").onclick = function () {
            if (shape.slot >= 0 && shape.slot !== null && shape.slot !== undefined) {
                document.getElementById("slot" + shape.slot).click();
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            } else {
                document.getElementById("hangerUI").style.display = "block";
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
        }
        if (HA) {
            document.getElementById("Upgrade").click();
        }
    }
    function customizeDrones(drone, shape) {
        let filteredWeapons = [];
        let f = player.drones.filter(e => e.owner == null).sort((a, b) => b.level - a.level).sort((a, b) => b.tier - a.tier);
        let data = dronesData.filter(e => !e.dontShow);
        for (let i = 0; i < f.length; i++) {
            let item = f[i];
            if (filteredWeapons.find(e => e.name == item.name && e.level == item.level)) {
                let index = filteredWeapons.findIndex(e => e.name == item.name && e.level == item.level);
                filteredWeapons[index].amount++;
            } else {
                filteredWeapons.push({
                    name: item.name,
                    level: item.level,
                    amount: 1
                });
            }
        }
        let ddrone = player.drones.find(e => e.owner == shape.sid);
        if (ddrone) {
            filteredWeapons.unshift({
                name: ddrone.name,
                level: ddrone.level,
                amount: "main"
            });
        }
        let currentIndex = 0;
        document.getElementById("sideDisplay").innerHTML = `
        <div id="WEAPONdisplay" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;">
        </div>
        <div id="goToPre" style="display: none; position: absolute; cursor: pointer; left: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToPreCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_before
        </span>
        </div>
        </div>
        <div id="goToNext" style="position: absolute; transition: .25s; cursor: pointer; right: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToNextCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_next
        </span>
        </div>
        </div>
        <div id="inventoryButton" style="position: absolute; text-align: center; font-size: 25px; color: #000; left: ${window.innerWidth / 2 - 165}px; top: 30px; border-radius: 6px; height: 42.5px; padding-top: 7.5px; width: 150px; background-color: rgb(255, 255, 255, .6);">
        INVENTORY
        </div>
        <div id="storeButton" style="position: absolute; text-align: center; font-size: 35px; cursor: pointer; color: #fff; left: ${window.innerWidth / 2 + 20}px; top: 30px; border-radius: 6px; height: 50px; width: 150px; background-color: rgb(0, 0, 0, .4);">
        STORE
        </div>
        `;
        let inInventory = true;
        let diiiisbled = false;
        document.getElementById("inventoryButton").onclick = function () {
            if (!diiiisbled) {
                this.style.cursor = null;
                this.style.color = "#000";
                this.style.backgroundColor = "rgb(255, 255, 255, .6)";
                document.getElementById("goToPre").style.display = "none";
                document.getElementById("goToNext").style.display = "block";
                document.getElementById("storeButton").style.cursor = "pointer";
                document.getElementById("storeButton").style.color = "#fff";
                document.getElementById("storeButton").style.backgroundColor = "rgb(0, 0, 0, .4)";
                currentIndex = 0;
                inInventory = true;
                drawDroneDisplay(inInventory ? filteredWeapons : data.sort((a, b) => a.tier - b.tier), currentIndex, false, shape, inInventory);
            }
        };
        document.getElementById("storeButton").onclick = function () {
            this.style.cursor = null;
            this.style.color = "#000";
            this.style.backgroundColor = "rgb(255, 255, 255, .6)";
            document.getElementById("goToPre").style.display = "none";
            document.getElementById("goToNext").style.display = "block";
            document.getElementById("inventoryButton").style.cursor = "pointer";
            document.getElementById("inventoryButton").style.color = "#fff";
            document.getElementById("inventoryButton").style.backgroundColor = "rgb(0, 0, 0, .4)";
            currentIndex = 0;
            inInventory = false;
            drawDroneDisplay(inInventory ? filteredWeapons : data.sort((a, b) => a.tier - b.tier), currentIndex, false, shape, inInventory);
        };
        if (filteredWeapons.length == 0) {
            document.getElementById("storeButton").click();
            document.getElementById("inventoryButton").style.cursor = null;
            diiiisbled = true;
        }
        drawDroneDisplay(filteredWeapons, 0, false, shape, inInventory);
        if (!(inInventory ? filteredWeapons[currentIndex - 1] : data[currentIndex - 1])) {
            document.getElementById("goToPre").style.display = "none";
        }
        document.getElementById("goToPre").onclick = function () {
            currentIndex--;
            drawDroneDisplay(inInventory ? filteredWeapons : data.sort((a, b) => a.tier - b.tier), currentIndex, false, shape, inInventory);
            if (!(inInventory ? filteredWeapons[currentIndex - 1] : data[currentIndex - 1])) {
                document.getElementById("goToPre").style.display = "none";
            } else {
                document.getElementById("goToPre").style.display = "block";
            }
            if (!(inInventory ? filteredWeapons[currentIndex + 1] : data[currentIndex + 1])) {
                document.getElementById("goToNext").style.display = "none";
            } else {
                document.getElementById("goToNext").style.display = "block";
            }
        }
        if (!(inInventory ? filteredWeapons[currentIndex + 1] : data[currentIndex + 1])) {
            document.getElementById("goToNext").style.display = "none";
        }
        document.getElementById("goToNext").onclick = function () {
            currentIndex++;
            drawDroneDisplay(inInventory ? filteredWeapons : data.sort((a, b) => a.tier - b.tier), currentIndex, false, shape, inInventory);
            if (!(inInventory ? filteredWeapons[currentIndex + 1] : data[currentIndex + 1])) {
                document.getElementById("goToNext").style.display = "none";
            } else {
                document.getElementById("goToNext").style.display = "block";
            }
            if (!(inInventory ? filteredWeapons[currentIndex - 1] : data[currentIndex - 1])) {
                document.getElementById("goToPre").style.display = "none";
            } else {
                document.getElementById("goToPre").style.display = "block";
            }
        }
        document.getElementById("goToNext").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToNextCon").style.color = "#000";
        }
        document.getElementById("goToNext").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToNextCon").style.color = "#fff";
        }
        document.getElementById("goToPre").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToPreCon").style.color = "#000";
        }
        document.getElementById("goToPre").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToPreCon").style.color = "#fff";
        }
    }
    var indexToRole = ["Tank", "Assault", "Scout", "Support", "All"];
    function shapeAbilitiesDisplay(shape) {
        let text = "";
        for (let i = 0; i < shape.abilities.length; i++) {
            let ability = shape.abilities[i];
            let tmpText = `
            ${ability.dmg ? `Ability Dmg: ${abbreviateNumber(ability.dmg)}<br>` : ""}
            ${ability.dotDamage ? `Ability DOT Dmg: ${abbreviateNumber(ability.dotDamage)}<br>` : ""}
            ${ability.shieldHp ? `Ability Shield HP: ${abbreviateNumber(ability.shieldHp)}<br>` : ""}
            ${ability.showDuration ? `Ability Duration: ${(ability.lastingTime / 1000)} sec<br>` : ""}
            ${ability.abilityDefensePoints ? `Ability ${ability.defensePointToReflector ? "Reflector Blocked" : "Defense Points"}: ${ability.defensePointToReflector ? Math.round((1 - defensePointsToResistance(ability.abilityDefensePoints)) * 1e3) / 10 + "%" : ability.abilityDefensePoints}<br>` : ""}
            ${ability.abilityHealthMulti ? `Ability Health Multiplier: ${ability.abilityHealthMulti * 100}%<br>` : ""}
            ${ability.effectIncrease ? `Effect Accumulation: ${Math.round(ability.effectIncrease * 1e4) / 100}%<br>` : ""}
            ${ability.suppressionPower ? `Ability Suppression Power: ${Math.round(ability.suppressionPower * 1e3) / 10}%<br>` : ""}
            ${ability.healingPower ? `Ability Healing Power: ${abbreviateNumber(ability.healingPower)}<br>` : ""}
            ${ability.additionalHealth ? `Ability Additional Health: ${abbreviateNumber(ability.additionalHealth)}<br>` : ""}
            ${ability.durabilityLimit ? `Ability Durability Bonus Limit: ${abbreviateNumber(ability.durabilityLimit)}<br>` : ""}
            ${ability.executionThreshold ? `Ability Execution Threshold: ${ability.executionThreshold * 100}%<br>` : ""}
            ${ability.effectAccumulation ? `Ability Effect Accumulation: ${ability.effectAccumulation}<br>` : ""}
            ${ability.healingPercent ? `Ability Repair Power: ${ability.healingPercent * 100}%<br>` : ""}
            ${ability.deathmark ? `Ability Deathmark Power: ${ability.deathmark * 100}%<br>` : ""}
            ${ability.abilityEffectDuration ? `Ability Effect Duration: ${ability.abilityEffectDuration / 1e3} sec<br>` : ""}
            ${ability.damageIncrease ? `Ability Damage Increase: ${ability.damageIncrease * 100}%<br>` : ""}
            `;
            if (tmpText.trim()) {
                tmpText = `
                <br>
                <div style="color: #fff;">Ability: ${ability.name}</div>
                ` + tmpText;
            }
            text += tmpText;
        }
        return text;
    }
    function customizeShape(shape, titan) {
        let customizedShape = shape;
        document.getElementById("hangerUI").style.display = "none";
        let infoDisplayTextThing = `
        Role: <span style="color: #fff">${indexToRole[shape.indexRole || 0]}</span><br>
        Health: ${abbreviateNumber(shape.health)}<br>
        ${shape.builtInDefensePoints ? `Defense Points: ${shape.builtInDefensePoints} (${((1 - defensePointsToResistance(shape.builtInDefensePoints)) * 100).toFixed(1)}% Resistance)<br>` : ""}
        Speed: ${(shape.speed * 1000).toFixed(2)} PX/SEC<br>
        ${shape.additionalHealth ? `Additional Health: ${abbreviateNumber(shape.additionalHealth)}<br>` : ""}
        ${shape.baseShielding ? `${shape.baseShielding.type == "normal" ? "Shield" : "Energy Shield"} Health: ${abbreviateNumber(shape.baseShielding.health)}<br>` : ""}
        ${shape.baseDamageIncrease ? `Base Dmg Increase: ${shape.baseDamageIncrease * 100}%<br>` : ""}
        ${shape.reflectorData ? `
        Reflector Blocked: ${Math.round(shape.reflectorData.resistance * 1e3) / 10}%<br>
        Reflector Returned: ${Math.round(shape.reflectorData.return * 1e3) / 10}%<br>
        ` : ""}
        ${shape.dotResistance ? `DOT Resistance: ${((1 - shape.dotResistance) * 100)}%<br>` : ""}
        ${shape.healingMulti ? `Healing Effectiveness: ${removeDecimals(shape.healingMulti * 100)}%<br>` : ""}
        ${shape.revive ? `Revival Amount: ${removeDecimals(shape.revive * 100)}%<br>` : ""}
        ${shape.healingAura ? `Healing Aura Power: ${abbreviateNumber(shape.healingAura)}<br>` : ""}
        ${shape.hullIntegrity ? `Hull Interity: ${shape.hullIntegrity * 100}%<br>` : ""}
        ${shapeAbilitiesDisplay(shape)}
        `;
        document.getElementById("sideDisplay").innerHTML = `
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(rgb(0, 0, 0, 0), ${tierColor(shape)});">
        </div>
        <div id="otherSlots" style="position: absolute; left: ${window.innerWidth / 2 - 200}px; top: 20px; width: 400px; height: 50px; background-color: rgb(0, 0, 0, 0.3); border-radius: 6px; overflow: hidden;">
        </div>
        <div style="position: absolute; display: ${shape.abilities[0]?.name ? "block" : "none"}; left: 20px; top: ${(window.innerHeight / 2) + 50}px; width: 325px; height: 100px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.4);">
        <div id="seeAbilityInfo" style="cursor: pointer; position: absolute; left: 6px; top: 6px; width: 80px; height: 80px; background-size: 80px 80px; border: solid; border-color: #000; border-width: 4px; background-image: url('${shape.abilities[0]?.iconSource}'); border-radius: 100%; background-color: rgb(255, 255, 255, .5);">
        </div>
        <div style="position: absolute; color: #fff; font-size: 26px; left: 100px; top: 0px; width: 225px; height: 100%; display: flex; align-items: center;">
        ${shape.abilities[0]?.name}
        </div>
        </div>
        <div style="position: absolute; display: ${shape.abilities[1]?.name ? "block" : "none"}; left: 20px; top: ${(window.innerHeight / 2) + (210 - 50)}px; width: 325px; height: 100px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.4);">
        <div id="seeAbilityInfo2" style="cursor: pointer; position: absolute; left: 6px; top: 6px; width: 80px; height: 80px; background-size: 80px 80px; border: solid; border-color: #000; border-width: 4px; background-image: url('${shape.abilities[1]?.iconSource}'); border-radius: 100%; background-color: rgb(255, 255, 255, .5);">
        </div>
        <div style="position: absolute; color: #fff; font-size: 26px; left: 100px; top: 0px; width: 225px; height: 100%; display: flex; align-items: center;">
        ${shape.abilities[1]?.name}
        </div>
        </div>
        <div id="abilityDescription" style="position: absolute; display: none; z-index: 100; left: 355px; top: ${(window.innerHeight / 2) - 100}px; width: 325px; height: 250px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(179, 179, 179, 0.3); overflow-y: scroll;">
        <div style="margin-top: 5px; margin-left: 10px; width: 310px;">
        ${shape.abilities[0]?.desc}
        <p></p>
        </div>
        </div>
        <div id="abilityDescription2" style="position: absolute; display: none; z-index: 100; left: 355px; top: ${(window.innerHeight / 2) + 10}px; width: 325px; height: 250px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(179, 179, 179, 0.3); overflow-y: scroll;">
        <div style="margin-top: 5px; margin-left: 10px; width: 310px;">
        ${shape.abilities[1]?.desc}
        <p></p>
        </div>
        </div>
        <div style="position: absolute; overflow-y: scroll; left: 20px; top: ${(window.innerHeight / 2) - 250}px; width: 325px; height: 290px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.4);">
        <div style="position: absolute; top: 7px; left: 5px;">
        <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(shape)};">
        ${!shape.titan && shape.level >= 13 ? 1 : shape.level}
        </div>
        <div style="position: absolute; height: 32.5px; max-height: 32.5px; overflow-y: scroll; top: 2px; width: 260px; left: 45px; color: #fff; font-size: 24px;">
        <strong>
        ${returnStyledName(shape, shape.name)}
        ${shape.titan ? "" : shape.level >= 13 ? `<span style="color: #${levelToMKColor(shape.level)};">${levelToMKText(shape.level)}</span>` : ""}
        </strong>
        </div>
        </div>
        <div style="position: absolute; top: 45px; left: 0px;">
        <hr style="position: absolute; top: 0px; left: 0px; color: #fff; width: 325px;">
        <div style="position: absolute; top: 15px; left: 5px; width: 320px;">
        ${infoDisplayTextThing}
        <p></p>
        </div>
        </div>
        </div>
        <div id="shapeImage" style="position: absolute; left: ${window.innerWidth / 2 - 187.5}px; top: ${window.innerHeight / 2 - 187.5}px; width: 375px; height: 375px;">
        <div id="showDescription" style="position: absolute; cursor: pointer; display: flex; align-items: center; right: 0px; top: 0px; width: 35px; height: 35px; background-color: rgb(255, 255, 255, .4); border-radius: 100%;">
        <div style="width: 100%; color: #fff; text-align: center; font-size: 30px;">
        i
        </div>
        </div>
        </div>
        <div style="position: absolute; overflow-y: scroll; right: 20px; top: ${(window.innerHeight / 2) - 267.5}px; width: 325px; height: 535px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.2);">
        <div style="position: absolute; width: 100%; height: 35px;">
        <div id="switchWeapon" style="position: absolute; font-size: 24px; text-align: center; left: 0px; width: 50%; height: 100%; background-color: rgb(255, 255, 255, .8);">
        WEAPONS
        </div>
        <div id="switchModule" style="position: absolute; cursor: pointer; color: #fff; text-align: center; font-size: 25px; left: 50%; width: 50%; height: 100%; background-color: rgb(0, 0, 0, .3);">
        MODULES
        </div>
        </div>
        <div id="weaponDisplay" style="position: absolute; left: 0px; top: 35px; height: 500px; width: 100%; overflow-y: scroll; background-color: rgb(0, 0, 0, 0.1);">
        </div>
        </div>
        <div id="upgradeShape" style="position: absolute; cursor: pointer; text-align: center; font-size: 35px; color: #fff; left: ${window.innerWidth / 2 + 10}px; bottom: 20px; width: 175px; height: 60px; background-color: rgb(0, 255, 0); border-radius: 6px;">
        UPGRADE
        </div>
        <div id="changeShape" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: ${window.innerWidth / 2 - 185}px; bottom: 20px; width: 175px; height: 60px; background-color: rgb(125, 125, 125); border-radius: 6px;">
        CHANGE
        </div>
        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        <div id="microchipList" style="display: ${player.profile.level < 16 ? "none" : "block"}; position: absolute; cursor: pointer; font-size: 40px; text-align: center; color: #fff; left: ${shape.titan ? 355 : 20}px; top: ${window.innerHeight / 2 + (210 - (shape.titan ? 54 : 50))}px; width: 105px; height: 105px; background-color: rgb(0, 0, 0, .4); border: solid; border-color: #fff; border-radius: 6px;">
        <span class="material-symbols-outlined" style="font-size: 100px; color: #fff;">
        developer_board
        </span>
        </div>
        <div id="dronesButton" style="display: ${player.profile.level < 10 ? "none" : shape.titan ? "none" : "block"}; position: absolute; cursor: pointer; font-size: 40px; text-align: center; color: #fff; left: 133px; top: ${window.innerHeight / 2 + (210 - 50)}px; width: 105px; height: 105px; background-color: rgb(0, 0, 0, .4); border: solid; border-color: #fff; border-radius: 6px;">
        <span class="material-symbols-outlined" style="font-size: 100px; color: #fff;">
        smart_toy
        </span>
        </div>
        <div id="upgradeMenu" style="position: absolute; color: #fff; display: none; top: 12.5%; left: 12.5%; width: 75%; height: 75%; background-color: rgb(0, 0, 0, .7);">
        </div>
        `;
        document.getElementById("seeAbilityInfo").onclick = function () {
            let e = document.getElementById("abilityDescription");
            if (e.style.display == "block") {
                e.style.display = "none";
            } else {
                e.style.display = "block";
            }
        }
        document.getElementById("seeAbilityInfo2").onclick = function () {
            let e = document.getElementById("abilityDescription2");
            if (e.style.display == "block") {
                e.style.display = "none";
            } else {
                e.style.display = "block";
            }
        }
        document.getElementById("showDescription").onclick = function () {
            let element = document.createElement("div");
            element.style = `
            position: absolute;
            top: 12.5%;
            left: 12.5%;
            width: 75%;
            height: 75%;
            background-color: rgb(0, 0, 0, 0.75);
            z-index: 99;
            border-radius: 6px;
            `;
            let width = window.innerWidth * .75;
            let height = window.innerHeight * .75;
            let box = width / 2 - 80;
            element.innerHTML = `
            <div style="position: absolute; top: 7px; left: 10px; width: ${width - 10}px;">
            <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(shape)};">
            ${!shape.titan && shape.level >= 13 ? 1 : shape.level}
            </div>
            <div style="position: absolute; top: 2px; left: 45px; color: #fff; font-size: 24px;">
            <strong>
            ${returnStyledName(shape, shape.name)}
            ${shape.titan ? "" : shape.level >= 13 ? `<span style="color: #${levelToMKColor(shape.level)};">${levelToMKText(shape.level)}</span>` : ""}
            </strong>
            </div>
            </div>
            <div id="imageShape2" style="position: absolute; top: ${(height / 2) - (box / 2)}px; left: 40px; width: ${box}px; height: ${box}px;">
            </div>
            <div style="position: absolute; color: #a3a3a3; top: 0px; left: ${width / 2}px; width: ${width / 2}px; height: 100%; overflow-y: scroll;">
            <div style="margin-top: 5px;">
            <strong style="color: #fff;">Industry: ${shape.industryName || shape.name.split(" ")[shape.name.split(" ").length - 1]}</strong><br><br>
            ${returnStyledName(shape, shape.desc)}<br><br>
            ${shape.abilities.length ? `
            Abilities:<br>
            ${shape.abilities[0]?.desc || ""}<br><br>
            ${shape.abilities[1] ? (shape.abilities[1].desc + "<br><br>") : ""}
            ` : ``}
            Shape Stats:<br>
            ${infoDisplayTextThing}
            <p></p>
            </div>
            </div>
            `;
            document.getElementById("sideDisplay").append(element);
            element.onclick = function () {
                this.remove();
            }
            if (shape.specialOf) {
                document.getElementById(`imageShape2`).style.backgroundSize = `${box}px ${box}px`;
                document.getElementById(`imageShape2`).style.backgroundImage = `url('${shape.specialOf}')`;
            } else {
                let ws = new SHAPPPPPPPPPE(shape, null, true);
                ws.scale *= 10;
                ws.increaseLine = 10;
                let image = getShapeSprite(ws, true);
                image.style = "width: 100%; height: 100%;";
                document.getElementById("imageShape2").appendChild(image);
            }
        }
        document.getElementById("microchipList").onclick = function () {
            doPilotStuff(shape);
        }
        document.getElementById("backButton").onclick = function () {
            document.getElementById("hangerUI").style.display = "block";
            document.getElementById("sideDisplay").innerHTML = "";
            updateSlots();
            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
        }
        if (shape.specialOf) {
            document.getElementById(`shapeImage`).style.backgroundSize = `375px 375px`;
            document.getElementById(`shapeImage`).style.backgroundImage = `url('${shape.specialOf}')`;
        } else {
            let image = getShapeSprite(shape, true);
            image.style = "width: 100%; height: 100%;";
            document.getElementById("shapeImage").appendChild(image);
        }
        let equippedSlots = player.shapes.filter(e => e.slot != null && e.slot >= 0).sort((a, b) => a.slot - b.slot);
        let slotElement = document.getElementById("otherSlots");
        for (let i = 0; i < 8; i++) {
            slotElement.innerHTML += `
            <div id="slotElement${i}" style="position: absolute; top: 0px; left: ${50 * i}px; width: 50px; height: 50px; background-color: ${i % 2 == 0 ? "rgb(0, 0, 0, 0.2)" : "rgb(0, 0, 0, 0.4)"};">
            </div>
            `;
        }
        for (let i = 0; i < 8; i++) {
            let shape = equippedSlots.find(e => e.slot == i);
            if (shape) {
                if (!document.getElementById(`slotElement${shape.slot}`)) continue;
                if (shape.specialOf) {
                    document.getElementById(`slotElement${shape.slot}`).style.backgroundSize = `50px 50px`;
                    document.getElementById(`slotElement${shape.slot}`).style.backgroundImage = `url('${shape.specialOf}')`;
                } else {
                    let image = getShapeSprite(shape, true);
                    image.style = "width: 100%; height: 100%;";
                    document.getElementById("slotElement" + shape.slot).appendChild(image);
                }
                if (shape == customizedShape) {
                    document.getElementById(`slotElement${shape.slot}`).style.backgroundColor = "rgb(0, 255, 0)";
                } else {
                    document.getElementById(`slotElement${shape.slot}`).style.cursor = "pointer";
                    document.getElementById(`slotElement${shape.slot}`).onclick = function () {
                        customizeShape(shape);
                    }
                }
            } else if (!slotData[i].unlocked) {
                document.getElementById(`slotElement${i}`).style.backgroundColor = "rgb(0, 0, 0, 0.4)";
                document.getElementById(`slotElement${i}`).innerHTML = `
                <span class="material-symbols-outlined" style="font-size: 50px; color: #fff;">
                lock
                </span>
                `;
            }
        }
        if (player.drones.find(e => e.owner == shape.sid)) {
            let Drone = player.drones.find(e => e.owner == shape.sid);
            let newt = new drone(Drone);
            newt.visualData.scale *= 10;
            newt.visualData.increaseLine = 10;
            let image = getShapeSprite(newt.visualData, true);
            image.style = "width: 100%; height: 100%;";
            document.getElementById("dronesButton").innerHTML = "";
            document.getElementById("dronesButton").appendChild(image);

        }
        document.getElementById("dronesButton").onclick = function () {
            customizeDrones(player.drones.find(e => e.owner == shape.sid), shape);
        }
        let hardpoints = shape.hardpoints.light + shape.hardpoints.heavy;
        let filteredWeapons = player.weapons.filter(e => e.owner == shape.sid);
        let elements = [];
        let doWeaponsStuff = () => {
            elements = [];
            document.getElementById("abilityDescription").style.display = "none";
            document.getElementById("abilityDescription2").style.display = "none";
            for (let i = 0; i < hardpoints; i++) {
                let weaponType = "";
                if (i < shape.hardpoints.light && shape.hardpoints.light > 0) {
                    elements.push("LIGHT slot" + i);
                    weaponType = "LIGHT";
                } else {
                    elements.push("HEAVY slot" + i);
                    weaponType = "HEAVY";
                }
                document.getElementById("weaponDisplay").innerHTML += `
                <div id="${weaponType} slot${i}" style="position: relative; cursor: pointer; height: ${500 / 4}px; width: 100%; background-color: ${i % 2 ? "rgb(0, 0, 0, 0.2);" : "rgb(255, 255, 255, 0.1);"}}">
                </div>
                `;
            }
            for (let i = 0; i < elements.length; i++) {
                let elementId = elements[i];
                let weapon = filteredWeapons.find(e => e.slot == parseInt(elementId[elementId.length - 1]));
                if (!weapon) {
                    document.getElementById(elementId).innerHTML = `
                    <span style="position: absolute; top: ${125 / 2 - 27}px; left: ${325 / 2 - 135}px; font-size: 40px;">Equip Weapon</span>
                    `;
                    document.getElementById(elementId).onclick = function () {
                        customizeWeapon(elementId.includes("LIGHT") ? "Light" : "Heavy", shape, parseInt(elementId[elementId.length - 1]));
                    }
                } else {
                    let weaponIcon = getWeaponIcon(weapon, true);
                    weaponIcon.style = "width: 125px; height: 125px;";
                    document.getElementById(elementId).appendChild(weaponIcon);
                    document.getElementById(elementId).innerHTML += `
                    <div style="position: absolute; color: ${tierColor(weapon)}; top: 5px; left: 135px; font-size: 24px;">
                    ${weapon.level >= 13 && !weapon.titan ? `${returnStyledName(weapon, weapon.name)} <span style="color: ${weapon.level == 13 ? "#0f0" : "#ffff00"};">${weapon.level == 13 ? "MK2" : "MK3"}</span>` : `Lvl ${weapon.level} ${returnStyledName(weapon, weapon.name)}`}
                    <div style="color: #fff; font-size: 14px; margin-top: -5px;">${elementId.includes("LIGHT") ? shape.titan ? "Beta" : "Light" : shape.titan ? "Alpha" : "Heavy"}</div>
                    </div>
                    `;
                    document.getElementById(elementId).onclick = function () {
                        customizeWeapon(weapon, shape, parseInt(elementId[elementId.length - 1]));
                    }
                }
            }
        }
        document.getElementById("switchWeapon").onclick = function () {
            this.style.cursor = null;
            this.style.color = "#000";
            this.style.backgroundColor = "rgb(255, 255, 255, .8)";
            document.getElementById("switchModule").style.color = "#fff";
            document.getElementById("switchModule").style.cursor = "pointer";
            document.getElementById("switchModule").style.backgroundColor = "rgb(0, 0, 0, .3)";
            document.getElementById("weaponDisplay").innerHTML = "";
            doWeaponsStuff();
        }
        let filteredModules = player.modules.filter(e => e.owner == shape.sid);
        let moduleHardpoints = (shape.moduleHardpoints || 0);
        document.getElementById("switchModule").onclick = function () {
            this.style.cursor = null;
            this.style.color = "#000";
            this.style.backgroundColor = "rgb(255, 255, 255, .8)";
            document.getElementById("abilityDescription").style.display = "none";
            document.getElementById("abilityDescription2").style.display = "none";
            document.getElementById("switchWeapon").style.color = "#fff";
            document.getElementById("switchWeapon").style.cursor = "pointer";
            document.getElementById("switchWeapon").style.backgroundColor = "rgb(0, 0, 0, .3)";
            document.getElementById("weaponDisplay").innerHTML = "";
            let elements = [];
            for (let i = 0; i < moduleHardpoints + (shape.titan ? 0 : 1); i++) {
                document.getElementById("weaponDisplay").innerHTML += `
                <div id="moduleSlot${i}" style="position: relative; cursor: pointer; height: ${500 / 4}px; width: 100%; background-color: ${i % 2 ? "rgb(0, 0, 0, 0.2);" : "rgb(255, 255, 255, 0.1);"}}">
                </div>
                `;
                elements.push(`moduleSlot${i}`);
            }
            for (let i = 0; i < elements.length; i++) {
                let elementId = elements[i];
                let module = filteredModules.find(e => e.slot == parseInt(elementId[elementId.length - 1]));
                if (!shape.titan && i + 1 >= elements.length) {
                    let module = activeModuleData[shape.activeModuleIndex];
                    let moduleIcon = getWeaponIcon(module, true);
                    moduleIcon.style = "width: 125px; height: 125px;";
                    document.getElementById(elementId).appendChild(moduleIcon);
                    document.getElementById(elementId).innerHTML += `
                    <div style="position: absolute; top: 5px; color: ${tierColor(module)}; left: 135px; font-size: 24px;">
                    ${module.name}
                    <div style="color: #fff; font-size: 14px; margin-top: -2px;">Active</div>
                    </div>
                    `;
                    document.getElementById(elementId).onclick = function () {
                        customizeActiveModule(module, shape);
                    };
                } else {
                    if (!module) {
                        document.getElementById(elementId).innerHTML = `
                        <span style="position: absolute; top: ${125 / 2 - 27}px; left: 35.25px; font-size: 40px;">
                        Equip Module
                        </span>
                        `;
                    } else {
                        let moduleIcon = getWeaponIcon(module, true);
                        moduleIcon.style = "width: 125px; height: 125px;";
                        document.getElementById(elementId).appendChild(moduleIcon);
                        document.getElementById(elementId).innerHTML += `
                        <div style="position: absolute; top: 5px; color: ${tierColor(module)}; left: 135px; font-size: 24px;">
                        Lvl ${module.level} ${module.name}
                        <div style="color: #fff; font-size: 14px; margin-top: -2px;">Passive</div>
                        </div>
                        `;
                    }
                    document.getElementById(elementId).onclick = function () {
                        customizeModule(module, shape, parseInt(elementId[elementId.length - 1]));
                    };
                }
            }
        }
        doWeaponsStuff();
        document.getElementById("upgradeShape").onclick = function () {
            slotElement.style.display = "none";
            document.getElementById("abilityDescription").style.display = "none";
            document.getElementById("abilityDescription2").style.display = "none";
            if (player.profile.level >= 10 && !shape.titan) document.getElementById("microchipList").style.display = "block";
            document.body.appendChild(document.getElementById("moneyDisplay"));
            let adjustwidth = window.innerWidth * .75;
            let titanUpgradeCost = (shape.level * (120 * ((shape.tier + 1) * .25)) + Math.ceil(shape.level / 5) * 1200) * (shape.tier + 1);
            document.getElementById("upgradeMenu").style.display = "block";
            document.getElementById("upgradeMenu").innerHTML = `
            <div style="width: 100%; text-align: center; margin-top: 5px; font-size: 30px;">
            ${!shape.titan && [14, 13].includes(shape.level) ? `${shape.name} <span style="color: ${shape.level == 13 ? "#0f0" : "#ffff00"};">${shape.level == 13 ? "MK2" : "MK3"}</span>` : `Lvl ${shape.level} ${shape.name}`}
            </div>
            <hr>
            <div style="position: absolute; left: 300px; top: 65px;">
            ${enterBarForShape("health", shape)}
            ${enterBarForShape("speed", shape)}
            ${enterBarForShape("additional health norm", shape)}
            ${enterBarForShape("built-in defense points", shape)}
            ${enterBarForShape("healingMulti", shape)}
            ${enterBarForShape("ability damage", shape)}
            ${enterBarForShape("ability dot damage", shape)}
            ${enterBarForShape("shield hp", shape)}
            ${enterBarForShape("ashield hp", shape)}
            ${enterBarForShape("healing aura", shape)}
            ${enterBarForShape("lasting time", shape)}
            ${enterBarForShape("ability effect duration", shape)}
            ${enterBarForShape("defense points ability", shape)}
            ${enterBarForShape("abilityHealthMulti", shape)}
            ${enterBarForShape("ability effect acc", shape)}
            ${enterBarForShape("ability suppression", shape)}
            ${enterBarForShape("ability healing power", shape)}
            ${enterBarForShape("additionalHealthData", shape)}
            ${enterBarForShape("executionThresholdData", shape)}
            ${enterBarForShape("effectAccumulationData", shape)}
            ${enterBarForShape("healingPercent", shape)}
            ${enterBarForShape("durabilityLimitData", shape)}
            ${enterBarForShape("deathmark", shape)}
            </div>
            <div id="leaveUpgrade" style="position: absolute; cursor: pointer; right: 10px; top: 10px;">
            X
            </div>
            <div id="UPGRADE" style="position: absolute; width: 200px; height: 80px; cursor: pointer; left: ${adjustwidth / 2 - 100}px; bottom: 10px; background-color: ${shape.level < 25 && shape.titan ? "#00ff00" : sliverUpgradesByTier[shape.tier].shapes[shape.level] ? "#00ff00" : [12, 13].includes(shape.level) ? "#ffff00" : "#808080"};">
            <div style="width: 100%; text-align: center; color: ${shape.titan ? "#fff" : [12, 13].includes(shape.level) ? "#f00" : "#fff"}; font-size: ${shape.titan && shape.level < 25 ? "24" : sliverUpgradesByTier[shape.tier].shapes[shape.level] ? "24" : [12, 13].includes(shape.level) ? "24" : "40"}px; margin-top: ${shape.titan && shape.level < 25 ? "5" : sliverUpgradesByTier[shape.tier].shapes[shape.level] ? "5" : shape.level == 12 ? "5" : "10"}px;">${shape.titan && shape.level < 25 ? "UPGRADE" : sliverUpgradesByTier[shape.tier].shapes[shape.level] ? "UPGRADE" : [12, 13].includes(shape.level) ? "ENHANCE" : "MAXED"}</div>
            <div style="color: ${shape.titan ? "#fff" : [12, 13].includes(shape.level) ? "#f00" : "#fff"}; display: ${shape.titan && shape.level < 25 ? "block" : sliverUpgradesByTier[shape.tier].shapes[shape.level] ? "block" : [12, 13].includes(shape.level) ? "block" : "none"}; width: 100%; text-align: center; font-size: 12px;">${shape.level < 25 && shape.titan ? `${titanUpgradeCost} WSP` : [12, 13].includes(shape.level) ? `${abbreviateNumber(shape.enhanceCost * (shape.level == 13 ? 24 : 1))} Gold` : `${abbreviateNumber(sliverUpgradesByTier[shape.tier].shapes[shape.level])} Sliver`}</div>
            </div>
            `;
            if (shape.specialOf) {
                document.getElementById(`upgradeMenu`).style.backgroundPosition = "0px 80px";
                document.getElementById(`upgradeMenu`).style.backgroundRepeat = "no-repeat";
                document.getElementById(`upgradeMenu`).style.backgroundSize = `280px 280px`;
                document.getElementById(`upgradeMenu`).style.backgroundImage = `url('${shape.specialOf}')`;
            } else {
                let sprite = getShapeSprite(shape, true);
                sprite.style = "width: 280px; height: 280px;";
                document.getElementById("upgradeMenu").appendChild(sprite);
            }
            document.getElementById("leaveUpgrade").onclick = function () {
                document.getElementById("upgradeMenu").style.display = "none";
                slotElement.style.display = "block";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
            document.getElementById("UPGRADE").onclick = function () {
                if (shape.titan) {
                    if (shape.level < 25 && player.workshopPoints - titanUpgradeCost >= 0) {
                        updateMoneyDisplay("workshopPoints", -titanUpgradeCost);
                        upgradeShape(shape);
                        document.getElementById("slot" + shape.slot).click();
                        document.getElementById("upgradeShape").click();
                    }
                } else if (sliverUpgradesByTier[shape.tier].shapes[shape.level] || shape.level == 12 || shape.level == 13) {
                    if (shape.level >= 12) {
                        if (player.gold - (shape.enhanceCost * (shape.level == 13 ? 24 : 1)) >= 0) {
                            updateMoneyDisplay("gold", -(shape.enhanceCost * (shape.level == 13 ? 24 : 1)));
                            upgradeShape(shape);
                            document.getElementById("slot" + shape.slot).click();
                            document.getElementById("upgradeShape").click();
                        }
                    } else {
                        if (player.sliver - sliverUpgradesByTier[shape.tier].shapes[shape.level] >= 0) {
                            updateMoneyDisplay("sliver", -sliverUpgradesByTier[shape.tier].shapes[shape.level]);
                            upgradeShape(shape);
                            document.getElementById("slot" + shape.slot).click();
                            document.getElementById("upgradeShape").click();
                        } else if (player.gold > 0) {
                            let amountNeeded = sliverUpgradesByTier[shape.tier].shapes[shape.level] - player.sliver;
                            let amountToGold = Math.round(amountNeeded / 1250);
                            if (player.gold - amountToGold >= 0) {
                                let answer = prompt(`Not Enough Silver!\nYou Need ${abbreviateNumber(amountNeeded)} Silver!\nUse ${abbreviateNumber(amountToGold)} Gold to make up for the amount of silver missing!\nType "y" or "yes" to confirm.`);
                                if (answer) {
                                    answer = answer.toLocaleLowerCase();
                                    if (answer == "yes" || answer == "y") {
                                        updateMoneyDisplay("sliver", -player.sliver);
                                        updateMoneyDisplay("gold", -amountToGold);
                                        upgradeShape(shape);
                                        document.getElementById("slot" + shape.slot).click();
                                        document.getElementById("upgradeShape").click();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        document.getElementById("changeShape").onclick = function () {
            equipShape(shape.slot, shape.titan);
            saveGameData();
        }
    }
    const SHAPPPPPPPPPE = shape;
    function drawShapeEquip(shapes, currentIndex, oldShape, slot, HA, inInventory) {
        let shape = shapes[currentIndex];
        if (shape && !shape.isItem) {
            shape = new SHAPPPPPPPPPE(shape, null, true);
        }
        let infoDisplayTextThing = `
        Role: <span style="color: #fff">${indexToRole[shape.indexRole || 0]}</span><br>
        Health: ${abbreviateNumber(shape.health)}<br>
        ${shape.builtInDefensePoints ? `Defense Points: ${shape.builtInDefensePoints} (${((1 - defensePointsToResistance(shape.builtInDefensePoints)) * 100).toFixed(1)}% Resistance)<br>` : ""}
        Speed: ${(shape.speed * 1000).toFixed(2)} PX/SEC<br>
        ${shape.additionalHealth ? `Additional Health: ${abbreviateNumber(shape.additionalHealth)}<br>` : ""}
        ${shape.baseShielding ? `${shape.baseShielding.type == "normal" ? "Shield" : "Energy Shield"} Health: ${abbreviateNumber(shape.baseShielding.health)}<br>` : ""}
        ${shape.baseDamageIncrease ? `Base Dmg Increase: ${shape.baseDamageIncrease * 100}%<br>` : ""}
        ${shape.reflectorData ? `
        Reflector Blocked: ${Math.round(shape.reflectorData.resistance * 1e3) / 10}%<br>
        Reflector Returned: ${Math.round(shape.reflectorData.return * 1e3) / 10}%<br>
        ` : ""}
        ${shape.dotResistance ? `DOT Resistance: ${((1 - shape.dotResistance) * 100)}%<br>` : ""}
        ${shape.healingMulti ? `Healing Effectiveness: ${removeDecimals(shape.healingMulti * 100)}%<br>` : ""}
        ${shape.revive ? `Revival Amount: ${removeDecimals(shape.revive * 100)}%<br>` : ""}
        ${shape.healingAura ? `Healing Aura Power: ${abbreviateNumber(shape.healingAura)}<br>` : ""}
        ${shape.hullIntegrity ? `Hull Interity: ${shape.hullIntegrity * 100}%<br>` : ""}
        ${shapeAbilitiesDisplay(shape)}
        `;
        document.getElementById("WEAPONdisplay").innerHTML = `
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(rgb(0, 0, 0, 0), ${tierColor(shape)});">
        </div>
        <div style="position: absolute; display: ${shape.abilities[0]?.name ? "block" : "none"}; left: 80px; top: ${(window.innerHeight / 2) + 50}px; width: 325px; height: 100px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.4);">
        <div id="seeAbilityInfo" style="cursor: pointer; position: absolute; left: 6px; top: 6px; width: 80px; height: 80px; background-size: 80px 80px; border: solid; border-color: #000; border-width: 4px; background-image: url('${shape.abilities[0]?.iconSource}'); border-radius: 100%; background-color: rgb(255, 255, 255, .5);">
        </div>
        <div style="position: absolute; color: #fff; font-size: 26px; left: 100px; top: 0px; width: 225px; height: 100%; display: flex; align-items: center;">
        ${shape.abilities[0]?.name}
        </div>
        </div>
        <div style="position: absolute; display: ${shape.abilities[1]?.name ? "block" : "none"}; left: 80px; top: ${(window.innerHeight / 2) + (210 - 50)}px; width: 325px; height: 100px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.4);">
        <div id="seeAbilityInfo2" style="cursor: pointer; position: absolute; left: 6px; top: 6px; width: 80px; height: 80px; background-size: 80px 80px; border: solid; border-color: #000; border-width: 4px; background-image: url('${shape.abilities[1]?.iconSource}'); border-radius: 100%; background-color: rgb(255, 255, 255, .5);">
        </div>
        <div style="position: absolute; color: #fff; font-size: 26px; left: 100px; top: 0px; width: 225px; height: 100%; display: flex; align-items: center;">
        ${shape.abilities[1]?.name}
        </div>
        </div>
        <div id="abilityDescription" style="position: absolute; display: none; z-index: 100; left: 420px; top: ${(window.innerHeight / 2) - 100}px; width: 325px; height: 250px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(179, 179, 179, 0.3); overflow-y: scroll;">
        <div style="margin-top: 5px; margin-left: 10px; width: 310px;">
        ${shape.abilities[0]?.desc}
        <p></p>
        </div>
        </div>
        <div id="abilityDescription2" style="position: absolute; display: none; z-index: 100; left: 420px; top: ${(window.innerHeight / 2) + 10}px; width: 325px; height: 250px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(179, 179, 179, 0.3); overflow-y: scroll;">
        <div style="margin-top: 5px; margin-left: 10px; width: 310px;">
        ${shape.abilities[1]?.desc}
        <p></p>
        </div>
        </div>
        <div style="position: absolute; overflow-y: scroll; left: 80px; top: ${(window.innerHeight / 2) - 250}px; width: 325px; height: 290px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.4);">
        <div style="position: absolute; top: 7px; left: 5px;">
        <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(shape)};">
        ${shape.level >= 13 && !shape.titan ? 1 : shape.level}
        </div>
        <div style="position: absolute; height: 32.5px; max-height: 32.5px; overflow-y: scroll; top: 2px; width: 260px; left: 45px; color: #fff; font-size: 24px;">
        <strong>
        ${returnStyledName(shape, shape.name)}
        ${shape.level >= 13 && !shape.titan ? `<span style="color: #${levelToMKColor(shape.level)};">${levelToMKText(shape.level)}</span>` : ""}
        </strong>
        </div>
        </div>
        <div style="position: absolute; top: 45px; left: 0px;">
        <hr style="position: absolute; top: 0px; left: 0px; color: #fff; width: 325px;">
        <div style="position: absolute; top: 15px; left: 5px; width: 320px;">
        ${infoDisplayTextThing}
        <p></p>
        </div>
        </div>
        </div>
        <div id="shapeImage" style="position: absolute; left: ${window.innerWidth / 2 - 187.5}px; top: ${window.innerHeight / 2 - 187.5}px; width: 375px; height: 375px;">
        <div id="showDescription" style="position: absolute; cursor: pointer; display: flex; align-items: center; right: 0px; top: 0px; width: 35px; height: 35px; background-color: rgb(255, 255, 255, .4); border-radius: 100%;">
        <div style="width: 100%; color: #fff; text-align: center; font-size: 30px;">
        i
        </div>
        </div>
        </div>
        <div style="position: absolute; overflow-y: scroll; right: 80px; top: ${(window.innerHeight / 2) - 267.5}px; width: 325px; height: 535px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.2);">
        <div style="position: absolute; width: 100%; height: 35px;">
        <div id="switchWeapon" style="position: absolute; font-size: 24px; text-align: center; left: 0px; width: 50%; height: 100%; background-color: rgb(255, 255, 255, .8);">
        WEAPONS
        </div>
        <div id="switchModule" style="position: absolute; cursor: pointer; color: #fff; text-align: center; font-size: 25px; left: 50%; width: 50%; height: 100%; background-color: rgb(0, 0, 0, .3);">
        MODULES
        </div>
        </div>
        <div id="weaponDisplay" style="position: absolute; left: 0px; top: 35px; height: 500px; width: 100%; overflow-y: scroll; background-color: rgb(0, 0, 0, 0.1);">
        </div>
        </div>
        <div id="upgradeMenu" style="position: absolute; z-index: 10000; color: #fff; display: none; top: 12.5%; left: 12.5%; width: 75%; height: 75%; background-color: rgb(0, 0, 0, .7);">
        </div>
        <div id="upgradeShape" style="position: absolute; cursor: pointer; text-align: center; font-size: 35px; color: #fff; left: ${window.innerWidth / 2 + 10}px; bottom: 20px; width: 175px; height: 60px; background-color: rgb(0, 255, 0); border-radius: 6px;">
        UPGRADE
        </div>
        <div id="equipShape" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: ${window.innerWidth / 2 - 185}px; bottom: 20px; width: 175px; height: 60px; background-color: rgb(0, 255, 0); border-radius: 6px;">
        EQUIP
        </div>
        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        <div id="microchipList" style="display: ${shape.titan ? "none" : player.profile.level < 16 ? "none" : inInventory ? player.profile.level < 16 ? "none" : "block" : "none"}; position: absolute; cursor: pointer; font-size: 40px; text-align: center; color: #fff; left: 80px; top: ${window.innerHeight / 2 + (210 - 50)}px; width: 105px; height: 105px; background-color: rgb(0, 0, 0, .4); border: solid; border-color: #fff; border-radius: 6px;">
        <span class="material-symbols-outlined" style="font-size: 100px; color: #fff;">
        developer_board
        </span>
        </div>
        <div id="dronesButton" style="display: ${shape.titan ? "none" : player.profile.level < 10 ? "none" : inInventory ? player.profile.level < 16 ? "none" : "block" : "none"}; position: absolute; cursor: pointer; font-size: 40px; text-align: center; color: #fff; left: 197px; top: ${window.innerHeight / 2 + (210 - 50)}px; width: 105px; height: 105px; background-color: rgb(0, 0, 0, .4); border: solid; border-color: #fff; border-radius: 6px;">
        <span class="material-symbols-outlined" style="font-size: 100px; color: #fff;">
        smart_toy
        </span>
        </div>
        <div style="position: absolute; bottom: 100px; left: 12.5%; width: 75%; height: 6px; background-color: #fff; border-radius: 4px; overflow: hidden;">
        <div style="position: absolute; top: 0px; left: ${(1 / shapes.length) * 100 * currentIndex}%; width: ${(1 / shapes.length) * 100}%; height: 100%; background-color: #03fcec;">
        </div>
        </div>
        <div id="buyShape" style="position: absolute; ${shape.costParts ? "margin-left: -12px; padding-left: 12px; padding-right: 12px;" : ""} display: none; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: ${window.innerWidth / 2 - 87.5}px; bottom: 20px; width: 175px; height: 60px; background-color: rgb(0, 255, 0); border-radius: 6px;">
        ${unlockedAtTier[shape.tier] > player.profile.level ? "LOCKED" : shape.costParts ? "Assemble" : "BUY"}
        </div>
        <div id="buyMenu" style="position: absolute; display: none; color: #fff; top: ${(window.innerHeight / 2) - (225 / 2)}px; left: ${(window.innerWidth / 2) - (425 / 2)}px; width: 425px; height: 225px; background-color: rgb(0, 0, 0, .7);">
        </div>
        <div id="sellItem" style="position: absolute; display: ${!shapes[currentIndex].isItem ? "none" : shape == oldShape ? "none" : "block"}; cursor: pointer; top: ${window.innerHeight / 2 + (267.5 - 50)}px; right: 415px; width: 50px; height: 50px; background-color: rgb(0, 0, 0, .4);">
        <span class="material-symbols-outlined" style="font-size: 50px; color: #fff;">
        delete
        </span>
        </div>
        `;
        document.getElementById("microchipList").onclick = function () {
            doPilotStuff(shape);
        }
        document.getElementById("seeAbilityInfo").onclick = function () {
            let e = document.getElementById("abilityDescription");
            if (e.style.display == "block") {
                e.style.display = "none";
            } else {
                e.style.display = "block";
            }
        }
        document.getElementById("seeAbilityInfo2").onclick = function () {
            let e = document.getElementById("abilityDescription2");
            if (e.style.display == "block") {
                e.style.display = "none";
            } else {
                e.style.display = "block";
            }
        }
        document.getElementById("showDescription").onclick = function () {
            let element = document.createElement("div");
            element.style = `
            position: absolute;
            top: 12.5%;
            left: 12.5%;
            width: 75%;
            height: 75%;
            background-color: rgb(0, 0, 0, 0.75);
            z-index: 99;
            border-radius: 6px;
            `;
            let width = window.innerWidth * .75;
            let height = window.innerHeight * .75;
            let box = width / 2 - 80;
            element.innerHTML = `
            <div style="position: absolute; top: 7px; left: 10px; width: ${width - 10}px;">
            <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(shape)};">
            ${shape.level >= 13 ? 1 : shape.level}
            </div>
            <div style="position: absolute; top: 2px; left: 45px; color: #fff; font-size: 24px;">
            <strong>
            ${returnStyledName(shape, shape.name)}
            ${shape.level >= 13 ? `<span style="color: #${levelToMKColor(shape.level)};">${levelToMKText(shape.level)}</span>` : ""}
            </strong>
            </div>
            </div>
            <div id="imageShape2" style="position: absolute; top: ${(height / 2) - (box / 2)}px; left: 40px; width: ${box}px; height: ${box}px;">
            </div>
            <div style="position: absolute; color: #a3a3a3; top: 0px; left: ${width / 2}px; width: ${width / 2}px; height: 100%; overflow-y: scroll;">
            <div style="margin-top: 5px;">
            <strong style="color: #fff;">Industry: ${shape.industryName || shape.name.split(" ")[shape.name.split(" ").length - 1]}</strong><br><br>
            ${returnStyledName(shape, shape.desc)}<br><br>
            ${shape.abilities.length ? `
            Abilities:<br>
            ${shape.abilities[0]?.desc || ""}<br><br>
            ${shape.abilities[1] ? (shape.abilities[1].desc + "<br><br>") : ""}
            ` : ``}
            Shape Stats:<br>
            ${infoDisplayTextThing}
            <p></p>
            </div>
            </div>
            `;
            document.getElementById("sideDisplay").append(element);
            element.onclick = function () {
                this.remove();
            }
            if (shape.specialOf) {
                document.getElementById(`imageShape2`).style.backgroundSize = `${box}px ${box}px`;
                document.getElementById(`imageShape2`).style.backgroundImage = `url('${shape.specialOf}')`;
            } else {
                let ws = new SHAPPPPPPPPPE(shape, null, true);
                ws.scale *= 10;
                ws.increaseLine = 10;
                let image = getShapeSprite(ws, true);
                image.style = "width: 100%; height: 100%;";
                document.getElementById("imageShape2").appendChild(image);
            }
        }
        if (player.drones.find(e => e.owner == shape.sid)) {
            let Drone = player.drones.find(e => e.owner == shape.sid);
            let newt = new drone(Drone);
            newt.visualData.scale *= 10;
            newt.visualData.increaseLine = 10;
            let image = getShapeSprite(newt.visualData, true);
            image.style = "width: 100%; height: 100%;";
            document.getElementById("dronesButton").innerHTML = "";
            document.getElementById("dronesButton").appendChild(image);

        }
        document.getElementById("dronesButton").onclick = function () {
            customizeDrones(player.drones.find(e => e.owner == shape.sid), shape);
        }
        document.getElementById("sellItem").onclick = function () {
            document.getElementById("buyMenu").style.display = "block";
            let num = 60;
            document.getElementById("buyMenu").innerHTML = `
            <div style="width: 100%; text-align: center; font-size: 30px;">
            Confirm Sale
            </div>
            <hr>
            <div id="lo____l" style="position: absolute; cursor: pointer; top: 5px; right: 10px;">
            x
            </div>

            <div style="position: absolute; top: ${num}px; left: ${425 / 2 - 62.5}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
            <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('${agSource}');">
            </div>
            <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
            ${abbreviateNumber(shape.sellPrice)}
            </div>
            </div>

            <div id="confirm" style="position: absolute; cursor: pointer; font-size: 26px; text-align: center; bottom: 10px; left: ${425 / 2 - 75}px; width: 150px; border-radius: 6px; height: 40px; background-color: #0f0;">
            Confirm
            </div>
            `;
            document.getElementById("confirm").onclick = function () {
                let index = player.shapes.findIndex(e => shape == e);
                updateMoneyDisplay("sliver", shape.sellPrice);
                player.weapons.filter(e => shape.sid == e.owner).forEach(item => {
                    item.owner = null;
                    item.slot = null;
                });
                player.modules.filter(e => shape.sid == e.owner).forEach(item => {
                    item.owner = null;
                    item.slot = null;
                });
                if (slotData[shape.slot]) slotData[shape.slot].used = false;
                player.shapes.splice(index, 1);
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").style.display = "block";
            }
            document.getElementById("lo____l").onclick = function () {
                document.getElementById("buyMenu").style.display = "none";
                document.getElementById("buyMenu").innerHTML = "";
            }
        }
        if (shape.specialOf) {
            document.getElementById(`shapeImage`).style.backgroundSize = `375px 375px`;
            document.getElementById(`shapeImage`).style.backgroundImage = `url('${shape.specialOf}')`;
        } else {
            let image = getShapeSprite(shape, true);
            image.style = "width: 100%; height: 100%;";
            document.getElementById("shapeImage").appendChild(image);
        }
        document.getElementById("storeButton").style.display = "block";
        document.getElementById("inventoryButton").style.display = "block";
        if (currentIndex == 0 && oldShape && shapes[currentIndex].isItem) {
            document.getElementById("equipShape").style.display = "none";
            document.getElementById("upgradeShape").style.left = `${window.innerWidth / 2 - 87.5}px`;
        } else if (!shapes[currentIndex].isItem) {
            document.getElementById("equipShape").style.display = "none";
            document.getElementById("upgradeShape").style.display = "none";
            if (!shapes[currentIndex].dontSell) document.getElementById("buyShape").style.display = "block";
        }
        document.getElementById("buyShape").onclick = function () {
            if (unlockedAtTier[shape.tier] > player.profile.level) return;
            document.body.appendChild(document.getElementById("moneyDisplay"));
            document.getElementById("buyMenu").style.display = "block";
            document.getElementById("storeButton").style.display = "none";
            document.getElementById("inventoryButton").style.display = "none";
            let num = 60;
            let theHA = shapes[currentIndex];
            let parts = (player.parts.shapes[theHA.name] || 0);
            let needed = 10e3;
            if (!theHA.costParts) {
                document.getElementById("buyMenu").innerHTML = `
                <div style="width: 100%; text-align: center; font-size: 30px;">
                Confirm Purchase
                </div>
                <hr>
                <div id="lo____l" style="position: absolute; cursor: pointer; top: 5px; right: 10px;">
                x
                </div>

                <div style="position: absolute; top: ${num}px; left: ${425 / 2 - 62.5}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
                <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('${agSource}');">
                </div>
                <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
                ${abbreviateNumber(theHA.cost.sliver)}
                </div>
                </div>
        
                <div style="position: absolute; top: ${num}px; left: ${425 / 2 - 200}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
                <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('${auSource}');">
                </div>
                <div style="position: absolute; top: 6.75px; left: 40px;  color: #fff;">
                ${abbreviateNumber(theHA.cost.gold)}
                </div>
                </div>
        
                <div style="position: absolute; top: ${num}px; left: ${425 / 2 + 75}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
                <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('./images/icons/workshop.png');">
                </div>
                <div style="position: absolute; top: 6.75px; left: 40px; color: #fff;">
                ${abbreviateNumber(theHA.cost.workshopPoints || 0)}
                </div>
                </div>

                <div id="confirm" style="position: absolute; cursor: pointer; font-size: 24px; text-align: center; bottom: 10px; left: ${425 / 2 - 75}px; width: 150px; border-radius: 6px; height: 40px; background-color: #0f0;">
                Confirm
                </div>
                `;
            } else {
                document.getElementById("buyMenu").innerHTML = `
                <div style="width: 100%; text-align: center; font-size: 30px;">
                Assemble Item
                </div>
                <hr>
                <div id="lo____l" style="position: absolute; cursor: pointer; top: 5px; right: 10px;">
                x
                </div>

                <div style="position: absolute; left: ${425 / 2 - 27.5}px; bottom: 100px;">
                <span class="material-symbols-outlined" style="font-size: 55px;">
                extension
                </span>
                </div>

                <div style="position: absolute; bottom: 70px; width: 385px; height: 15px; left: ${425 / 2 - 192.5}px; background-color: #fff; border-radius: 4px; overflow: hidden;">
                <div style="position: absolute; top: 0px; left: 0px; width: ${Math.min(1, parts / needed) * 100}%; height: 100%; background-color: #00ffff;">
                </div>
                <div style="position: absolute; color: #000; font-size: 12px; top: 0px; left: 0px; text-align: center; width: 100%;">
                ${parts}/${needed}
                </div>
                </div>

                <div id="confirm" style="position: absolute; ${parts / needed < 1 ? "" : "cursor: pointer;"} font-size: 24px; text-align: center; bottom: 10px; left: ${425 / 2 - 75}px; width: 150px; border-radius: 6px; height: 40px; background-color: ${parts / needed < 1 ? "#808080" : "#0f0"};">
                Confirm
                </div>
                `;
            }
            function buy(theThing) {
                if (oldShape) {
                    oldShape.slot = null;
                }
                slotData[slot].used = true;
                let sid = shapeSids;
                player.shapes.push(new SHAPPPPPPPPPE(theThing, slot));
                let hardpoints = theThing.hardpoints.light + theThing.hardpoints.heavy;
                for (let i = 0; i < hardpoints; i++) {
                    if (i < theThing.hardpoints.light && theThing.hardpoints.light > 0) {
                        player.weapons.push(new weapon(weaponData.find(e => e.type == "Light" && e.titan == theThing.titan), sid, i));
                    } else {
                        player.weapons.push(new weapon(weaponData.find(e => e.type == "Heavy" && e.titan == theThing.titan), sid, i));
                    }
                }
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                document.getElementById("hangerUI").style.display = "block";
                updateSlots();
                saveGameData();
            }
            document.getElementById("confirm").onclick = function () {
                let theThing = shapes[currentIndex];
                if (theThing.costParts) {
                    if (parts / needed >= 1) {
                        player.parts.shapes[theHA.name] -= 10e3;
                        buy(theThing);
                    }
                } else {
                    if (player.sliver - theThing.cost.sliver >= 0 && player.gold - theThing.cost.gold >= 0) {
                        if ((!theThing.cost.workshopPoints ? true : player.workshopPoints - theThing.cost.workshopPoints >= 0)) {
                            updateMoneyDisplay("sliver", -theThing.cost.sliver);
                            updateMoneyDisplay("gold", -theThing.cost.gold);
                            updateMoneyDisplay("workshopPoints", -(theThing.cost.workshopPoints || 0));
                            buy(theThing);
                        }
                    }
                }
            }
            document.getElementById("lo____l").onclick = function () {
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                document.getElementById("buyMenu").style.display = "none";
                document.getElementById("storeButton").style.display = "block";
                document.getElementById("inventoryButton").style.display = "block";
            }
        }
        let hardpoints = shape.hardpoints.light + shape.hardpoints.heavy;
        let filteredWeapons = inInventory ? player.weapons.filter(e => e.owner == shape.sid) : [];
        if (!inInventory) {
            for (let i = 0; i < hardpoints; i++) {
                if (i < shape.hardpoints.light && shape.hardpoints.light > 0) {
                    filteredWeapons.push(new weapon(weaponData.find(e => e.type == "Light" && e.titan == shape.titan), null, i));
                } else {
                    filteredWeapons.push(new weapon(weaponData.find(e => e.type == "Heavy" && e.titan == shape.titan), null, i));
                }
            }
        }
        let elements = [];
        let doWeaponsStuff = () => {
            elements = [];
            for (let i = 0; i < hardpoints; i++) {
                let weaponType = "";
                if (i < shape.hardpoints.light && shape.hardpoints.light > 0) {
                    elements.push("LIGHT slot" + i);
                    weaponType = "LIGHT";
                } else {
                    elements.push("HEAVY slot" + i);
                    weaponType = "HEAVY";
                }
                document.getElementById("weaponDisplay").innerHTML += `
                <div id="${weaponType} slot${i}" style="position: relative; ${inInventory ? "cursor: pointer;" : ""} height: ${500 / 4}px; width: 100%; background-color: ${i % 2 ? "rgb(0, 0, 0, 0.2);" : "rgb(255, 255, 255, 0.1);"}}">
                </div>
                `;
            }
            for (let i = 0; i < elements.length; i++) {
                let elementId = elements[i];
                let weapon = filteredWeapons.find(e => e.slot == parseInt(elementId[elementId.length - 1]));
                if (!weapon) {
                    document.getElementById(elementId).innerHTML = `
                    <span style="position: absolute; top: ${125 / 2 - 27}px; left: ${325 / 2 - 135}px; font-size: 40px;">Equip Weapon</span>
                    `;
                    document.getElementById(elementId).onclick = function () {
                        customizeWeapon(elementId.includes("LIGHT") ? "Light" : "Heavy", shape, parseInt(elementId[elementId.length - 1]));
                    }
                } else {
                    let weaponIcon = getWeaponIcon(weapon, true);
                    weaponIcon.style = "width: 125px; height: 125px;";
                    document.getElementById(elementId).appendChild(weaponIcon);
                    document.getElementById(elementId).innerHTML += `
                    <div style="position: absolute; color: ${tierColor(weapon)}; top: 5px; left: 135px; font-size: 24px;">
                    ${weapon.level >= 13 && !shape.titan ? `${returnStyledName(weapon, weapon.name)} <span style="color: ${weapon.level == 13 ? "#0f0" : "#ffff00"};">${weapon.level == 13 ? "MK2" : "MK3"}</span>` : `Lvl ${weapon.level} ${returnStyledName(weapon, weapon.name)}`}
                    <div style="color: #fff; font-size: 14px; margin-top: -5px;">${elementId.includes("LIGHT") ? "Light" : "Heavy"}</div>
                    </div>
                    `;
                    if (inInventory) {
                        document.getElementById(elementId).onclick = function () {
                            customizeWeapon(weapon, shape, parseInt(elementId[elementId.length - 1]));
                        }
                    }
                }
            }
        }
        document.getElementById("switchWeapon").onclick = function () {
            this.style.cursor = null;
            this.style.color = "#000";
            this.style.backgroundColor = "rgb(255, 255, 255, .8)";
            document.getElementById("switchModule").style.color = "#fff";
            document.getElementById("switchModule").style.cursor = "pointer";
            document.getElementById("switchModule").style.backgroundColor = "rgb(0, 0, 0, .3)";
            document.getElementById("weaponDisplay").innerHTML = "";
            doWeaponsStuff();
        }
        let filteredModules = inInventory ? player.modules.filter(e => e.owner == shape.sid) : [];
        let moduleHardpoints = (shape.moduleHardpoints || 0);
        document.getElementById("switchModule").onclick = function () {
            this.style.cursor = null;
            this.style.color = "#000";
            this.style.backgroundColor = "rgb(255, 255, 255, .8)";
            document.getElementById("switchWeapon").style.color = "#fff";
            document.getElementById("switchWeapon").style.cursor = "pointer";
            document.getElementById("switchWeapon").style.backgroundColor = "rgb(0, 0, 0, .3)";
            document.getElementById("weaponDisplay").innerHTML = "";
            let elements = [];
            for (let i = 0; i < moduleHardpoints; i++) {
                document.getElementById("weaponDisplay").innerHTML += `
                <div id="moduleSlot${i}" style="position: relative; ${inInventory ? "cursor: pointer;" : ""} height: ${500 / 4}px; width: 100%; background-color: ${i % 2 ? "rgb(0, 0, 0, 0.2);" : "rgb(255, 255, 255, 0.1);"}}">
                </div>
                `;
                elements.push(`moduleSlot${i}`);
            }
            for (let i = 0; i < elements.length; i++) {
                let elementId = elements[i];
                let module = filteredModules.find(e => e.slot == parseInt(elementId[elementId.length - 1]));
                if (!module) {
                    document.getElementById(elementId).innerHTML = `
                    <span style="position: absolute; top: ${125 / 2 - 27}px; left: 35.25px; font-size: 40px;">
                    Equip Module
                    </span>
                    `;
                } else {
                    let moduleIcon = getWeaponIcon(module, true);
                    moduleIcon.style = "width: 125px; height: 125px;";
                    document.getElementById(elementId).appendChild(moduleIcon);
                    document.getElementById(elementId).innerHTML += `
                    <div style="position: absolute; top: 5px; color: ${tierColor(module)}; left: 135px; font-size: 24px;">
                    Lvl ${module.level} ${module.name}
                    </div>
                    `;
                }
                if (inInventory) {
                    document.getElementById(elementId).onclick = function () {
                        if (player.modules.filter(e => e.owner == null).length || module) {
                            customizeModule(module, shape, parseInt(elementId[elementId.length - 1]));
                        } else {
                            alert("You have no modules in inventory.")
                        }
                    };
                }
            }
        }
        doWeaponsStuff();
        document.getElementById("backButton").onclick = function () {
            if (oldShape) {
                document.getElementById("slot" + oldShape.slot).click();
            } else {
                document.getElementById("hangerUI").style.display = "block";
                document.getElementById("sideDisplay").innerHTML = "";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
        }
        document.getElementById("upgradeShape").onclick = function () {
            document.body.appendChild(document.getElementById("moneyDisplay"));
            let adjustwidth = window.innerWidth * .75;
            document.getElementById("upgradeMenu").style.display = "block";
            let titanUpgradeCost = (shape.level * (120 * ((shape.tier + 1) * .25)) + Math.ceil(shape.level / 5) * 1200) * (shape.tier + 1);
            document.getElementById("upgradeMenu").innerHTML = `
            <div style="width: 100%; text-align: center; margin-top: 5px; font-size: 30px;">
            ${[14, 13].includes(shape.level) ? `${shape.name} <span style="color: ${shape.level == 13 ? "#0f0" : "#ffff00"};">${shape.level == 13 ? "MK2" : "MK3"}</span>` : `Lvl ${shape.level} ${shape.name}`}
            </div>
            <hr>
            <div style="position: absolute; left: 300px; top: 65px;">
            ${enterBarForShape("health", shape)}
            ${enterBarForShape("speed", shape)}
            ${enterBarForShape("additional health norm", shape)}
            ${enterBarForShape("built-in defense points", shape)}
            ${enterBarForShape("healingMulti", shape)}
            ${enterBarForShape("ability damage", shape)}
            ${enterBarForShape("ability dot damage", shape)}
            ${enterBarForShape("shield hp", shape)}
            ${enterBarForShape("ashield hp", shape)}
            ${enterBarForShape("healing aura", shape)}
            ${enterBarForShape("lasting time", shape)}
            ${enterBarForShape("ability effect duration", shape)}
            ${enterBarForShape("defense points ability", shape)}
            ${enterBarForShape("abilityHealthMulti", shape)}
            ${enterBarForShape("ability effect acc", shape)}
            ${enterBarForShape("ability suppression", shape)}
            ${enterBarForShape("ability healing power", shape)}
            ${enterBarForShape("additionalHealthData", shape)}
            ${enterBarForShape("executionThresholdData", shape)}
            ${enterBarForShape("effectAccumulationData", shape)}
            ${enterBarForShape("healingPercent", shape)}
            ${enterBarForShape("durabilityLimitData", shape)}
            ${enterBarForShape("deathmark", shape)}
            </div>
            <div id="leaveUpgrade" style="position: absolute; cursor: pointer; right: 10px; top: 10px;">
            X
            </div>
            <div id="UPGRADE" style="position: absolute; width: 200px; height: 80px; cursor: pointer; left: ${adjustwidth / 2 - 100}px; bottom: 10px; background-color: ${shape.level < 25 && shape.titan ? "#00ff00" : sliverUpgradesByTier[shape.tier].shapes[shape.level] ? "#00ff00" : [12, 13].includes(shape.level) ? "#ffff00" : "#808080"};">
            <div style="width: 100%; text-align: center; color: ${shape.level < 25 && shape.titan ? "#fff" : [12, 13].includes(shape.level) ? "#f00" : "#fff"}; font-size: ${shape.level < 25 && shape.titan ? "24" : sliverUpgradesByTier[shape.tier].shapes[shape.level] ? "24" : [12, 13].includes(shape.level) ? "24" : "40"}px; margin-top: ${shape.level < 25 && shape.titan ? "5" : sliverUpgradesByTier[shape.tier].shapes[shape.level] ? "5" : shape.level == 12 ? "5" : "10"}px;">${shape.level < 25 && shape.titan ? "UPGRADE" : sliverUpgradesByTier[shape.tier].shapes[shape.level] ? "UPGRADE" : [12, 13].includes(shape.level) ? "ENHANCE" : "MAXED"}</div>
            <div style="color: ${shape.level < 25 && shape.titan ? "#fff" : [12, 13].includes(shape.level) ? "#f00" : "#fff"}; display: ${shape.level < 25 && shape.titan ? "block" : sliverUpgradesByTier[shape.tier].shapes[shape.level] ? "block" : [12, 13].includes(shape.level) ? "block" : "none"}; width: 100%; text-align: center; font-size: 12px;">${shape.level < 25 && shape.titan ? `${abbreviateNumber(titanUpgradeCost)} WSP` : [12, 13].includes(shape.level) ? `${abbreviateNumber(shape.enhanceCost * (shape.level == 13 ? 24 : 1))} Gold` : `${abbreviateNumber(sliverUpgradesByTier[shape.tier].shapes[shape.level])} Sliver`}</div>
            </div>
            `;
            if (shape.specialOf) {
                document.getElementById(`upgradeMenu`).style.backgroundPosition = "0px 80px";
                document.getElementById(`upgradeMenu`).style.backgroundRepeat = "no-repeat";
                document.getElementById(`upgradeMenu`).style.backgroundSize = `280px 280px`;
                document.getElementById(`upgradeMenu`).style.backgroundImage = `url('${shape.specialOf}')`;
            } else {
                let sprite = getShapeSprite(shape, true);
                sprite.style = "width: 280px; height: 280px;";
                document.getElementById("upgradeMenu").appendChild(sprite);
            }
            document.getElementById("leaveUpgrade").onclick = function () {
                document.getElementById("upgradeMenu").style.display = "none";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            }
            document.getElementById("UPGRADE").onclick = function () {
                if (shape.titan) {
                    if (shape.level < 25 && player.workshopPoints - titanUpgradeCost >= 0) {
                        updateMoneyDisplay("workshopPoints", -titanUpgradeCost);
                        upgradeShape(shape);
                        drawShapeEquip(shapes, currentIndex, oldShape, slot, true);
                    }
                } else if (sliverUpgradesByTier[shape.tier].shapes[shape.level] || shape.level == 12 || shape.level == 13) {
                    if (shape.level >= 12) {
                        if (player.gold - (shape.enhanceCost * (shape.level == 13 ? 24 : 1)) >= 0) {
                            updateMoneyDisplay("gold", -(shape.enhanceCost * (shape.level == 13 ? 24 : 1)));
                            upgradeShape(shape);
                            drawShapeEquip(shapes, currentIndex, oldShape, slot, true);
                        }
                    } else {
                        if (player.sliver - sliverUpgradesByTier[shape.tier].shapes[shape.level] >= 0) {
                            updateMoneyDisplay("sliver", -sliverUpgradesByTier[shape.tier].shapes[shape.level]);
                            upgradeShape(shape);
                            drawShapeEquip(shapes, currentIndex, oldShape, slot, true);
                        } else if (player.gold > 0) {
                            let amountNeeded = sliverUpgradesByTier[shape.tier].shapes[shape.level] - player.sliver;
                            let amountToGold = Math.round(amountNeeded / 1250);
                            if (player.gold - amountToGold >= 0) {
                                let answer = prompt(`Not Enough Silver!\nYou Need ${abbreviateNumber(amountNeeded)} Silver!\nUse ${abbreviateNumber(amountToGold)} Gold to make up for the amount of silver missing!\nType "y" or "yes" to confirm.`);
                                if (answer) {
                                    answer = answer.toLocaleLowerCase();
                                    if (answer == "yes" || answer == "y") {
                                        updateMoneyDisplay("sliver", -player.sliver);
                                        updateMoneyDisplay("gold", -amountToGold);
                                        upgradeShape(shape);
                                        drawShapeEquip(shapes, currentIndex, oldShape, slot, true);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        document.getElementById("equipShape").onclick = function () {
            shapes[currentIndex].slot = slot;
            slotData[slot].used = true;
            if (oldShape) {
                oldShape.slot = null;
            }
            document.getElementById("sideDisplay").innerHTML = "";
            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            updateSlots();
            document.getElementById("slot" + slot).click();
            saveGameData();
        }
        if (HA) {
            document.getElementById("upgradeShape").click();
        }
    }
    var rarityToChance = {
        "Common": .9,
        "Rare": .5,
        "Epic": .3,
        "Legendary": .15,
        "Mythic": .07
    };
    var rarityToTier = {
        "Common": 0,
        "Rare": 1,
        "Epic": 2,
        "Legendary": 3,
        "Mythic": 4
    };
    var lootboxes = [{
        name: "Basic Box",
        desc: "The most affordable chest to open, often chosen by aspiring commanders in the early stages of their illustrious journey. Many great commanders have embarked on their path to glory by opening this very chest.",
        source: "./images/lootbox/basic_lootbox.png",
        rewards: [{
            type: "silver", rarity: "Common", value: 15e3
        }, {
            type: "silver", rarity: "Common", value: 10e3
        }, {
            type: "silver", rarity: "Common", value: 20e3
        }, {
            type: "silver", rarity: "Epic", value: 100e3
        }, {
            type: "gold", rarity: "Common", value: 5
        }, {
            type: "gold", rarity: "Common", value: 10
        }, {
            type: "gold", rarity: "Common", value: 15
        }, {
            type: "keys", rarity: "Common", value: 8
        }, {
            type: "keys", rarity: "Rare", value: 20
        }, {
            type: "keys", rarity: "Epic", value: 100
        }, {
            type: "workshop points", rarity: "Rare", value: 120
        }, {
            type: "workshop points", rarity: "Legendary", value: 1e3
        }, {
            type: "weapon", rarity: "Legendary", name: "Taran"
        }, {
            type: "weapon", rarity: "Rare", name: "Punisher"
        }, {
            type: "weapon", rarity: "Rare", name: "Destroyer"
        }],
        cost: 10
    }, {
        name: "Copper Box",
        desc: "An ideal choice for the early game, this chest delivers a substantial amount of resources, offering valuable support for your initial journey.",
        source: "./images/lootbox/copper_lootbox.png",
        rewards: [{
            type: "silver", rarity: "Common", value: 100e3
        }, {
            type: "silver", rarity: "Common", value: 200e3
        }, {
            type: "gold", rarity: "Common", value: 30
        }, {
            type: "gold", rarity: "Common", value: 70
        }, {
            type: "gold", rarity: "Common", value: 100
        }, {
            type: "keys", rarity: "Rare", value: 500
        }, {
            type: "keys", rarity: "Epic", value: 1e3
        }, {
            type: "weapon", rarity: "Rare", name: "Taran"
        }, {
            type: "weapon", rarity: "Rare", name: "Destroyer"
        }, {
            type: "weapon", rarity: "Rare", name: "Landslide"
        }, {
            type: "weapon", rarity: "Rare", name: "Ancile"
        }, {
            type: "workshop points", rarity: "Rare", value: 1200
        }, {
            type: "workshop points", rarity: "Epic", value: 3600
        }, {
            type: "silver", rarity: "Legendary", value: 700e3
        }, {
            type: "silver", rarity: "Legendary", value: 1e6
        }, {
            type: "silver", rarity: "Mythic", value: 10e6
        }, {
            type: "gold", rarity: "Mythic", value: 5e3
        }, {
            type: "weapon", rarity: "Epic", name: "Thunder"
        }, {
            type: "weapon", rarity: "Epic", name: "Storm"
        }, {
            type: "weapon", rarity: "Epic", name: "Blaze"
        }, {
            type: "weapon", rarity: "Epic", name: "Ember"
        }, {
            type: "weapon", rarity: "Epic", name: "Sting"
        }, {
            type: "weapon", rarity: "Epic", name: "Viper"
        }, {
            type: "shape", rarity: "Rare", name: "Yellow Circle"
        }, {
            type: "shape", rarity: "Rare", name: "Green Circle"
        }],
        cost: 100
    }, {
        name: "Gold Box",
        desc: "Chest that contains shape accessories like modules, weapons, and drones. You can also earn shapes as well.",
        source: "./images/lootbox/gold_lootbox.png",
        rewards: [{
            type: "gold", rarity: "Rare", value: 1e3
        }, {
            type: "silver", rarity: "Common", value: 1e6
        }, {
            type: "gold", rarity: "Rare", value: 5e3
        }, {
            type: "workshop points", rarity: "Common", value: 1200
        }, {
            type: "silver", rarity: "Rare", value: 10e6
        }, {
            type: "silver", rarity: "Common", value: 5e6
        }, {
            type: "workshop points", rarity: "Epic", value: 8e3
        }, {
            type: "weapon", rarity: "Rare", name: "Glaive"
        }, {
            type: "weapon", rarity: "Rare", name: "Lance"
        }, {
            type: "weapon", rarity: "Rare", name: "Scatter"
        }, {
            type: "weapon", rarity: "Rare", name: "Devastator"
        }, {
            type: "weapon", rarity: "Rare", name: "Toxin"
        }, {
            type: "weapon", rarity: "Rare", name: "Bane"
        }, {
            type: "weapon", rarity: "Rare", name: "Slumber"
        }, {
            type: "weapon", rarity: "Rare", name: "Delay"
        }, {
            type: "weapon", rarity: "Rare", name: "Rime"
        }, {
            type: "weapon", rarity: "Rare", name: "Glacier"
        }, {
            type: "weapon", rarity: "Rare", name: "Reaper"
        }, {
            type: "weapon", rarity: "Rare", name: "Scald"
        }, {
            type: "weapon", rarity: "Rare", name: "Incinerator"
        }, {
            type: "weapon", rarity: "Common", name: "Razor"
        }, {
            type: "weapon", rarity: "Common", name: "Smuta"
        }, {
            type: "weapon", rarity: "Common", name: "Atomizer"
        }, {
            type: "weapon", rarity: "Common", name: "Nucleon"
        }, {
            type: "weapon", rarity: "Legendary", name: "Evora"
        }, {
            type: "weapon", rarity: "Legendary", name: "Veyron"
        }, {
            type: "weapon", rarity: "Legendary", name: "Brisant"
        }, {
            type: "weapon", rarity: "Legendary", name: "Shatter"
        }, {
            type: "weapon", rarity: "Legendary", name: "Trickster"
        }, {
            type: "weapon", rarity: "Legendary", name: "Tamer"
        }, {
            type: "weapon", rarity: "Epic", name: "Damper"
        }, {
            type: "weapon", rarity: "Epic", name: "Deceiver"
        }, {
            type: "token", rarity: "Mythic", mk: 1, value: 3
        }, {
            type: "silver", rarity: "Mythic", value: 50e6
        }, {
            type: "shape", rarity: "Legendary", name: "Gold Circle"
        }, {
            type: "shape", rarity: "Legendary", name: "Orange Circle"
        }, {
            type: "shape", rarity: "Mythic", name: "Pumpkin Orange Circle"
        }, {
            type: "module", rarity: "Common", name: "Heavy Armor Plating"
        }, {
            type: "module", rarity: "Common", name: "Thermonuclear Reactor"
        }, {
            type: "module", rarity: "Epic", name: "Nuclear Amplifier"
        }, {
            type: "module", rarity: "Epic", name: "Repair Amplifier"
        }, {
            type: "module", rarity: "Epic", name: "Immune Amplifier"
        }, {
            type: "module", rarity: "Epic", name: "Last Stand"
        }, {
            type: "module", rarity: "Epic", name: "Anti Control"
        }, {
            type: "module", rarity: "Epic", name: "Damage Controller"
        }, {
            type: "drone", rarity: "Mythic", name: "Pascal"
        }, {
            type: "drone", rarity: "Epic", name: "Beak"
        }, {
            type: "drone", rarity: "Epic", name: "Armadillo"
        }],
        cost: 1e3
    }, {
        name: "Diamond Box",
        desc: "Elite chest that only the richest commanders can purchase. It contains not only the best equipment, but a lot of resources as well!",
        source: "./images/lootbox/diamond_lootbox.png",
        rewards: [{
            type: "token", rarity: "Epic", mk: 1, value: 3
        }, {
            type: "token", rarity: "Mythic", mk: 3, value: 3
        }, {
            type: "token", rarity: "Legendary", mk: 2, value: 3
        }, {
            type: "silver", rarity: "Common", value: 10e6
        }, {
            type: "silver", rarity: "Rare", value: 50e6
        }, {
            type: "gold", rarity: "Rare", value: 8e3
        }, {
            type: "gold", rarity: "Common", value: 3e3
        }, {
            type: "shape", rarity: "Rare", name: "Orange Circle"
        }, {
            type: "shape", rarity: "Common", name: "Brown Pentagon"
        }, {
            type: "shape", rarity: "Common", name: "Gray Heptagon"
        }, {
            type: "weapon", rarity: "Epic", name: "Veyron"
        }, {
            type: "weapon", rarity: "Epic", name: "Evora"
        }, {
            type: "weapon", rarity: "Epic", name: "Shatter"
        }, {
            type: "weapon", rarity: "Epic", name: "Brisant"
        }, {
            type: "weapon", rarity: "Epic", name: "Trickster"
        }, {
            type: "weapon", rarity: "Epic", name: "Tamer"
        }, {
            type: "weapon", rarity: "Rare", name: "Damper"
        }, {
            type: "weapon", rarity: "Rare", name: "Deceiver"
        }, {
            type: "shape", rarity: "Legendary", name: "Gray Pentagon"
        }, {
            type: "shape", rarity: "Legendary", name: "Pinkish-Red Circle"
        }, {
            type: "shape", rarity: "Epic", name: "Gold Circle"
        }, {
            type: "shape", rarity: "Common", name: "Purple Hexagon"
        }, {
            type: "shape", rarity: "Common", name: "Yellow Hexagon"
        }, {
            type: "shape", rarity: "Legendary", name: "Magenta Circle"
        }, {
            type: "shape", rarity: "Legendary", name: "Cyan Hexagon"
        }, {
            type: "shape", rarity: "Epic", name: "Cyan Pentagon"
        }, {
            type: "shape", rarity: "Legendary", name: "Ultimate Green Circle"
        }, {
            type: "shape", rarity: "Legendary", name: "Tan Circle"
        }, {
            type: "workshop points", rarity: "Mythic", value: 20e3
        }, {
            type: "workshop points", rarity: "Mythic", value: 15e3
        }, {
            type: "gold", rarity: "Mythic", value: 40e3
        }, {
            type: "silver", rarity: "Mythic", value: 150e6
        }, {
            type: "weapon", rarity: "Epic", name: "Labrys"
        }, {
            type: "weapon", rarity: "Epic", name: "Cestus"
        }, {
            type: "weapon", rarity: "Legendary", name: "Tumultus"
        }, {
            type: "weapon", rarity: "Legendary", name: "Discordia"
        }, {
            type: "drone", rarity: "Epic", name: "Pascal"
        }, {
            type: "drone", rarity: "Rare", name: "Beak"
        }],
        cost: 10e3
    }, {
        name: "Ultimate Box",
        desc: "After the discovery of chest-generated XP, industries have found numerous great uses for it. Although chest-generated XP (or CGXP) is highly valued, its true potential is realized when amassed in sizable quantities. Commanders, in their pursuit of loot boxes, are encouraged to collect and contribute the accumulated CGXP to the Industries. Doing so grants them additional benefits and rewards, particularly when they amass enough to form substantial pods.",
        source: "./images/lootbox/ulimate_lootbox.png",
        rewards: [{
            type: "silver", rarity: "Common", value: 20e6
        }, {
            type: "silver", rarity: "Common", value: 15e6
        }, {
            type: "gold", rarity: "Common", value: 10e3
        }, {
            type: "workshop points", rarity: "Common", value: 5e3
        }, {
            type: "gold", rarity: "Rare", value: 20e3
        }, {
            type: "silver", rarity: "Rare", value: 50e6
        }, {
            type: "drone", rarity: "Rare", name: "Beak"
        }, {
            type: "shape", rarity: "Epic", name: "Gray Pentagon"
        }, {
            type: "weapon", rarity: "Rare", name: "Tumultus"
        }, {
            type: "weapon", rarity: "Rare", name: "Discordia"
        }, {
            type: "weapon", rarity: "Rare", name: "Labrys"
        }, {
            type: "weapon", rarity: "Rare", name: "Cestus"
        }, {
            type: "weapon", rarity: "Rare", name: "Veyron"
        }, {
            type: "weapon", rarity: "Rare", name: "Evora"
        }, {
            type: "weapon", rarity: "Rare", name: "Shatter"
        }, {
            type: "weapon", rarity: "Rare", name: "Brisant"
        }, {
            type: "weapon", rarity: "Rare", name: "Trickster"
        }, {
            type: "weapon", rarity: "Rare", name: "Tamer"
        }, {
            type: "weapon", rarity: "Common", name: "Damper"
        }, {
            type: "weapon", rarity: "Common", name: "Deceiver"
        }, {
            type: "module", rarity: "Rare", name: "Nuclear Amplifier"
        }, {
            type: "module", rarity: "Rare", name: "Repair Amplifier"
        }, {
            type: "module", rarity: "Rare", name: "Immune Amplifier"
        }, {
            type: "token", rarity: "Epic", mk: 1, value: 3
        }, {
            type: "token", rarity: "Legendary", mk: 2, value: 3
        }, {
            type: "token", rarity: "Mythic", mk: 3, value: 3
        }, {
            type: "shape", rarity: "Epic", name: "Magenta Circle"
        }, {
            type: "shape", rarity: "Epic", name: "Cyan Hexagon"
        }, {
            type: "shape", rarity: "Epic", name: "Tan Circle"
        }, {
            type: "shape", rarity: "Epic", name: "Ultimate Green Circle"
        }, {
            type: "drone", rarity: "Epic", name: "Pascal"
        }, {
            type: "drone", rarity: "Rare", name: "Beak"
        }, {
            type: "module", rarity: "Epic", name: "Defense Amplifier"
        }, {
            type: "drone", rarity: "Epic", name: "Kestrel"
        }, {
            type: "drone", rarity: "Epic", name: "Bulwark"
        }]
    }, {
        name: "MK1 Data Box",
        desc: `
        Data Boxes are a universal data storage technology. The encoded boxes contains many benefits that can be converted into shapes, drones, equipment, and more. There are 3 types of these data boxes: MK1, MK2, and MK3.
        <br><br>
        MK1 Data Box, a data box that only contains resources like gold and silver.
        `,
        source: "./images/tokens/token_chests/mk1_chest.png",
        rewards: [{
            type: "silver", rarity: "Common", value: 1e6
        }, {
            type: "silver", rarity: "Common", value: 2e6
        }, {
            type: "silver", rarity: "Common", value: 4e6
        }, {
            type: "gold", rarity: "Common", value: 500
        }, {
            type: "gold", rarity: "Common", value: 1e3
        }, {
            type: "workshop points", rarity: "Mythic", value: 50e3
        }, {
            type: "silver", rarity: "Mythic", value: 100e6
        }, {
            type: "keys", rarity: "Rare", value: 1e3
        }, {
            type: "keys", rarity: "Rare", value: 2e3
        }, {
            type: "keys", rarity: "Epic", value: 5e3
        }, {
            type: "workshop points", rarity: "Rare", value: 3e3
        }, {
            type: "token", rarity: "Legendary", mk: 2, value: 3
        }, {
            type: "token", rarity: "Mythic", mk: 3, value: 3
        }, {
            type: "silver", rarity: "Epic", value: 50e6
        }, {
            type: "gold", rarity: "Epic", value: 10e3
        }, {
            type: "gold", rarity: "Legendary", value: 25e3
        }, {
            type: "workshop points", rarity: "Legendary", value: 15e3
        }],
        tokenCost: "token 1"
    }, {
        name: "MK2 Data Box",
        desc: `
        Data Boxes are a universal data storage technology. The encoded boxes contains many benefits that can be converted into shapes, drones, equipment, and more. There are 3 types of these data boxes: MK1, MK2, and MK3.
        <br><br>
        MK2 Data Box, a data box that only contains shape accessories like drones, modules, pilots, and weapons.
        `,
        source: "./images/tokens/token_chests/mk2_chest.png",
        rewards: [{
            type: "weapon", rarity: "Common", name: "Rime"
        }, {
            type: "weapon", rarity: "Common", name: "Glacier"
        }, {
            type: "drone", rarity: "Common", name: "Starter"
        }, {
            type: "drone", rarity: "Epic", name: "Pascal"
        }, {
            type: "drone", rarity: "Epic", name: "Kestrel"
        }, {
            type: "drone", rarity: "Rare", name: "Beak"
        }, {
            type: "drone", rarity: "Rare", name: "Armadillo"
        }, {
            type: "weapon", rarity: "Rare", name: "Veyron"
        }, {
            type: "weapon", rarity: "Rare", name: "Evora"
        }, {
            type: "weapon", rarity: "Rare", name: "Brisant"
        }, {
            type: "weapon", rarity: "Rare", name: "Shatter"
        }, {
            type: "weapon", rarity: "Rare", name: "Tamer"
        }, {
            type: "weapon", rarity: "Rare", name: "Damper"
        }, {
            type: "weapon", rarity: "Rare", name: "Trickster"
        }, {
            type: "weapon", rarity: "Rare", name: "Deceiver"
        }, {
            type: "weapon", rarity: "Rare", name: "Discordia"
        }, {
            type: "weapon", rarity: "Rare", name: "Tumultus"
        }, {
            type: "weapon", rarity: "Rare", name: "Labrys"
        }, {
            type: "weapon", rarity: "Rare", name: "Cestus"
        }, {
            type: "weapon", rarity: "Common", name: "Reaper"
        }, {
            type: "weapon", rarity: "Common", name: "Flux"
        }, {
            type: "weapon", rarity: "Common", name: "Lance"
        }, {
            type: "weapon", rarity: "Common", name: "Glaive"
        }, {
            type: "token", rarity: "Legendary", mk: 3, value: 3
        }, {
            type: "weapon", rarity: "Epic", name: "Maha Vajra"
        }, {
            type: "weapon", rarity: "Epic", name: "Vajra"
        }, {
            type: "module", rarity: "Legendary", name: "Defense Amplifier"
        }, {
            type: "weapon", rarity: "Legendary", name: "Subduer"
        }, {
            type: "weapon", rarity: "Legendary", name: "Grief"
        }, {
            type: "weapon", rarity: "Legendary", name: "Sorrow"
        }, {
            type: "weapon", rarity: "Common", name: "Jaw"
        }, {
            type: "weapon", rarity: "Common", name: "Talon"
        }, {
            type: "weapon", rarity: "Epic", name: "Fengbao"
        }, {
            type: "weapon", rarity: "Epic", name: "Leiming"
        }, {
            type: "weapon", rarity: "Legendary", name: "Inferno"
        }, {
            type: "weapon", rarity: "Legendary", name: "Pyro"
        }, {
            type: "drone", rarity: "Legendary", name: "Bulwark"
        }, {
            type: "weapon", rarity: "Epic", name: "Hammer"
        }, {
            type: "weapon", rarity: "Epic", name: "Mace"
        }, {
            type: "weapon", rarity: "Legendary", name: "Disintegrator"
        }, {
            type: "weapon", rarity: "Legendary", name: "Havoc"
        }, {
            type: "module", rarity: "Epic", name: "Grand Balance Reactor"
        }, {
            type: "weapon", rarity: "Legendary", name: "Igniter"
        }, {
            type: "weapon", rarity: "Legendary", name: "Discharger"
        }, {
            type: "weapon", rarity: "Legendary", name: "Athos"
        }, {
            type: "weapon", rarity: "Legendary", name: "Aramis"
        }, {
            type: "drone", rarity: "Epic", name: "Hawkeye"
        }],
        tokenCost: "token 2"
    }, {
        name: "MK3 Data Box",
        desc: `
        Data Boxes are a universal data storage technology. The encoded boxes contains many benefits that can be converted into shapes, drones, equipment, and more. There are 3 types of these data boxes: MK1, MK2, and MK3.
        <br><br>
        MK3 Data Box, a data box that only contains shapes.
        `,
        source: "./images/tokens/token_chests/mk3_chest.png",
        rewards: [{
            type: "shape", rarity: "Rare", name: "Dark Brown Pentagon"
        }, {
            type: "shape", rarity: "Rare", name: "Ultimate Green Circle",
        }, {
            type: "shape", rarity: "Rare", name: "Cyan Heptagon",
        }, {
            type: "shape", rarity: "Common", name: "Blue Heptagon",
        }, {
            type: "shape", rarity: "Rare", name: "Magenta Circle",
        }, {
            type: "shape", rarity: "Common", name: "Gray Heptagon",
        }, {
            type: "shape", rarity: "Epic", name: "Ultimate Teal Circle",
        }, {
            type: "shape", rarity: "Rare", name: "Ultimate Tan Pentagon",
        }, {
            type: "shape", rarity: "Common", name: "Yellow Hexagon",
        }, {
            type: "shape", rarity: "Common", name: "Purple Hexagon",
        }, {
            type: "shape", rarity: "Epic", name: "Purple Heptagon",
        }, {
            type: "shape", rarity: "Rare", name: "Blue-Outlined Tan Circle"
        }, {
            type: "shape", rarity: "Epic", name: "Dark Green Pentagon"
        }, {
            type: "shape", rarity: "Epic", name: "Dark Tan Circle"
        }, {
            type: "shape", rarity: "Common", name: "Light Blue Triangle"
        }, {
            type: "shape", rarity: "Common", name: "Ultimate Gray Circle"
        }, {
            type: "shape", rarity: "Epic", name: "Purple Pentagon"
        }, {
            type: "shape", rarity: "Legendary", name: "Ultimate Brown Pentagon"
        }, {
            type: "shape", rarity: "Rare", name: "Orange Heptagon"
        }, {
            type: "shape", rarity: "Epic", name: "Teal Pentagon"
        }, {
            type: "shape", rarity: "Epic", name: "Blue Triangle"
        }, {
            type: "shape", rarity: "Legendary", name: "Indra"
        }, {
            type: "shape", rarity: "Legendary", name: "Light Gray Heptagon"
        }, {
            type: "shape", rarity: "Legendary", name: "Bersagliere"
        }, {
            type: "shape", rarity: "Mythic", name: "Luchador"
        }, {
            type: "shape", rarity: "Mythic", name: "Eiffel"
        }],
        tokenCost: "token 3"
    }];
    function lootboxGetItem(reward) {
        if (reward.type == "shape") {
            let sid = shapeSids;
            let Shape = shapeData.find(e => reward.name == e.name);
            player.shapes.push(new shape(Shape));
            let hardpoints = Shape.hardpoints.light + Shape.hardpoints.heavy;
            for (let i = 0; i < hardpoints; i++) {
                if (i < Shape.hardpoints.light && Shape.hardpoints.light > 0) {
                    player.weapons.push(new weapon(weaponData[0], sid, i));
                } else {
                    player.weapons.push(new weapon(weaponData[2], sid, i));
                }
            }
        } else if (reward.type == "weapon") {
            player.weapons.push(new weapon(weaponData.find(e => reward.name == e.name), null, null));
        } else if (reward.type == "module") {
            player.modules.push(new module(moduleData.find(e => reward.name == e.name), null, null));
        } else if (reward.type == "token") {
            updateMoneyDisplay(`token ${reward.mk}`, reward.value);
        } else if (reward.type == "silver") {
            updateMoneyDisplay("sliver", reward.value);
        } else if (reward.type == "drone") {
            player.drones.push(new drone(dronesData.find(e => reward.name == e.name), null, null));
        } else {
            updateMoneyDisplay(reward.type, reward.value);
        }
    }
    function getBackgroundImage(reward) {
        if (reward.type == "silver" || reward.type == "gold") {
            return {
                type: "background",
                source: `./images/icons/${reward.type == "gold" ? "au" : "ag"}_icon.png`,
                color: "rgb(255, 255, 255, .1)",
                textColor: "#fff",
                shadowColor: "#000"
            }
        } else if (reward.type == "keys" || reward.type == "workshop points") {
            return {
                type: "background",
                source: `./images/icons/${reward.type == "workshop points" ? "workshop" : "keys_icon"}.png`,
                color: "rgb(255, 255, 255, .1)",
                textColor: "#fff",
                shadowColor: "#000"
            }
        } else if (reward.type == "weapon" || reward.type == "module") {
            return {
                type: "background",
                source: reward.type == "module" ? moduleData.find(e => e.name == reward.name).imageSource : weaponData.find(e => e.name == reward.name).imageSource,
                color: "rgb(255, 255, 255, .1)",
                textColor: "#fff",
                shadowColor: "#000",
                tier: reward.type == "module" ? moduleData.find(e => e.name == reward.name).tier : weaponData.find(e => e.name == reward.name).tier,
                isHeavy: reward.type == "module" ? false : weaponData.find(e => e.name == reward.name).type == "Heavy",
                isTitan: reward.type == "module" ? moduleData.find(e => e.name == reward.name).titan : weaponData.find(e => e.name == reward.name).titan
            }
        } else if (reward.type == "token") {
            return {
                type: "background",
                source: `./images/tokens/mk${reward.mk}_token.png`,
                color: "rgb(255, 255, 255, .1)",
                textColor: "#fff",
                shadowColor: "#000"
            }
        } else if (reward.type == "shape") {
            let shape = shapeData.find(e => e.name == reward.name);
            let canvas = getShapeSprite(shape, true);
            canvas.style = "width: 100%; height: 100%;";
            return {
                type: "background",
                source: shape.specialOf && shape.specialOf.includes("images/") ? shape.specialOf : canvas.toDataURL(),
                color: "rgb(255, 255, 255, .1)",
                textColor: "#fff",
                shadowColor: "#000",
                tier: shape.tier
            }
        } else if (reward.type == "drone") {
            let shape = dronesData.find(e => e.name == reward.name);
            let Drone = new drone(shape);
            Drone.visualData.scale = Drone.visualData.scale * 10;
            Drone.visualData.increaseLine = 10;
            let canvas = getShapeSprite(Drone.visualData, true);
            canvas.style = "width: 100%; height: 100%;";
            return {
                type: "background",
                source: shape.specialOf && shape.specialOf.includes("images/") ? shape.specialOf : canvas.toDataURL(),
                color: "rgb(255, 255, 255, .1)",
                textColor: "#fff",
                shadowColor: "#000",
                tier: shape.tier
            }
        }
    }
    function showLootboxRewards(data) {
        let tokenThing = {
            "token 1": "./images/tokens/mk1_token.png",
            "token 2": "./images/tokens/mk2_token.png",
            "token 3": "./images/tokens/mk3_token.png"
        };
        if (document.getElementById("hahahahSAJDOIAJDIASJDAJSD___SADPOSKDOIJADHIADASHDASGYDGHAS")) return;
        let element = document.createElement("div");
        element.id = "hahahahSAJDOIAJDIASJDAJSD___SADPOSKDOIJADHIADASHDASGYDGHAS";
        element.style = `
        position: absolute;
        left: 12.5%;
        top: 12.5%;
        height: 75%;
        width: 75%;
        background-color: rgb(0, 0, 0, .8);
        border-radius: 4px;
        color: #fff;
        `;
        let width = window.innerWidth * .75;
        let height = window.innerHeight * .75;
        let fuckingWidth = (width - 300) - 40;
        element.innerHTML = `
        <div style="font-size: 28px; margin-left: 15px; margin-top: 5px;">
        ${data.name}
        </div>
        <div style="position: absolute; top: 40px; left: 15px; width: 300px; height: 300px; background-image: url('${data.source}');">
        </div>
        <div id="rewards" style="position: absolute; top: 20px; left: ${320}px; width: ${fuckingWidth}px; height: ${height - 40}; background-color: rgb(255, 255, 255, .2); border-radius: 4px; overflow-y: scroll;">
        </div>
        <div style="position: absolute; top: 300px; left: 15px; width: 290px; height: ${height - (20 + 300)}px; background-color: rgb(255, 255, 255, .1); border-radius: 4px; overflow-y: scroll;">
        <div style="margin-left: 5px;">
        ${data.desc}
        </div>
        </div>
        `;
        document.getElementById("sideDisplay").appendChild(element);
        let rewardsElement = document.getElementById("rewards");
        let rewardsText = "";
        let groupedRewards = {};
        let dataRewards = data.rewards.sort((a, b) => rarityToTier[b.rarity] - rarityToTier[a.rarity]);
        dataRewards.forEach(reward => {
            if (!groupedRewards[reward.rarity]) {
                groupedRewards[reward.rarity] = [];
            }
            groupedRewards[reward.rarity].push(reward);
        });

        let size = 100;
        for (let i in groupedRewards) {
            rewardsText += `
            <div style="margin-top: 5px; color: ${i == "Common" || i == "Legendary" ? "#000" : "#fff"}; margin-left: 5px; padding: 2.5px; width: ${fuckingWidth - 15}px; height: ${20}px; background-color: ${tierColor({ tier: rarityToTier[i] })}; border-radius: 2px;">
            ${i} (${Math.round(rarityToChance[i] * 100)}%)
            </div>
            `;
            groupedRewards[i].forEach(e => {
                let backgroundData = getBackgroundImage(e);
                rewardsText += `
                <div style="position: relative; display: inline-block; width: ${size}px; height: ${size}px; ${backgroundData.type == "background" ? `background-size: ${size}px ${size}px; background-color: ${backgroundData.color}; background-image: url('${backgroundData.source}');` : ""} border: solid; border-width: 2px; border-color: #000; margin: 5px; overflow: hideen; border-radius: 2px;">
                <div style="bottom: 0px; right: 2px; text-shadow: 0px 0px 10px ${backgroundData.shadowColor}; text-align: right; position: absolute; color: ${backgroundData.textColor}">
                ${e.type == "module" ? `
                <div style="box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.75); width: 25px; height: 25px; background-size: 25px 25px; background-image: url('${backgroundData.isTitan ? "./images/weapons/gangantua.png" : "./images/abilities/shapeshift.png"}');">
                </div>
                ` : e.type == "shape" || e.type == "drone" ? `
                ${e.name}
                ` : e.type == "weapon" ? `
                <div style="box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.75); width: 25px; height: 25px; background-size: 25px 25px; background-image: url('${backgroundData.isHeavy ? backgroundData.isTitan ? "./images/weapons/veyron.png" : "./images/weapons/destroyer.png" : backgroundData.isTitan ? "./images/weapons/evora.png" : "./images/weapons/punisher.png"}');">
                </div>
                ` : abbreviateNumber(e.value)}
                </div>
                </div>
                `;
            });
        }
        rewardsElement.innerHTML = rewardsText;

        element.onclick = function () {
            this.remove();
        }
    }
    function getLootboxReward(rewards, adsasda) {
        const randomValue = Math.random();
        let possible = [];
        for (let i = 0; i < rewards.length; i++) {
            let reward = rewards[i];
            let chance = rarityToChance[reward.rarity];
            if (chance >= randomValue) {
                possible.push(reward);
            }
        }
        if (!adsasda) {
            let highestL = "Common";
            let secondHighestL = "Common";
            for (let i = 0; i < rewards.length; i++) {
                let reward = rewards[i];
                let chance = rarityToChance[reward.rarity];
                if (chance <= rarityToChance[highestL]) {
                    secondHighestL = highestL;
                    highestL = reward.rarity;
                } else if (chance <= rarityToChance[secondHighestL] && reward.rarity !== highestL) {
                    secondHighestL = reward.rarity;
                }
            }
            let possinle = rewards.filter(e => e.rarity == (Math.random() < .75 ? highestL : secondHighestL));
            return possinle[Math.floor(Math.random() * possinle.length)];
        } else if (possible.length) {
            let randomNums = [];
            for (let i = 0; i < 50; i++) {
                randomNums.push(Math.random());
            }
            let randomNums2 = [];
            for (let i = 0; i < 5; i++) {
                randomNums2.push(randomNums[Math.floor(Math.random() * randomNums.length)]);
            }
            let randomnum = randomNums2[Math.floor(Math.random() * randomNums2.length)];
            return possible[Math.floor(randomnum * possible.length)];
        } else {
            return rewards[Math.floor(Math.random() * rewards.length)];
        }
    }
    function hexToRgb(hexCode, a) {
        hexCode = hexCode.replace(/^#/, '');
        let bigint = parseInt(hexCode, 16);
        let r = (bigint >> 16) & 255;
        let g = (bigint >> 8) & 255;
        let b = bigint & 255;
        return `rgb(${r}, ${g}, ${b}, ${a})`;
    }
    function doLootboxAnimation(reward, thingy, asdasd) {
        document.getElementById("money2Display").style.display = "none";
        document.getElementById("sideDisplay").style.display = "none";
        let element = document.createElement("div");
        element.style = `
        position: absolute;
        left: 0px;
        top: 0px;
        width: 100%;
        height: 100%;
        `;
        let color = tierColor({ tier: rarityToTier[reward.rarity] });
        let gradient = `radial-gradient(circle, ${color} 0%, #000 66%)`;
        let backgroundData = getBackgroundImage(reward);
        let size2 = 300;
        element.innerHTML = `
        <div id="third" style="transition: .25s; position: absolute; display: flex; justify-content: center; align-items: center; top: 0px; left: 0px; width: 100%; height: 100%; background-color: ${!asdasd ? "#ffff00" : "#000"};">
        <div id="circle of doom" style="transition: .5s; width: 0px; height: 0px; border-radius: 100%; background: radial-gradient(circle, #808080 0%, ${!asdasd ? "#ffff00" : "#000"} 66%);">
        </div>
        <div id="rewardInfo" style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); opacity: 0; transition: 1s; display: block; width: ${size2}px; height: ${size2}px; ${backgroundData.type == "background" ? `background-size: ${size2}px ${size2}px; background-color: ${backgroundData.tier >= 0 ? hexToRgb(tierColor(backgroundData), .8) : "#808080"}; background-image: url('${backgroundData.source}');` : ""} border: solid; border-width: 4px; border-color: #000; margin: 5px; overflow: hideen; border-radius: 4px;">
        <div style="bottom: 0px; right: 2px; font-size: 24px; text-shadow: 0px 0px 10px ${backgroundData.shadowColor}; text-align: right; position: absolute; color: ${backgroundData.textColor}">
        ${reward.type == "module" ? `
        <div style="box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.75); width: 50px; height: 50px; background-size: 50px 50px; background-image: url('./images/abilities/shapeshift.png');">
        </div>
        ` : reward.type == "shape" || reward.type == "drone" ? `
        ${reward.name}
        ` : reward.type == "weapon" ? `
        <div style="box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.75); width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${backgroundData.isHeavy ? "./images/weapons/destroyer.png" : "./images/weapons/punisher.png"}');">
        </div>
        ` : abbreviateNumber(reward.value)}
        </div>
        </div>
        <div id="getmeout" style="cursor: pointer; text-align: center; position: absolute; opacity: 0; transition: 2s; display: block; left: ${window.innerWidth / 2 - 100}px; bottom: 100px; width: 200px; height: 50px; background-color: #0f0; color: #fff; font-size: 34px; border-radius: 4px;">
        Great
        </div>
        </div>
        <div id="second" style="display: block;">
        <div id="second1" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 50%; background-color: #808080;">
        </div>
        <div id="second2" style="position: absolute; left: 0px; bottom: 0px; width: 100%; height: 50%; background-color: #808080;">
        </div>
        </div>
        <div id="first" style="display: block;">
        <div id="first1" style="position: absolute; left: 0px; top: 0px; width: 50%; height: 100%; background-color: ${!asdasd ? "#ffff00" : "#000"};">
        </div>
        <div id="first2" style="position: absolute; right: 0px; top: 0px; width: 50%; height: 100%; background-color: ${!asdasd ? "#ffff00" : "#000"};">
        </div>
        </div>
        `;
        document.body.appendChild(element);
        let isDone = false;
        let gete = function (id) {
            return document.getElementById(id);
        }
        let first = 0;
        let second = 0;
        let delta = 0;
        let size = 0;
        let start = false;
        let lastu = Date.now();
        function animation() {
            delta = Date.now() - lastu;
            lastu = Date.now();
            if (gete("first").style.display == "block") {
                let speed = (delta * 0.6);
                first -= speed;
                gete("first1").style.left = `${first}px`;
                gete("first2").style.right = `${first}px`;
                if (first <= -window.innerWidth / 2) {
                    gete("first").style.display = "none";
                }
            } else if (gete("second").style.display == "block") {
                let speed = (delta * 0.6);
                second -= speed;
                gete("second1").style.top = `${second}px`;
                gete("second2").style.bottom = `${second}px`;
                if (Math.abs(second) >= window.innerHeight / 4) {
                    start = true;
                }
                if (second <= -window.innerHeight / 2) {
                    gete("second").style.display = "none";
                }
            }
            if (size <= (window.innerHeight - 200) && start) {
                size += (delta * 0.8);
                gete("circle of doom").style.width = `${size}px`;
                gete("circle of doom").style.height = `${size}px`;
            } else if (size >= (window.innerHeight - 200) && !isDone) {
                isDone = true;
                gete("third").style.backgroundColor = "#000";
            } else if (isDone) {
                isDone = "pop";
                gete("circle of doom").style.background = gradient;
                gete("rewardInfo").style.opacity = 1;
                gete("getmeout").style.opacity = 1;
            }
            if (isDone != "pop") window.requestAnimationFrame(animation);
        }
        gete("getmeout").onclick = function () {
            isDone = "pop";
            document.getElementById("money2Display").style.display = "block";
            document.getElementById("sideDisplay").style.display = "block";
            document.getElementById("lootBoxToggle").click();
            if (thingy) {
                document.getElementById("goToNext").click();
            }
            element.remove();
        }
        window.requestAnimationFrame(animation);
    }
    function getUltimateXP(amount) {
        player.ULIMATEXP = Math.min(player.ULIMATEXP + amount, 50e3);
        if (player.ULIMATEXP >= 50e3) {
            document.getElementById("get_Ultimate Box").style.cursor = "pointer";
        } else {
            document.getElementById("get_Ultimate Box").style.cursor = null;
        }
        if (document.getElementById("ultimateXP")) document.getElementById("ultimateXP").style.width = `${(player.ULIMATEXP / 50e3) * 100}%`;
        saveGameData();
    }
    function doLootBoxStuff(lootbox) {
        let dosssss = function (asdasdasd) {
            let reward = getLootboxReward(lootbox.rewards, asdasdasd);
            lootboxGetItem(reward);
            doLootboxAnimation(reward, lootbox.name.includes("Data") ? true : false, asdasdasd);
        };
        if (lootbox.cost) {
            if (player.keys - lootbox.cost >= 0) {
                updateMoneyDisplay("keys", -lootbox.cost);
                getUltimateXP(lootbox.cost);
                dosssss(true);
            }
        } else {
            if (lootbox.name == "Ultimate Box") {
                if (player.ULIMATEXP >= 50e3) {
                    player.ULIMATEXP = 0;
                    getUltimateXP(0);
                    dosssss(true);
                }
            } else {
                let asdasdasd = true;
                if (lootbox.name == "MK1 Data Box" && player.tokens.mk1 - 1 >= 0) {
                    updateMoneyDisplay("token 1", -1);
                    player.lootboxSpecialPrize.mk1--;
                    if (player.lootboxSpecialPrize.mk1 <= 0) {
                        asdasdasd = false;
                        player.lootboxSpecialPrize.mk1 = Math.randInt(12, 25);
                    }
                    getUltimateXP(2e3);
                    dosssss(asdasdasd);
                } else if (lootbox.name == "MK2 Data Box" && player.tokens.mk2 - 1 >= 0) {
                    updateMoneyDisplay("token 2", -1);
                    player.lootboxSpecialPrize.mk2--;
                    if (player.lootboxSpecialPrize.mk2 <= 0) {
                        asdasdasd = false;
                        player.lootboxSpecialPrize.mk2 = Math.randInt(25, 50);
                    }
                    getUltimateXP(5e3);
                    dosssss(asdasdasd);
                } else if (lootbox.name == "MK3 Data Box" && player.tokens.mk3 - 1 >= 0) {
                    updateMoneyDisplay("token 3", -1);
                    player.lootboxSpecialPrize.mk3--;
                    if (player.lootboxSpecialPrize.mk3 <= 0) {
                        asdasdasd = false;
                        player.lootboxSpecialPrize.mk3 = Math.randInt(37, 50);
                    }
                    getUltimateXP(10e3);
                    dosssss(asdasdasd);
                }
            }
        }
    }
    document.getElementById("lootBoxToggle").onclick = function () {
        document.getElementById("rewardAnimation").style.overflow = "hidden";
        document.getElementById("rewardAnimation").style.pointerEvents = "none";
        document.getElementById("rewardAnimation").style.display = "none";
        let ultimateBoxData = lootboxes.find(e => e.name == "Ultimate Box");
        document.getElementById("sideDisplay").innerHTML = `
        <div id="get_${ultimateBoxData.name}" style="${player.ULIMATEXP >= 50e3 ? "cursor: pointer;" : ""}position: absolute; left: ${(window.innerWidth) / 2 - 50}px; width: 100px; height: 100px; background-image: url('${ultimateBoxData.source}'); background-size: 100px 100px;">
        </div>
        <div id="${ultimateBoxData.name}_rewards" style="cursor: pointer; position: absolute; text-align: center; color: #fff; top: 10px; left: ${(window.innerWidth) / 2 + 50}px; width: 25px; height: 25px; border-radius: 100%; background-color: rgb(0, 0, 0, .25);">
        <strong>i</strong>
        </div>
        <div style="position: absolute; top: 90px; left: 30px; width: ${window.innerWidth - 60}px; height: 10px; background-color: #808080; border-radius: 6px; overflow: hidden;">
        <div id="ultimateXP" style="height: 100%; transition: 2s; width: ${(player.ULIMATEXP / 50e3) * 100}%; background-color: #ffff00;">
        </div>
        </div>

        <div id="main"></div>

        <div id="noMain" style="display: none;"></div>

        <div id="goToPre" style="display: none; z-index: 10000; position: absolute; cursor: pointer; left: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToPreCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_before
        </span>
        </div>
        </div>

        <div id="goToNext" style="position: absolute; z-index: 10000; transition: .25s; cursor: pointer; right: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToNextCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_next
        </span>
        </div>
        </div>

        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        `;
        if (unlockedAtTier[4] > player.profile.level) {
            document.getElementById("goToNext").style.display = "none";
        }
        let mainElement = document.getElementById("main");
        let mainText = "";
        let normalBoxes = lootboxes.filter(e => e.cost).sort((a, b) => a.cost - b.cost);
        normalBoxes.forEach((e, index) => {
            let left = (index % 2 == 0 ? (window.innerWidth / 2 - 320) : (window.innerWidth / 2 + 20));
            let top = index >= 2 ? 440 : 120;
            mainText += `
            <div style="position: absolute; top: ${top}px; left: ${left}px; width: 300px; height: 300px; background-image: url('${e.source}');">
            <div style="width: 100%; text-align: center; color: #fff; font-size: 30px;">
            ${e.name}
            </div>
            <div id="${e.name}_rewards" style="position: absolute; border-radius: 100%; color: #fff; cursor: pointer; top; 0px; width: 25px; height: 25px; text-align: center; right: 0px; background-color: #808080;">
            <strong>i</strong>
            </div>
            <div id="get_${e.name}" style="cursor: pointer; position: absolute; text-align: center; color: #fff; font-size: 26px; bottom: 10px; left: 20px; border-radius: 6px; width: 260px; height: 40px; background-color: #00ff00;">
            Get (${abbreviateNumber(e.cost)} Keys)
            </div>
            </div>
            `;
        });
        mainElement.innerHTML = mainText;
        let noMainElement = document.getElementById("noMain");
        let noMainText = "";
        let specialBoxes = lootboxes.filter(e => !e.name.includes("Ultimate") && !e.cost);
        specialBoxes.forEach((e, index) => {
            let left = window.innerWidth / 2 - 460;
            if (index == 1) {
                left = window.innerWidth / 2 - 150;
            } else if (index == 2) {
                left = window.innerWidth / 2 + 160;
            }
            noMainText += `
            <div style="position: absolute; top: ${window.innerHeight / 2 - 150}px; left: ${left}px; width: 300px; height: 300px; background-image: url('${e.source}');">
            <div style="width: 100%; text-align: center; color: #fff; font-size: 30px;">
            ${e.name}
            </div>
            <div id="${e.name}_rewards" style="position: absolute; border-radius: 100%; color: #fff; cursor: pointer; top; 0px; width: 25px; height: 25px; text-align: center; right: 0px; background-color: #808080;">
            <strong>i</strong>
            </div>
            <div style="position: absolute; text-align: center; left: 25px; color: #fff; bottom: 60px; width: 250px; height: 25px; background-color: rgba(0, 0, 0, .6); border-radius: 12px; box-shadow: 0px 0px 20px rgba(255, 255, 255, 0.6);">
            Special Prize in: ${player.lootboxSpecialPrize["mk" + (index + 1)]}
            </div>
            <div id="get_${e.name}" style="cursor: pointer; position: absolute; text-align: center; color: #fff; font-size: 26px; bottom: 10px; left: 20px; border-radius: 6px; width: 260px; height: 40px; background-color: #00ff00;">
            <div style="position: absolute; top: 2px; width: 100%; text-align: center; font-size: 12px;"><strong>OPEN</strong></div>
            <div style="position: absolute; left: 110; top: 17px; font-size: 12px;">
            <div style="width: 25px; height: 25px; background-size: 25px 25px; background-image: url('./images/tokens/mk${index + 1}_token.png');">
            <div style="margin-left: 25px; font-size: 18px;">1</div>
            </div>
            </div>
            </div>
            </div>
            `;
        });
        noMainElement.innerHTML = noMainText;

        let elements = [...document.getElementById("sideDisplay").getElementsByTagName("div")];
        for (let i = 0; i < elements.length; i++) {
            let element = elements[i];
            if (element.id && (element.id.includes("get_") || element.id.includes("_rewards"))) {
                if (element.id.includes("_rewards")) {
                    let name = element.id.split("_rewards")[0];
                    element.onclick = function () {
                        showLootboxRewards(lootboxes.find(e => e.name == name));
                    }
                } else if (element.id.includes("get_")) {
                    let name = element.id.split("get_")[1];
                    element.onclick = function () {
                        doLootBoxStuff(lootboxes.find(e => e.name == name));
                    }
                }
            }
        }

        document.getElementById("goToNext").onclick = function () {
            this.style.display = "none";
            document.getElementById("rewardAnimation").style.display = "none";
            document.getElementById("goToPre").style.display = "block";
            document.getElementById("main").style.display = "none";
            document.getElementById("noMain").style.display = "block";
        }
        document.getElementById("goToPre").onclick = function () {
            this.style.display = "none";
            document.getElementById("rewardAnimation").style.display = "none";
            document.getElementById("goToNext").style.display = "block";
            document.getElementById("main").style.display = "block";
            document.getElementById("noMain").style.display = "none";
        }
        document.getElementById("goToNext").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToNextCon").style.color = "#000";
        }
        document.getElementById("goToNext").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToNextCon").style.color = "#fff";
        }
        document.getElementById("goToPre").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToPreCon").style.color = "#000";
        }
        document.getElementById("goToPre").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToPreCon").style.color = "#fff";
        }
        document.getElementById("hangerUI").style.display = "none";
        document.getElementById("money2Display").style.display = "block";
        document.body.appendChild(document.getElementById("money2Display"));
        document.getElementById("backButton").onclick = function () {
            document.getElementById("sideDisplay").innerHTML = "";
            document.getElementById("hangerUI").style.display = "block";
            document.getElementById("money2Display").style.display = "none";
            document.getElementById("hangerUI").appendChild(document.getElementById("money2Display"));
            document.getElementById("rewardAnimation").style.display = "none";
        }
    }
    function betterEquipShape(slot, oldShape, unequipedShapes, titan) {
        let filteredRobots = [];
        for (let i = 0; i < unequipedShapes.length; i++) {
            if (!unequipedShapes[i].isSold) filteredRobots.push(unequipedShapes[i]);
        }
        filteredRobots = filteredRobots.filter(e => e.titan == titan).sort((a, b) => b.level - a.level).sort((a, b) => b.tier - a.tier);
        if (oldShape) filteredRobots.unshift(oldShape);
        let currentIndex = 0;
        document.getElementById("sideDisplay").innerHTML = `
        <div id="WEAPONdisplay" style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;">
        </div>
        <div id="goToPre" style="display: none; position: absolute; cursor: pointer; left: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToPreCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_before
        </span>
        </div>
        </div>
        <div id="goToNext" style="position: absolute; transition: .25s; cursor: pointer; right: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToNextCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_next
        </span>
        </div>
        </div>
        <div id="inventoryButton" style="position: absolute; text-align: center; font-size: 25px; color: #000; left: ${window.innerWidth / 2 - 165}px; top: 30px; border-radius: 6px; height: 42.5px; padding-top: 7.5px; width: 150px; background-color: rgb(255, 255, 255, .6);">
        INVENTORY
        </div>
        <div id="storeButton" style="position: absolute; text-align: center; font-size: 35px; cursor: pointer; color: #fff; left: ${window.innerWidth / 2 + 20}px; top: 30px; border-radius: 6px; height: 50px; width: 150px; background-color: rgb(0, 0, 0, .4);">
        STORE
        </div>
        `;
        let inInventory = true;
        let diiiisbled = false;
        document.getElementById("inventoryButton").onclick = function () {
            if (!diiiisbled) {
                this.style.cursor = null;
                this.style.color = "#000";
                this.style.backgroundColor = "rgb(255, 255, 255, .6)";
                document.getElementById("goToPre").style.display = "none";
                document.getElementById("goToNext").style.display = "block";
                document.getElementById("storeButton").style.cursor = "pointer";
                document.getElementById("storeButton").style.color = "#fff";
                document.getElementById("storeButton").style.backgroundColor = "rgb(0, 0, 0, .4)";
                currentIndex = 0;
                inInventory = true;
                drawShapeEquip(inInventory ? filteredRobots : shapeData.filter(e => e.titan == titan).filter(e => !e.dontShow).sort((a, b) => a.tier - b.tier), currentIndex, oldShape, slot, null, inInventory);
            }
        };
        document.getElementById("storeButton").onclick = function () {
            this.style.cursor = null;
            this.style.color = "#000";
            this.style.backgroundColor = "rgb(255, 255, 255, .6)";
            document.getElementById("goToPre").style.display = "none";
            document.getElementById("goToNext").style.display = "block";
            document.getElementById("inventoryButton").style.cursor = "pointer";
            document.getElementById("inventoryButton").style.color = "#fff";
            document.getElementById("inventoryButton").style.backgroundColor = "rgb(0, 0, 0, .4)";
            currentIndex = 0;
            inInventory = false;
            drawShapeEquip(inInventory ? filteredRobots : shapeData.filter(e => e.titan == titan).filter(e => !e.dontShow).sort((a, b) => a.tier - b.tier), currentIndex, oldShape, slot, inInventory);
        };
        if (filteredRobots.length == 0) {
            document.getElementById("storeButton").click();
            document.getElementById("inventoryButton").style.cursor = null;
            diiiisbled = true;
        }
        drawShapeEquip(inInventory ? filteredRobots : shapeData.filter(e => e.titan == titan).filter(e => !e.dontShow), currentIndex, oldShape, slot, null, inInventory);
        if (inInventory ? !filteredRobots[currentIndex + 1] : !shapeData.filter(e => e.titan == titan).filter(e => !e.dontShow)[currentIndex + 1]) {
            document.getElementById("goToNext").style.display = "none";
        }
        document.getElementById("goToNext").onclick = function () {
            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            if (inInventory ? filteredRobots[currentIndex + 1] : shapeData.filter(e => e.titan == titan).filter(e => !e.dontShow)[currentIndex + 1]) {
                currentIndex++;
                drawShapeEquip(inInventory ? filteredRobots : shapeData.filter(e => e.titan == titan).filter(e => !e.dontShow).sort((a, b) => a.tier - b.tier), currentIndex, oldShape, slot, null, inInventory);
                if (inInventory ? filteredRobots[currentIndex + 1] : shapeData.filter(e => e.titan == titan).filter(e => !e.dontShow)[currentIndex + 1]) {
                    this.style.display = "block";
                } else {
                    this.style.display = "none";
                }
                if (inInventory ? filteredRobots[currentIndex - 1] : shapeData.filter(e => e.titan == titan).filter(e => !e.dontShow)[currentIndex - 1]) {
                    document.getElementById("goToPre").style.display = "block";
                } else {
                    document.getElementById("goToPre").style.display = "none";
                }
            }
        }
        document.getElementById("goToNext").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToNextCon").style.color = "#000";
        }
        document.getElementById("goToNext").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToNextCon").style.color = "#fff";
        }
        document.getElementById("goToPre").onclick = function () {
            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            if (inInventory ? filteredRobots[currentIndex - 1] : shapeData.filter(e => e.titan == titan)[currentIndex - 1]) {
                currentIndex--;
                drawShapeEquip(inInventory ? filteredRobots : shapeData.filter(e => e.titan == titan).sort((a, b) => a.tier - b.tier), currentIndex, oldShape, slot, null, inInventory);
                if (inInventory ? filteredRobots[currentIndex - 1] : shapeData.filter(e => e.titan == titan)[currentIndex - 1]) {
                    this.style.display = "block";
                } else {
                    this.style.display = "none";
                }
                if (inInventory ? filteredRobots[currentIndex + 1] : shapeData.filter(e => e.titan == titan)[currentIndex + 1]) {
                    document.getElementById("goToNext").style.display = "block";
                } else {
                    document.getElementById("goToNext").style.display = "none";
                }
            }
        }
        document.getElementById("goToPre").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToPreCon").style.color = "#000";
        }
        document.getElementById("goToPre").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToPreCon").style.color = "#fff";
        }
        saveGameData();
    }
    function equipShape(slot, titan) {
        let unequipedShapes = player.shapes.filter(e => e.slot == null || e.slot == undefined);
        document.getElementById("sideDisplay").innerHTML = "";
        document.getElementById("hangerUI").style.display = "none";
        let oldShape = player.shapes.find(e => e.slot == slot);
        betterEquipShape(slot, oldShape, unequipedShapes, titan);
    }
    function tierColor(obj) {
        if (obj.tier == 10) return `rgb(${Math.randInt(0, 255)},${Math.randInt(0, 255)},${Math.randInt(0, 255)})`;
        return obj.tier == 4 ? "#fa0032" : obj.tier == 3 ? "#fcdf00" : obj.tier == 2 ? "#7702bf" : obj.tier == 1 ? "#38b0f5" : "#d3d3d3";
    }
    function updateSlots() {
        document.getElementById("shapesDisplay").innerHTML = "";
        let adjusted = window.innerWidth - 200;
        let adjustedH = (adjusted / 4) * 2;
        document.getElementById("shapesDisplay").style = `
        position: absolute;
        top: ${(window.innerHeight / 2) - (adjustedH / 2)}px;
        left: 100px;
        width: ${adjusted}px;
        border-radius: 12px;
        overflow: ${player.profile.level >= 30 ? "scroll" : "hidden"};
        height: ${adjustedH}px;
        background-color: rgb(135, 135, 135, 0.5);
        `;
        let INDEX = slotData.findIndex(e => !e.unlocked);
        for (let i = 0; i < 9; i++) {
            let slot = slotData[i];
            let backgroundColor = (i < 4 ? (i % 2 == 0 ? "rgb(0, 0, 0, 0.2);" : "rgb(0, 0, 0, 0);") : (i % 2 == 0 ? "rgb(0, 0, 0, 0);" : "rgb(0, 0, 0, 0.2);"));
            if (i == 8 || slot.unlocked) {
                if (i == 8 && player.profile.level < 30) {
                } else if (i == 8 ? player.shapes.find(e => e.slot == 8) : slot.used) {
                    document.getElementById("shapesDisplay").innerHTML += `
                    <div id="slot${i}" style="position: absolute; text-align: right; transition: .5s; top: ${i == 8 ? 0 : i < 4 ? 0 : adjustedH / 2}px; left: ${(adjusted / 4) * (i == 8 ? 4 : (i < 4 ? i : i - 4))}px; cursor: pointer; width: ${(adjusted / 4) * (i == 8 ? 2 : 1)}px; height: ${(adjusted / 4) * (i == 8 ? 2 : 1)}px; background-color: ${backgroundColor}">
                    </div>
                    `;
                } else {
                    document.getElementById("shapesDisplay").innerHTML += `
                    <div id="slot${i}" style="position: absolute; text-align: right; transition: .5s; top: ${i == 8 ? 0 : i < 4 ? 0 : adjustedH / 2}px; left: ${(adjusted / 4) * (i == 8 ? 4 : (i < 4 ? i : i - 4))}px; cursor: pointer; width: ${(adjusted / 4) * (i == 8 ? 2 : 1)}px; height: ${(adjusted / 4) * (i == 8 ? 2 : 1)}px; background-color: ${backgroundColor}">
                    <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 28px;">
                    Equip ${i == 8 ? "Titan" : "Robot"}
                    <div>
                    </div>
                    `;
                }
            } else {
                if (i > INDEX) {
                    document.getElementById("shapesDisplay").innerHTML += `
                    <div id="slot${i}" style="position: absolute; display: flex; align-items: center; top: ${i < 4 ? 0 : adjustedH / 2}px; left: ${(adjusted / 4) * (i < 4 ? i : i - 4)}px; pointer-events: auto; width: ${adjusted / 4}px; height: ${adjusted / 4}px; background-color: ${backgroundColor}">
                    <div style="width: 100%; text-align: center;">
                    <span class="material-symbols-outlined" style="font-size: 150px;">
                    lock
                    </span>
                    </div>
                    </div>
                    `;
                } else {
                    document.getElementById("shapesDisplay").innerHTML += `
                    <div id="slot${i}" style="position: absolute; display: flex; align-items: center; top: ${i < 4 ? 0 : adjustedH / 2}px; left: ${(adjusted / 4) * (i < 4 ? i : i - 4)}px; cursor: pointer; width: ${adjusted / 4}px; height: ${adjusted / 4}px; background-color: ${backgroundColor}">
                    <div style="width: 100%; text-align: center; font-size: 50px;">
                    Unlock: ${abbreviateNumber(slot.cost)} Gold
                    </div>
                    </div>
                    `;
                }
            }
        }
        for (let i = 0; i < 9; i++) {
            let slot = slotData[i];
            let backgroundColor = (i < 4 ? (i % 2 == 0 ? "rgb(0, 0, 0, 0.2)" : "rgb(0, 0, 0, 0)") : (i % 2 == 0 ? "rgb(0, 0, 0, 0)" : "rgb(0, 0, 0, 0.2)"));
            if (i == 8 || slot.unlocked) {
                if (i == 8 && player.profile.level < 30) {
                } else if ((i == 8 ? player.shapes.find(e => e.slot == 8) : slot.used)) {
                    let shape = player.shapes.find(e => e.slot == i);
                    if (shape) {
                        let tmpImage = getShapeSprite(shape, true);
                        tmpImage.style = `position: absolute; top: 0px; left: 0px; width: ${(adjusted / 4) * (i == 8 ? 2 : 1)}px; height: ${(adjusted / 4) * (i == 8 ? 2 : 1)}px;`;
                        document.getElementById("slot" + i).innerHTML = `
                        <div style="color: ${tierColor(shape)}; z-index: 10; position: absolute; bottom: 5px; right: 5px; font-size: 30px;">
                        <strong>${!shape.titan && [14, 13].includes(shape.level) ? `${returnStyledName(shape, shape.name)} <span style="color: ${shape.level == 13 ? "#0f0" : "#ffff00"};">${shape.level == 13 ? "MK2" : "MK3"}</span>` : `Lvl ${shape.level} ${shape.name}`}</strong>
                        </div>
                        `;
                        if (shape.specialOf) {
                            document.getElementById(`slot${i}`).style.backgroundSize = `${(adjusted / 4) * (i == 8 ? 2 : 1)}px ${(adjusted / 4) * (i == 8 ? 2 : 1)}px`;
                            document.getElementById(`slot${i}`).style.backgroundImage = `url('${shape.specialOf}')`;
                        } else {
                            document.getElementById("slot" + i).appendChild(tmpImage);
                        }
                        let weapons = player.weapons.filter(e => e.owner == shape.sid);
                        weapons = weapons.sort((a, b) => a.slot - b.slot);
                        let heavy = weapons.filter(e => e.type == "Heavy").length;
                        let light = weapons.filter(e => e.type == "Light").length;
                        if (heavy > shape.hardpoints.heavy || light > shape.hardpoints.light) {
                            weapons.forEach(e => {
                                e.slot = null;
                                e.owner = null;
                            });
                            weapons = [];
                        }
                        if (shape.hardpoints.light && weapons.find(e => e.owner == shape.sid && e.slot == 0 && e.type == "Heavy")) {
                            weapons.forEach(e => {
                                e.slot = null;
                                e.owner = null;
                            });
                            weapons = [];
                        }
                        for (let t = 0; t < Math.min(weapons.length, 8); t++) {
                            let tmpImage = getWeaponIcon(weapons[t], true);
                            tmpImage.style = `position: absolute; bottom: ${40 + (60 * (t >= 4 ? t - 4 : t))}px; right: ${t >= 4 ? 55 : 5}px; width: 50px; height: 50px;`;
                            document.getElementById("slot" + i).appendChild(tmpImage);
                        }
                        document.getElementById("slot" + i).onmouseover = function () {
                            this.style.filter = "brightness(150%)";
                            this.style.backgroundColor = "rgb(255, 255, 255, 0.6)";
                        }
                        document.getElementById("slot" + i).onmouseout = function () {
                            this.style.filter = "brightness(100%)";
                            this.style.backgroundColor = backgroundColor;
                        }
                        document.getElementById("slot" + i).onclick = function () {
                            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                            customizeShape(shape);
                            saveGameData();
                        }
                    } else {
                        slot.used = false;
                        updateSlots();
                        break;
                    }
                } else {
                    document.getElementById("slot" + i).onclick = function () {
                        document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                        equipShape(i, i == 8);
                        saveGameData();
                    }
                }
            } else if (i <= INDEX) {
                document.getElementById("slot" + i).onclick = function () {
                    if (player.gold - slot.cost >= 0) {
                        document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                        updateMoneyDisplay("gold", -slot.cost);
                        slot.unlocked = true;
                        updateSlots();
                        saveGameData();
                    }
                }
            }
        }
        /*let robots = player.shapes.filter(e => e.slot != null).sort((a, b) => a.slot - b.slot);
        let thingy = [];
        for (let i = 0; i < robots.length; i++) {
            let robot = robots[i];
            let item = {
                "name": robot.name,
                "weapons": {
                    "heavy": "",
                    "light": ""
                },
                "modules": [],
                "drone": "",
                "pilotName": "",
                "skills": [],
                "activeModuleIndex": robot.activeModuleIndex
            };
            let heavy = player.weapons.find(e => e.type == "Heavy" && e.owner == robot.sid);
            let light = player.weapons.find(e => e.type == "Light" && e.owner == robot.sid);
            item.weapons.heavy = heavy?.name || "Destroyer";
            item.weapons.light = light?.name || "Punisher";
            let modules = player.modules.filter(e => e.owner == robot.sid);
            for (let t = 0; t < modules.length; t++) {
                item.modules.push(modules[t].name);
            } 
            let pilot = player.pilots.find(e => e.owner == robot.sid);
            item.pilotName = pilot?.name;
            for (let t = 0; t < pilot.skills.length; t++) {
                if (!pilot.skills[t].legendary) {
                    item.skills.push(pilot.skills[t].name);
                }
            }
            item.drone = player.drones.find(e => e.owner == robot.sid)?.name;
            thingy.push(item);
        }
        console.log(thingy);*/
    }
    var operationData = {
        xp: 0,
        currentIndex: 0,
        data: []
    };
    function addOperationXP(amount) {
        if (!operationData.data.length || !operationData.data.some(e => e.collected == null)) {
            generateOperation();
        }
        if ((operationData.xp + amount) >= operationData.data[operationData.currentIndex].maxxp) {
            amount -= (operationData.data[operationData.currentIndex].maxxp - operationData.xp);
            operationData.data[operationData.currentIndex].done = true;
            operationData.xp = 0;
            if (amount <= 0) {
                operationData.currentIndex++;
                if (!operationData.data[operationData.currentIndex]) {
                    operationData.currentIndex = operationData.data.length - 1;
                }
            }
            while (amount > 0) {
                operationData.currentIndex++;
                if (!operationData.data[operationData.currentIndex]) {
                    operationData.currentIndex = operationData.data.length - 1;
                    amount = 0;
                } else if (amount >= operationData.data[operationData.currentIndex].maxxp) {
                    amount -= operationData.data[operationData.currentIndex].maxxp;
                    operationData.data[operationData.currentIndex].done = true;
                } else {
                    operationData.xp += amount;
                    amount = 0;
                }
            }
        } else {
            operationData.xp += amount;
        }
    }
    var keysSource = "./images/icons/keys_icon.png";
    function generateOperation() {
        operationData.xp = 0;
        operationData.currentIndex = 0;
        operationData.data = [];
        for (let i = 0; i < 200; i++) {
            let amount = 1;
            let rewardType = "silver";
            if (i >= 149 && (i + 1) % 10 == 0) {
                if (i >= 149 && i < 179) {
                    rewardType = "token 1";
                } else if (i >= 179 && i < 199) {
                    rewardType = "token 2";
                } else {
                    rewardType = "token 3";
                }
            } else {
                if (Math.random() < 0.5) {
                    rewardType = "silver";
                    if (i >= 125) {
                        amount = 8e6;
                    } else if (i >= 120) {
                        amount = i * 60e3;
                    } else if (i >= 50) {
                        amount = i * 40e3;
                    } else if (i >= 25) {
                        amount = i * 25e3;
                    } else {
                        amount = Math.max(i * 10e3, 10e3);
                    }
                } else if (Math.random() < 0.3334) {
                    rewardType = "keys";
                    if (i >= 100) {
                        amount = 800;
                    } else if (i >= 50) {
                        amount = i * 7;
                    } else {
                        amount = (i * 5) + 5;
                    }
                } else {
                    rewardType = "gold";
                    if (i >= 100) {
                        amount = 1e3;
                    } else if (i >= 50) {
                        amount = i * 10;
                    } else {
                        amount = (5 * i) + 5;
                    }
                }
            }
            operationData.data.push({
                maxxp: 50 + (i * (i >= 100 ? 50 : 25)),
                done: false,
                type: rewardType,
                amount: amount,
            });
        }
    }
    function displayOperation(XDDDD) {
        document.getElementById("sideDisplay").innerHTML = `
        <div style="width: 100%; text-align: center; font-size: 40px;">
        Operation
        </div>
        <hr>
        <div style="position: absolute; left: ${(window.innerWidth) / 2 - 25}px; top: ${window.innerHeight / 2 - 170}px;">
        Lvl ${operationData.currentIndex + 1}
        </div>
        <div style="position: absolute; left: ${(window.innerWidth) / 2 - 300}px; top: ${window.innerHeight / 2 - 140}px; height: 20px; border-radius: 12px;  overflow: hidden; width: 600px; background-color: rgb(0, 0, 0, 0.4);">
        <div style="position: absolute; top: 0px; left: 0px; height: 100%; width: ${operationData.data[operationData.data.length - 1].done ? 100 : (operationData.xp / operationData.data[operationData.currentIndex].maxxp) * 100}%; background-color: #07faf2;">
        </div>
        <span style="position: absolute; top: 0px; left: 0px; margin-left: 5px; color: #fff;">${operationData.data[operationData.data.length - 1].done ? `${operationData.data[operationData.data.length - 1].maxxp}/${operationData.data[operationData.data.length - 1].maxxp}` : `${operationData.xp}/${operationData.data[operationData.currentIndex].maxxp}`}</span>
        </div>
        <div id="rewards" style="position: absolute; top: ${window.innerHeight / 2 - 100}px; overflow-x: scroll; height: 220px; width: 100%; background-color: rgb(0, 0, 0, .3);">
        </div>
        <div id="10threwardXD" style="position: absolute; box-shadow: -20px 0 20px rgba(0, 0, 0, 0.7); right: 0px; top: ${window.innerHeight / 2 - 100}px; overflow-x: scroll; height: 220px; width: 200px; background-color: rgb(0, 0, 0, .8);">
        </div>
        <div id="collectAll" style="color: #fff; border-radius: 12px; font-size: 35px; width: 200px; text-align: center; height: 50px; background-color: rgb(0, 0, 0, 0.4); position: absolute; left: ${(window.innerWidth) / 2 - 100}px; top: ${window.innerHeight / 2 + 140}px;">
        Collect All
        </div>
        <div id="youEarned" style="${XDDDD ? "cursor: pointer; " : ""};display: ${XDDDD ? "block" : "none"}; position: absolute; top: 25%; left: 25%; width: 50%; height: 50%; background-color: rgb(0, 0, 0, 0.4);">
        ${XDDDD}
        </div>
        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        `;
        document.getElementById("hangerUI").style.display = "none";
        document.getElementById("backButton").onclick = function () {
            document.getElementById("sideDisplay").innerHTML = "";
            document.getElementById("hangerUI").style.display = "block";
        }
        document.getElementById("youEarned").onclick = function () {
            this.style.display = "none";
        }
        let hasStuff = operationData.data.filter(e => e.done && !e.collected);
        if (hasStuff.length > 1) {
            document.getElementById("collectAll").style.cursor = "pointer";
            document.getElementById("collectAll").style.backgroundColor = "rgb(0, 255, 0, 0.8)";
            let stuff = {};
            document.getElementById("collectAll").onclick = function () {
                for (let i = 0; i < hasStuff.length; i++) {
                    let data = hasStuff[i];
                    if (stuff[data.type]) {
                        stuff[data.type] += data.amount;
                    } else {
                        stuff[data.type] = data.amount;
                    }
                    if (data.type == "silver") {
                        data.collected = true;
                        updateMoneyDisplay("sliver", data.amount);
                    } else if (data.type == "gold") {
                        data.collected = true;
                        updateMoneyDisplay("gold", data.amount);
                    } else if (data.type.includes("token")) {
                        data.collected = true;
                        updateMoneyDisplay(data.type, 1);
                    } else {
                        data.collected = true;
                        updateMoneyDisplay("keys", data.amount);
                    }
                }
                let TEXT = `
                <div style="color: #fff; text-align: center; width: 100%; font-size: 40px;">You Got!</div>
                <hr>
                `;
                let indexx = 0;
                for (let i in stuff) {
                    let backgroundImage = i == "token 3" ? "./images/tokens/mk3_token.png" : i == "token 2" ? "./images/tokens/mk2_token.png" : i == "token 1" ? "./images/tokens/mk1_token.png" : i == "silver" ? agSource : i == "gold" ? auSource : keysSource;
                    TEXT += `
                    <div style="position: relative; border-radius: 12px; ${indexx == 0 ? "margin-left: 5px; " : ""}width: 100px; height: 100px; display: inline-block; background-color: rgb(255, 255, 255, .8); background-size: 100px 100px; background-image: url('${backgroundImage}')">
                    <div style="position: absolute; font-size: 24px; bottom: 5px; right: 5px; color: #000;">
                    ${abbreviateNumber(stuff[i])}
                    </div>
                    </div>
                    `;
                    indexx++;
                }
                displayOperation(TEXT);
            }
        }
        let tenthX = [];
        for (let i = 0; i < operationData.data.length; i++) {
            if ((i + 1) % 10 == 0) {
                tenthX.push(i * 200);
            }
        }
        let maxdis = window.innerWidth;
        document.getElementById("rewards").onscroll = function () {
            let tmpx = document.getElementById("rewards").scrollLeft;
            tmpx += maxdis;
            let closest = tenthX.filter(e => e + 300 >= tmpx).sort((a, b) => Math.abs(a - tmpx) - Math.abs(b - tmpx))[0];
            let element = document.getElementById(`OPREWARD${(closest / 200)}`);
            document.getElementById("10threwardXD").style.display = (closest / 200) == operationData.data.length - 1 && closest <= tmpx ? "none" : "block";
            let newElement = element.cloneNode(true);
            newElement.id = "THENTHTNETh";
            newElement.style.left = "0px";
            newElement.style.bottom = "0px";
            document.getElementById("10threwardXD").innerHTML = "";
            document.getElementById("10threwardXD").innerHTML += `
            <div style="position: absolute; color: #fff; background-color: rgb(0, 0, 0, 0.6); text-align: center; top: 0px; left: 0px; height: 20px; width: 200px;">
            ${(closest / 200) + 1}
            </div>
            `;
            document.getElementById("10threwardXD").appendChild(newElement);
            let index = closest / 200;
            if (operationData.data[index] && operationData.data[index].done && !operationData.data[index].collected) {
                let data = operationData.data[index];
                document.getElementById(`THENTHTNETh`).style.cursor = "pointer";
                document.getElementById(`THENTHTNETh`).style.backgroundColor = "rgb(0, 255, 0, .4)";
                document.getElementById(`THENTHTNETh`).onclick = function () {
                    if (data.type == "silver") {
                        data.collected = true;
                        updateMoneyDisplay("sliver", data.amount);
                    } else if (data.type == "gold") {
                        data.collected = true;
                        updateMoneyDisplay("gold", data.amount);
                    } else if (data.type.includes("token")) {
                        data.collected = true;
                        updateMoneyDisplay(data.type, 1);
                    } else {
                        data.collected = true;
                        updateMoneyDisplay("keys", data.amount);
                    }
                    displayOperation();
                };
                document.getElementById(`THENTHTNETh`).onmouseover = function () {
                    document.getElementById(`THENTHTNETh`).style.filter = "brightness(125%)";
                }
                document.getElementById(`THENTHTNETh`).onmouseout = function () {
                    document.getElementById(`THENTHTNETh`).style.filter = "brightness(100%)";
                }
            } else if (operationData.data[index] && !operationData.data[index].done) {
                document.getElementById(`THENTHTNETh`).onmouseover = function () {
                    document.getElementById(`THENTHTNETh`).style.filter = "brightness(125%)";
                }
                document.getElementById(`THENTHTNETh`).onmouseout = function () {
                    document.getElementById(`THENTHTNETh`).style.filter = "brightness(100%)";
                }
            }
        }
        for (let i = 0; i < operationData.data.length; i++) {
            let data = operationData.data[i];
            if (data) {
                let backgroundImage = data.type == "token 3" ? "./images/tokens/mk3_token.png" : data.type == "token 2" ? "./images/tokens/mk2_token.png" : data.type == "token 1" ? "./images/tokens/mk1_token.png" : data.type == "silver" ? agSource : data.type == "gold" ? auSource : keysSource;
                document.getElementById("rewards").innerHTML += `
                <div style="position: absolute; color: #fff; background-color: rgb(0, 0, 0, 0.6); text-align: center; top: 0px; left: ${200 * i}px; height: 20px; width: 200px;">
                ${i + 1}
                </div>
                <div id="OPREWARD${i}" style="position: absolute; transition: .5s; bottom: 0px; left: ${200 * i}px; height: 200px; width: 200px; background-color: ${i % 2 == 0 ? "rgb(0, 0, 0, 0.4)" : "rgb(255, 255, 255, 0.6)"}; background-size: 200px 200px; background-image: url('${backgroundImage}')">
                <div style="position: absolute; font-size: 24px; bottom: 5px; right: 5px; color: ${i % 2 == 0 ? "#fff" : "#000"}">
                ${abbreviateNumber(data.amount)}
                </div>
                </div>
                `;
            }
        }
        for (let i = 0; i < operationData.data.length; i++) {
            let data = operationData.data[i];
            if (data && data.done) {
                if (data.collected) {
                    document.getElementById(`OPREWARD${i}`).innerHTML += `
                    <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-size: 100% 100%; background-image: url('./images/operation_collected.png');">
                    </div>
                    `;
                } else {
                    document.getElementById(`OPREWARD${i}`).style.cursor = "pointer";
                    document.getElementById(`OPREWARD${i}`).style.backgroundColor = "rgb(0, 255, 0, .4)";
                    document.getElementById(`OPREWARD${i}`).onclick = function () {
                        if (data.type == "silver") {
                            data.collected = true;
                            updateMoneyDisplay("sliver", data.amount);
                        } else if (data.type == "gold") {
                            data.collected = true;
                            updateMoneyDisplay("gold", data.amount);
                        } else if (data.type.includes("token")) {
                            data.collected = true;
                            updateMoneyDisplay(data.type, 1);
                        } else {
                            data.collected = true;
                            updateMoneyDisplay("keys", data.amount);
                        }
                        displayOperation();
                    };
                    document.getElementById(`OPREWARD${i}`).onmouseover = function () {
                        document.getElementById(`OPREWARD${i}`).style.filter = "brightness(125%)";
                    }
                    document.getElementById(`OPREWARD${i}`).onmouseout = function () {
                        document.getElementById(`OPREWARD${i}`).style.filter = "brightness(100%)";
                    }
                }
            } else if (data && !data.done) {
                document.getElementById(`OPREWARD${i}`).onmouseover = function () {
                    document.getElementById(`OPREWARD${i}`).style.filter = "brightness(125%)";
                }
                document.getElementById(`OPREWARD${i}`).onmouseout = function () {
                    document.getElementById(`OPREWARD${i}`).style.filter = "brightness(100%)";
                }
            }
        }
        document.getElementById("rewards").onscroll();
    }
    document.getElementById("operationToggle").onclick = function () {
        if (!operationData.data.length || !operationData.data.some(e => e.collected == null)) {
            generateOperation();
            displayOperation();
        } else {
            displayOperation();
        }
        saveGameData();
    }
    document.addEventListener("click", () => {
        saveGameData();
    });
    var univeralMothershipChargeData = {
        base: 0,
        level: [0, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, 0.1]
    };
    var univeralMothershipChargeData2 = {
        base: 5,
        level: [0, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, .05, 0.1]
    };
    function getMothershipUpgradeCost(level) {
        let index = level + 1;
        if (index >= 55) {
            return 1800 * index;
        } else if (index >= 50) {
            return 1320 * index;
        } else if (index >= 35) {
            return 960 * index;
        } else if (index >= 25) {
            return 720 * index;
        } else if (index >= 15) {
            return 480 * index;
        } else if (index >= 10) {
            return 240 * index;
        } else {
            return 120 * index;
        }
    }
    class mothership {
        constructor(data, using) {
            this.tier = data.tier;
            this.level = 1;
            this.name = data.name;
            this.desc = data.desc;
            this.grayHealing = data.grayHealingData ? data.grayHealingData.base : data.grayHealing;
            this.healingPercent = data.healingPercentData ? data.healingPercentData.base : data.healingPercent;
            this.effectDuration = data.effectDurationData ? data.effectDurationData.base : data.effectDuration;
            this.effectPower = data.effectPowerData ? data.effectPowerData.base : data.effectPower;
            this.dmg = data.dmgData ? data.dmgData.base : data.dmg;
            this.repair = data.repairData ? data.repairData.base : data.repair;
            this.yellowShield = data.yellowShieldData ? data.yellowShieldData.base : data.yellowShield;
            this.chargeSpeed = data.chargeLevel ? data.chargeLevel.base : data.chargeSpeed;
            this.color = data.color;
            this.using = using;
            this.maxlevel = data.maxlevel;
            this.hardpoints = { ...data.hardpoints };
            this.turrets = [];
            this.industryName = data.industryName;
            this.isItem = true;
        }
    }
    var mothershipCost = [2e3, 12e3, 45e3, 95e3, 155e3];
    function mothershipDataThingyPlsSendMod(t) {
        let levels = [];
        if (t == "a") {
            levels.push(0);
            for (let i = 0; i < 39; i++) {
                levels.push(0.0005);
            }
            for (let i = 0; i < 10; i++) {
                levels.push(0.001);
            }
            for (let i = 0; i < 9; i++) {
                levels.push(0.0015);
            }
            levels.push(0.0035);
        } else {
            levels.push(0);
            for (let i = 0; i < 39; i++) {
                levels.push(75);
            }
            for (let i = 0; i < 10; i++) {
                levels.push(125);
            }
            for (let i = 0; i < 10; i++) {
                levels.push(150);
            }
        }
        return levels;
    }
    var mothershipData = [{
        industryName: "Circle",
        tier: 0,
        name: "Gray Rectangle",
        desc: `
        A simple mothership that strikes enemies with a powerful energy charge.<br><br>
        Effect Radius: 500 PX<br>
        Strike Delay: 1 second
        `,
        dmgData: {
            base: 14e3,
            level: [0, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3]
        },
        hardpoints: {
            attack: 1,
            defense: 0,
            support: 0
        },
        chargeLevel: { ...univeralMothershipChargeData },
        maxlevel: 20,
        color: "#808080",
        cost: mothershipCost[0]
    }, {
        industryName: "Circle",
        tier: 1,
        name: "Black Rectangle",
        desc: `
        There is no need to summon monsters where you can be a monster yourself. The Black Rectangle is capable of delivering a devastating laser strike to the enemy.<br><br>
        Effect Radius: 500 PX<br>
        Strike Delay: 1 second
        `,
        dmgData: {
            base: 24e3,
            level: [0, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 3e3, 3e3, 3e3, 4e3, 4e3, 4e3, 4e3, 4e3, 4e3, 4e3]
        },
        hardpoints: {
            attack: 2,
            defense: 0,
            support: 0
        },
        chargeLevel: { ...univeralMothershipChargeData },
        maxlevel: 30,
        color: "#000",
        cost: mothershipCost[1]
    }, {
        industryName: "Triangle",
        tier: 1,
        name: "Green Oval",
        desc: `
        A mothership capable of providing you and your allies with repair micro-bots and the yellow shield defense system while you are in battle. Unfortunately, the ship is not able to calm the egos of your enemies.<br><br>
        Effect Radius: 300 PX<br>
        Strike Delay: 2 second
        `,
        repairData: {
            base: 15e3,
            level: [0, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 3e3, 3e3, 3e3, 4e3, 4e3, 4e3, 4e3, 4e3, 4e3, 4e3]
        },
        yellowShieldData: {
            base: 7e3,
            level: [0, 500, 500, 500, 500, 500, 500, 500, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 5e3, 5e3]
        },
        hardpoints: {
            attack: 0,
            defense: 1,
            support: 1
        },
        chargeLevel: { ...univeralMothershipChargeData },
        maxlevel: 30,
        color: "#0f0",
        cost: mothershipCost[1]
    }, {
        industryName: "Triangle",
        tier: 3,
        name: "Gray Oval",
        desc: `
        A defender ship designed specially for those who want to be in the thick of the fight under a powerful yellow bubble shield. For honor and courage!<br><br>
        Shield Duration: 10 seconds<br>
        Gray Damage Repair: 25%
        `,
        repairData: {
            base: 57e3,
            level: [0, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 1e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 3e3, 3e3, 3e3, 4e3, 4e3, 4e3, 4e3, 4e3, 4e3, 4e3]
        },
        yellowShieldData: {
            base: 100e3,
            level: [0, 2500, 2500, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 5e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 10e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3, 11e3]
        },
        hardpoints: {
            attack: 0,
            defense: 2,
            support: 1
        },
        chargeLevel: { ...univeralMothershipChargeData },
        maxlevel: 40,
        color: "#808080",
        cost: mothershipCost[3]
    }, {
        industryName: "Circle",
        tier: 4,
        name: "Purple Rectangle",
        desc: `
        The ship was created by the Circle Industries to hide in enemy terrain. Equipped with the ability to disable the main systems of enemy shapes, it can provide help in any situation.<br><br>
        <span style="color: #fff">Blind</span> Prevents the enemy radars from rendering any targets.<br><br>
        <span style="color: #fff">EMP</span> Prevents the enemy from activating their shape's special ability.<br><br>
        Effect Radius: 600 PX<br>
        Effects Applied: Bline and EMP<br>
        Strike Delay: 1 second
        `,
        effectDurationData: {
            base: 500,
            level: mothershipDataThingyPlsSendMod()
        },
        hardpoints: {
            attack: 2,
            defense: 0,
            support: 2
        },
        chargeLevel: { ...univeralMothershipChargeData },
        maxlevel: 60,
        color: "#800080",
        cost: mothershipCost[4]
    }, {
        industryName: "Triangle",
        tier: 4,
        name: "Black Oval",
        desc: `
        Developed by leading Triangle engineers, the cutting edge defensive systems of this ship help neutralize some negative effects and restore robot's durability and grey damage.<br><br>
        THe ship gains [Cleanse] Effect. It removes these effects: Lockdown, Slowdown, EMP, Blind, Rust, and Suppression. The max limit for cleanse is 7 stacks.
        `,
        healingPercentData: {
            base: 0.1,
            level: mothershipDataThingyPlsSendMod("a")
        },
        grayHealingData: {
            base: 0.025,
            level: mothershipDataThingyPlsSendMod("a")
        },
        hardpoints: {
            attack: 1,
            defense: 2,
            support: 1
        },
        chargeLevel: { ...univeralMothershipChargeData },
        maxlevel: 60,
        color: "#000",
        cost: mothershipCost[4]
    }, {
        industryName: "Circle",
        tier: 4,
        name: "Yellow Rectangle",
        desc: ``,
        effectPowerData: {
            base: 0.0535,
            level: mothershipDataThingyPlsSendMod("a")
        },
        hardpoints: {
            attack: 1,
            defense: 1,
            support: 2
        },
        chargeLevel: { ...univeralMothershipChargeData },
        maxlevel: 60,
        color: "#ffff00",
        cost: mothershipCost[4]
    }];
    var turretsCost = [1e3, 5500, 15e3, 30e3, 65e3];
    var turretsData = [{
        tier: 0,
        type: "attack",
        name: "Target Ray Cannon",
        strikeDelay: 1e3,
        desc: "After a 1 second delay, it strikes the target.",
        dmg: 7e3,
        imageSource: "./images/weapons/cinder.png",
        scale: 350,
        cost: turretsCost[0]
    }, {
        tier: 1,
        type: "attack",
        name: "Laser Blast Cannon",
        strikeDelay: 1e3,
        desc: "After a 1 second delay, it strikes the target with a powerful laser blast.",
        dmg: 19e3,
        imageSource: "./images/weapons/laser_blast_cannon.png",
        scale: 350,
        cost: turretsCost[1]
    }, {
        tier: 0,
        type: "defense",
        name: "Yellow Shield Self System",
        strikeDelay: 2e3,
        desc: "After a 2 second delay, it grants the shape a yellow shield.",
        shieldHp: 17e3,
        imageSource: "./images/modules/fortifier.png",
        cost: turretsCost[0]
    }, {
        tier: 0,
        type: "support",
        name: "Periodic Fix Station",
        desc: "A turret that repairs a portion of your durability and that of allies in a radius around you in several seconds.",
        scale: 300,
        strikeDelay: 2e3,
        healingData: {
            rate: 500,
            power: 0.02,
            duration: 5e3
        },
        imageSource: "./images/abilities/self_heal.png",
        cost: turretsCost[0]
    }, {
        tier: 3,
        type: "defense",
        name: "Life Saver",
        desc: "When activated, this turret applies Stealth on your robot for 3 seconds, and also gives immunity to Defence Mitigation for 5 seconds. When installing several of these turrets, the duration of the applied effects is not cumulative.",
        strikeDelay: 2e3,
        stealthTime: 3e3,
        antiDefenseMig: 8e3,
        imageSource: "./images/icons/anti_defense_mitigation.png",
        cost: turretsCost[3]
    }, {
        tier: 3,
        type: "support",
        name: "Durability Extender",
        desc: "A turret that increases the Durability of your robot when activated.",
        strikeDelay: 2e3,
        durabilityIncrease: 35e3,
        imageSource: "./images/modules/heavy_armor_plating.png",
        cost: turretsCost[3]
    }, {
        tier: 3,
        type: "defense",
        name: "Anti-Jamming Support",
        desc: "This turret instantly removes the effects of Suppression, EMP and Blind from your shape and provides you with long-term immunity from them.",
        strikeDelay: 2e3,
        imageSource: "./images/icons/anti_jamming_support.png",
        cost: turretsCost[3]
    }, {
        tier: 4,
        type: "attack",
        name: "Nuclear Attack Cannon",
        strikeDelay: 100,
        desc: "Instantly strikes the target with a powerful blast of damage and DoT. Deals increased damage to T4 (150%) and T5 (200%).",
        dmg: 50e3,
        imageSource: "./images/weapons/decay.png",
        scale: 450,
        cost: turretsCost[4]
    }, {
        tier: 4,
        type: "defense",
        name: "Enchanced Shield Self System",
        desc: "It grants the shape a yellow shield with huge durability.",
        shieldHp: 200e3,
        imageSource: "./images/modules/fortifier.png",
        cost: turretsCost[4]
    }];
    function getMothershipImage(obj) {
        let tmpCanvas = document.createElement("canvas");
        tmpCanvas.width = tmpCanvas.height = 3000;
        tmpCanvas.style.width = tmpCanvas.style.height = 3000 + "px";
        let tmpCtx = tmpCanvas.getContext("2d");
        tmpCtx.globalAlpha = 1;
        tmpCtx.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
        if (obj.name.includes("Rectangle")) {
            tmpCtx.fillStyle = obj.color;
            tmpCtx.strokeStyle = "#000";
            tmpCtx.lineWidth = 100;
            tmpCtx.fillRect(-1000, -500, 2000, 1000);
            tmpCtx.strokeRect(-1000, -500, 2000, 1000);
        } else if (obj.name.includes("Oval")) {
            renderOval(0, 0, 1250, 625, tmpCtx, obj.color, "#000", false, false, 100);
        }
        return tmpCanvas;
    }
    function giveMothershipTurrets(shape) {
        let slot = 0;
        let attack = shape.hardpoints.attack;
        if (attack) {
            let turret = turretsData.find(e => e.type == "attack");
            for (let i = 0; i < attack; i++) {
                let index = shape.turrets.length;
                shape.turrets.push({ ...turret });
                shape.turrets[index].slot = slot;
                slot++;
            }
        }
        let defense = shape.hardpoints.defense;
        if (defense) {
            let turret = turretsData.find(e => e.type == "defense");
            for (let i = 0; i < defense; i++) {
                let index = shape.turrets.length;
                shape.turrets.push({ ...turret });
                shape.turrets[index].slot = slot;
                slot++;
            }
        }
        let support = shape.hardpoints.support;
        if (support) {
            let turret = turretsData.find(e => e.type == "support");
            for (let i = 0; i < support; i++) {
                let index = shape.turrets.length;
                shape.turrets.push({ ...turret });
                shape.turrets[index].slot = slot;
                slot++;
            }
        }
    }
    function drawMothershipEquip(shapes, currentIndex, inInventory, JA) {
        let shape = shapes[currentIndex];
        if (!shape.isItem) {
            shape = new mothership(shape);
        }
        let infoDisplayTextThing = getMothershipInfoDisplayThing(shape);
        document.getElementById("WEAPONdisplay").innerHTML = `
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(rgb(0, 0, 0, 0), ${tierColor(shape)});">
        </div>
        <div style="position: absolute; overflow-y: scroll; left: 80px; top: ${(window.innerHeight / 2) - 250}px; width: 325px; height: 290px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.4);">
        <div style="position: absolute; top: 7px; left: 5px;">
        <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(shape)};">
        ${shape.level}
        </div>
        <div style="position: absolute; height: 32.5px; max-height: 32.5px; overflow-y: scroll; top: 2px; width: 260px; left: 45px; color: #fff; font-size: 24px;">
        <strong>
        ${shape.name}
        </strong>
        </div>
        </div>
        <div style="position: absolute; top: 45px; left: 0px;">
        <hr style="position: absolute; top: 0px; left: 0px; color: #fff; width: 325px;">
        <div style="position: absolute; top: 15px; left: 5px; width: 320px;">
        ${infoDisplayTextThing}
        <p></p>
        </div>
        </div>
        </div>
        <div id="shapeImage" style="position: absolute; left: ${window.innerWidth / 2 - 187.5}px; top: ${window.innerHeight / 2 - 187.5}px; width: 375px; height: 375px;">
        <div id="showDescription" style="position: absolute; cursor: pointer; display: flex; align-items: center; right: 0px; top: 0px; width: 35px; height: 35px; background-color: rgb(255, 255, 255, .4); border-radius: 100%;">
        <div style="width: 100%; color: #fff; text-align: center; font-size: 30px;">
        i
        </div>
        </div>
        </div>
        <div style="position: absolute; overflow-y: scroll; right: 80px; top: ${(window.innerHeight / 2) - 267.5}px; width: 325px; height: 500px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.2);">
        <div id="weaponDisplay" style="position: absolute; left: 0px; top: 0px; height: 500px; width: 100%; overflow-y: scroll; background-color: rgb(0, 0, 0, 0.1);">
        </div>
        </div>
        <div id="upgradeMenu" style="position: absolute; z-index: 10000; color: #fff; display: none; top: 12.5%; left: 12.5%; width: 75%; height: 75%; background-color: rgb(0, 0, 0, .7);">
        </div>
        <div id="upgradeShape" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: ${window.innerWidth / 2 + 10}px; bottom: 20px; width: 175px; height: 60px; background-color: rgb(0, 255, 0); border-radius: 6px;">
        UPGRADE
        </div>
        <div id="equipShape" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: ${window.innerWidth / 2 - 185}px; bottom: 20px; width: 175px; height: 60px; background-color: rgb(0, 255, 0); border-radius: 6px;">
        EQUIP
        </div>
        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        <div style="position: absolute; bottom: 100px; left: 12.5%; width: 75%; height: 6px; background-color: #fff; border-radius: 4px; overflow: hidden;">
        <div style="position: absolute; top: 0px; left: ${(1 / shapes.length) * 100 * currentIndex}%; width: ${(1 / shapes.length) * 100}%; height: 100%; background-color: #03fcec;">
        </div>
        </div>
        <div id="buyShape" style="position: absolute; display: none; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: ${window.innerWidth / 2 - 87.5}px; bottom: 20px; width: 175px; height: 60px; background-color: rgb(0, 255, 0); border-radius: 6px;">
        BUY
        </div>
        <div id="buyMenu" style="position: absolute; display: none; color: #fff; top: ${(window.innerHeight / 2) - (225 / 2)}px; left: ${(window.innerWidth / 2) - (425 / 2)}px; width: 425px; height: 225px; background-color: rgb(0, 0, 0, .7);">
        </div>
        `;
        let image = getMothershipImage(shape);
        image.style = `
        width: 100%;
        height: 100%;
        `;
        document.getElementById("shapeImage").appendChild(image);
        if (inInventory) {
            document.getElementById("buyShape").style.display = "none";
            document.getElementById("equipShape").style.display = "block";
            document.getElementById("upgradeShape").style.display = "block";
        } else {
            document.getElementById("buyShape").style.display = "block";
            document.getElementById("equipShape").style.display = "none";
            document.getElementById("upgradeShape").style.display = "none";
            giveMothershipTurrets(shape);
        }
        let order = { "attack": 0, "defense": 1, "support": 2 };
        let tmpT = shape.turrets.sort((a, b) => {
            return order[a.type] - order[b.type];
        });
        for (let i = 0; i < tmpT.length; i++) {
            document.getElementById("weaponDisplay").innerHTML += `
            <div id="${tmpT[i].name}_${i}" style="position: relative; ${inInventory ? "cursor: pointer;" : ""} height: ${500 / 4}px; width: 100%; background-color: ${i % 2 ? "rgb(0, 0, 0, 0.2);" : "rgb(255, 255, 255, 0.1);"}}">
            </div>
            `;
        }
        for (let i = 0; i < tmpT.length; i++) {
            let weapon = tmpT[i];
            let weaponIcon = getWeaponIcon(weapon, true);
            weaponIcon.style = "width: 125px; height: 125px;";
            let yype = weapon.type;
            document.getElementById(`${tmpT[i].name}_${i}`).appendChild(weaponIcon);
            document.getElementById(`${tmpT[i].name}_${i}`).innerHTML += `
            <div style="position: absolute; color: ${tierColor(weapon)}; top: 5px; left: 135px; font-size: 24px;">
            ${weapon.name}
            <div style="color: #fff; font-size: 14px; margin-top: -5px;">${yype.charAt(0).toUpperCase() + yype.slice(1)}</div></div>
            `;
            document.getElementById(`${tmpT[i].name}_${i}`).onclick = function () {
                if (inInventory) {
                    customizeShipTurret(weapon, shape, weapon.slot);
                }
            };
        }
        document.getElementById("buyShape").onclick = function () {
            document.body.appendChild(document.getElementById("moneyDisplay"));
            document.getElementById("buyMenu").style.display = "block";
            document.getElementById("storeButton").style.display = "none";
            document.getElementById("inventoryButton").style.display = "none";
            let num = 60;
            let theHA = shapes[currentIndex];
            document.getElementById("buyMenu").innerHTML = `
            <div style="width: 100%; text-align: center; font-size: 30px;">
            Confirm Purchase
            </div>
            <hr>
            <div id="lo____l" style="position: absolute; cursor: pointer; top: 5px; right: 10px;">
            x
            </div>

            <div style="position: absolute; top: ${num}px; left: ${425 / 2 - 62.5}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
            <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('./images/icons/workshop.png');">
            </div>
            <div style="position: absolute; top: 6.75px; left: 40px;  color: #fff;">
            ${abbreviateNumber(theHA.cost)}
            </div>
            </div>

            <div id="confirm" style="position: absolute; cursor: pointer; font-size: 24px; text-align: center; bottom: 10px; left: ${425 / 2 - 75}px; width: 150px; border-radius: 6px; height: 40px; background-color: #0f0;">
            Confirm
            </div>
            `;
            document.getElementById("confirm").onclick = function () {
                if (player.workshopPoints - theHA.cost >= 0) {
                    updateMoneyDisplay("workshopPoints", -theHA.cost);
                    let data = mothershipData.find(e => e.name == theHA.name);
                    let old = player.motherships.find(e => e.using);
                    if (old) {
                        old.using = false;
                    }
                    let index = player.motherships.length;
                    player.motherships.push(new mothership(data, true));
                    giveMothershipTurrets(player.motherships[index]);
                    document.getElementById("sideDisplay").innerHTML = "";
                    document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                    updateMothershipDisplay();
                    saveGameData();
                }
            }
            document.getElementById("lo____l").onclick = function () {
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                document.getElementById("buyMenu").style.display = "none";
                document.getElementById("storeButton").style.display = "block";
                document.getElementById("inventoryButton").style.display = "block";
            }
        }
        document.getElementById("equipShape").onclick = function () {
            let oldShip = player.motherships.find(e => e.using);
            if (oldShip) {
                oldShip.using = false;
            }
            shape.using = true;
            document.getElementById("sideDisplay").innerHTML = "";
            updateMothershipDisplay();
            saveGameData();
        }
        document.getElementById("upgradeShape").onclick = function () {
            document.body.appendChild(document.getElementById("moneyDisplay"));
            let adjustwidth = window.innerWidth * .75;
            document.getElementById("upgradeMenu").style.display = "block";
            let cost = getMothershipUpgradeCost(shape.level);
            document.getElementById("upgradeMenu").innerHTML = `
            <div style="width: 100%; text-align: center; margin-top: 5px; font-size: 30px;">
            Lvl ${shape.level} ${shape.name}
            </div>
            <hr>
            <div style="position: absolute; left: 300px; top: 65px;">
            ${enterBarForShip("dmg", shape)}
            ${enterBarForShip("repair", shape)}
            ${enterBarForShip("yellow shield", shape)}
            ${enterBarForShip("effect duration", shape)}
            ${enterBarForShip("healingPercent", shape)}
            ${enterBarForShip("grayHealing", shape)}

            ${enterBarForShip("charge", shape)}
            </div>
            <div id="leaveUpgrade" style="position: absolute; cursor: pointer; right: 10px; top: 10px;">
            X
            </div>
            <div id="UPGRADE" style="position: absolute; width: 200px; height: 80px; cursor: pointer; left: ${adjustwidth / 2 - 100}px; bottom: 10px; background-color: ${shape.level < shape.maxlevel ? "#00ff00" : "#808080"};">
            <div style="width: 100%; text-align: center; color: #fff; font-size: ${shape.level < shape.maxlevel ? 30 : 40}px; margin-top: 10px;">
            ${shape.level < shape.maxlevel ? "UPGRADE" : "MAXED"}
            </div>
            <div style="color: #fff; display: ${shape.level < shape.maxlevel ? "block" : "none"}; width: 100%; text-align: center; font-size: 12px;">
            ${abbreviateNumber(cost)} WKSP
            </div>
            </div>
            `;
            let sprite = getMothershipImage(shape);
            sprite.style = "width: 280px; height: 280px;";
            document.getElementById("upgradeMenu").appendChild(sprite);
            document.getElementById("leaveUpgrade").onclick = function () {
                document.getElementById("upgradeMenu").style.display = "none";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            };
            document.getElementById("UPGRADE").onclick = function () {
                if (player.workshopPoints - cost >= 0 && shape.level < shape.maxlevel) {
                    updateMoneyDisplay("workshopPoints", -cost);
                    upgradeMothership(shape);
                    drawMothershipEquip(shapes, currentIndex, inInventory, true);
                    saveGameData();
                }
            };
        }
        document.getElementById("backButton").onclick = function () {
            document.getElementById("sideDisplay").innerHTML = "";
            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            document.getElementById("mothershipToggle").click();
        }
        document.getElementById("showDescription").onclick = function () {
            let element = document.createElement("div");
            element.style = `
            position: absolute;
            top: 12.5%;
            left: 12.5%;
            width: 75%;
            height: 75%;
            background-color: rgb(0, 0, 0, 0.75);
            z-index: 99;
            border-radius: 6px;
            `;
            let width = window.innerWidth * .75;
            let height = window.innerHeight * .75;
            let box = width / 2 - 80;
            element.innerHTML = `
            <div style="position: absolute; top: 7px; left: 10px; width: ${width - 10}px;">
            <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(shape)};">
            ${shape.level}
            </div>
            <div style="position: absolute; top: 2px; left: 45px; color: #fff; font-size: 24px;">
            <strong>
            ${returnStyledName(shape, shape.name)}
            </strong>
            </div>
            </div>
            <div id="imageShape2" style="position: absolute; top: ${(height / 2) - (box / 2)}px; left: 40px; width: ${box}px; height: ${box}px;">
            </div>
            <div style="position: absolute; color: #a3a3a3; top: 0px; left: ${width / 2}px; width: ${width / 2}px; height: 100%; overflow-y: scroll;">
            <div style="margin-top: 5px;">
            <strong style="color: #fff;">Industry: ${shape.industryName}</strong><br><br>
            ${shape.desc}<br><br>
            Mothership Stats:<br>
            ${infoDisplayTextThing}
            <p></p>
            </div>
            </div>
            `;
            document.getElementById("sideDisplay").append(element);
            element.onclick = function () {
                this.remove();
            }
            let image = getMothershipImage(shape);
            image.style = "width: 100%; height: 100%;";
            document.getElementById("imageShape2").appendChild(image);
        }
        if (JA) {
            document.getElementById("upgradeShape").click();
        }
    }
    function getMothershipInfoDisplayThing(shape) {
        return `
        ${shape.repair ? `Repair Power: ${abbreviateNumber(shape.repair)}<br>` : ""}
        ${shape.dmg ? `Strike Damage: ${abbreviateNumber(shape.dmg)}<br>` : ""}
        ${shape.effectDuration ? `Effect Duration: ${shape.effectDuration / 1e3} second(s)<br>` : ""}
        ${shape.yellowShield ? `Energy Shield Health: ${abbreviateNumber(shape.yellowShield)}<br>` : ""}
        ${shape.healingPercent ? `Durability Repair: ${Math.round(shape.healingPercent * 10000) / 100}%<br>` : ""}
        ${shape.grayHealing ? `Gray Damage Repair: ${Math.round(shape.grayHealing * 10000) / 100}%<br>` : ""}
        ${shape.effectPower ? `Effect Power: ${Math.round(shape.effectPower * 10000) / 100}%<br>` : ""}
        Charge Speed Modifier: ${Math.round(shape.chargeSpeed * 100)}%
        `;
    }
    function upgradeMothership(shape) {
        let data = mothershipData.find(e => e.name == shape.name);
        if (data.dmgData && data.dmgData.level[shape.level]) {
            shape.dmg += data.dmgData.level[shape.level];
        }
        if (data.grayHealingData && data.grayHealingData.level[shape.level]) {
            shape.grayHealing += data.grayHealingData.level[shape.level];
        }
        if (data.effectDurationData && data.effectDurationData.level[shape.level]) {
            shape.effectDuration += data.effectDurationData.level[shape.level];
        }
        if (data.healingPercentData && data.healingPercentData.level[shape.level]) {
            shape.healingPercent += data.healingPercentData.level[shape.level];
        }
        if (data.effectPowerData && data.effectPowerData.level[shape.level]) {
            shape.effectPower += data.effectPowerData.level[shape.level];
        }
        if (data.yellowShieldData && data.yellowShieldData.level[shape.level]) {
            shape.yellowShield += data.yellowShieldData.level[shape.level];
        }
        if (data.repairData && data.repairData.level[shape.level]) {
            shape.repair += data.repairData.level[shape.level];
        }
        if (data.chargeLevel && data.chargeLevel.level[shape.level]) {
            shape.chargeSpeed += data.chargeLevel.level[shape.level];
        }
        shape.level++;
    }
    function enterBarForShip(type, weapon) {
        let text = "";
        let Weapon = mothershipData.find(item => item.name == weapon.name)
        let maxwidth = window.innerWidth >= 1442 ? 500 : window.innerWidth >= 1374 ? 450 : window.innerWidth >= 1311 ? 400 : window.innerWidth >= 1245 ? 350 : window.innerWidth >= 1182 ? 300 : 250;
        maxwidth += 281.25;
        if (type == "dmg" && Weapon.dmgData) {
            let maxdmg = Weapon.dmgData.base;
            for (let i = 0; i < Weapon.dmgData.level.length; i++) {
                maxdmg += Weapon.dmgData.level[i];
            }
            let indexAdjust = ((weapon.dmg / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.dmg + (Weapon.dmgData.level[weapon.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Damage: ${abbreviateNumber(weapon.dmg)}
            <div style="display: ${Weapon.dmgData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${abbreviateNumber(Weapon.dmgData.level[weapon.level])}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;

        } else if (type == "effectPower" && Weapon.effectPowerData) {
            let maxdmg = Weapon.effectPowerData.base;
            for (let i = 0; i < Weapon.effectPowerData.level.length; i++) {
                maxdmg += Weapon.effectPowerData.level[i];
            }
            let indexAdjust = ((weapon.effectPower / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.effectPower + (Weapon.effectPowerData.level[weapon.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Effect power: ${(weapon.effectPower * 100)}%
            <div style="display: ${Weapon.effectPowerData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${(Weapon.effectPowerData.level[weapon.level] * 100)}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "charge") {
            let maxdmg = Weapon.chargeLevel.base;
            for (let i = 0; i < Weapon.chargeLevel.level.length; i++) {
                maxdmg += Weapon.chargeLevel.level[i];
            }
            let indexAdjust = ((weapon.chargeSpeed / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.chargeSpeed + (Weapon.chargeLevel.level[weapon.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Charge Speed Modifier: ${Math.round(weapon.chargeSpeed * 100)}%
            <div style="display: ${Weapon.chargeLevel.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Math.round(Weapon.chargeLevel.level[weapon.level] * 100)}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "repair" && Weapon.repairData) {
            let maxdmg = Weapon.repairData.base;
            for (let i = 0; i < Weapon.repairData.level.length; i++) {
                maxdmg += Weapon.repairData.level[i];
            }
            let indexAdjust = ((weapon.repair / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.repair + (Weapon.repairData.level[weapon.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Repair Power: ${abbreviateNumber(weapon.repair)}
            <div style="display: ${Weapon.repairData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${abbreviateNumber(Weapon.repairData.level[weapon.level])}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "yellow shield" && Weapon.yellowShieldData) {
            let maxdmg = Weapon.yellowShieldData.base;
            for (let i = 0; i < Weapon.yellowShieldData.level.length; i++) {
                maxdmg += Weapon.yellowShieldData.level[i];
            }
            let indexAdjust = ((weapon.yellowShield / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.yellowShield + (Weapon.yellowShieldData.level[weapon.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Energy Shield Health: ${abbreviateNumber(weapon.yellowShield)}
            <div style="display: ${Weapon.yellowShieldData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${abbreviateNumber(Weapon.yellowShieldData.level[weapon.level])}
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "effect duration" && Weapon.effectDurationData) {
            let maxdmg = Weapon.effectDurationData.base;
            for (let i = 0; i < Weapon.effectDurationData.level.length; i++) {
                maxdmg += Weapon.effectDurationData.level[i];
            }
            let indexAdjust = ((weapon.effectDuration / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.effectDuration + (Weapon.effectDurationData.level[weapon.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Effect Duration: ${weapon.effectDuration / 1e3} second(s)
            <div style="display: ${Weapon.effectDurationData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Weapon.effectDurationData.level[weapon.level] / 1e3} second(s)
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "healingPercent" && Weapon.healingPercentData) {
            let maxdmg = Weapon.healingPercentData.base;
            for (let i = 0; i < Weapon.healingPercentData.level.length; i++) {
                maxdmg += Weapon.healingPercentData.level[i];
            }
            let indexAdjust = ((weapon.healingPercent / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.healingPercent + (Weapon.healingPercentData.level[weapon.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Durability Repair: ${Math.round(weapon.healingPercent * 10000) / 100}%
            <div style="display: ${Weapon.healingPercentData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Math.round(Weapon.healingPercentData.level[weapon.level] * 10000) / 100}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        } else if (type == "grayHealing" && Weapon.grayHealingData) {
            let maxdmg = Weapon.grayHealingData.base;
            for (let i = 0; i < Weapon.grayHealingData.level.length; i++) {
                maxdmg += Weapon.grayHealingData.level[i];
            }
            let indexAdjust = ((weapon.grayHealing / maxdmg) * maxwidth) / maxwidth;
            let indexAdjusted = (((weapon.grayHealing + (Weapon.grayHealingData.level[weapon.level])) / maxdmg) * maxwidth) / maxwidth;
            text = `
            <div style="position: relative; width: ${maxwidth}px;">
            Gray Damage Repair: ${Math.round(weapon.grayHealing * 10000) / 100}%
            <div style="display: ${Weapon.grayHealingData.level[weapon.level] ? "block" : "none"};position: absolute; top: 0px; right: 0px; color: #00ff00;">
            +${Math.round(Weapon.grayHealingData.level[weapon.level] * 10000) / 100}%
            </div>
            </div>
            <div style="position: relative; width: ${maxwidth}px; height: 3px; background-color: #fff;">
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjusted * 100}%; background-color: #02de02;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; height: 3px; width: ${indexAdjust * 100}%; background-color: #00fcec;">
            </div>
            </div>
            `;
        }
        return text;
    }
    function drawMothershipDisplay(module, index, shape, slot) {
        document.getElementById("WEAPONdisplay").innerHTML = `
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(rgb(0, 0, 0, 0), ${tierColor(module)});">
        </div>
        <div id="weaponImage" style="position: absolute; top: ${window.innerHeight / 2 - 187.5}px; left: ${window.innerWidth / 2 - 187.5}px; height: 375px; width: 375px;">
        </div>
        <div style="position: absolute; text-align: center; top: ${window.innerHeight / 2 + 187.5}px; left: ${window.innerWidth / 2 - 187.5}px; height: 50px; width: 375px;">
        </div>
        <div style="position: absolute; top: ${window.innerHeight / 2 - 250}px; left: ${window.innerWidth / 2 - 522.5}px; width: 325px; height: 500px; background-color: rgb(0, 0, 0, .2); border: solid; border-color: #fff; border-radius: 6px; overflow-y: scroll;">
        <div style="position: absolute; top: 7px; left: 5px;">
        <div style="position: absolute; top: 2px; width: 260px; left: 5px; color: #fff; font-size: 24px;">
        <strong>
        ${module.name}
        </strong>
        </div>
        </div>
        <div style="position: absolute; top: 45px; left: 0px;">
        <hr style="position: absolute; top: 0px; left: 0px; color: #fff; width: 325px;">
        <div style="position: absolute; top: 15px; left: 5px; width: 320px;">
        ${module.desc}<br>
        <hr style="position: absolute; left: -5px; color: #fff; width: 325px;">
        <br>
        ${module.dmg ? `Strike Damage: ${abbreviateNumber(module.dmg)}<br>` : ""}
        ${module.scale ? `Effect Radius: ${abbreviateNumber(module.scale)} PX<br>` : ""}
        ${module.shieldHp ? `Shield Health: ${abbreviateNumber(module.shieldHp)}<br>` : ""}
        ${module.healingData ? `
        Healing Rate: ${(module.healingData.rate / 1e3).toFixed(1)} second(s)<br>
        Healing Power: ${module.healingData.power * 100}%<br>
        Healing Duration: ${(module.healingData.duration / 1e3).toFixed(1)} second(s)<br>
        ` : ""}
        ${module.stealthTime ? `Stealth Duration: ${module.stealthTime / 1e3} second(s)<br>` : ""}
        ${module.antiDefenseMig ? `Anti Defense Mitigation Duration: ${module.antiDefenseMig / 1e3} second(s)<br>` : ""}
        ${module.durabilityIncrease ? `Durability Increase: ${styleNumberWithCommas(module.durabilityIncrease)}<br>` : ""}
        ${module.strikeDelay ? `Strike Delay: ${(module.strikeDelay / 1e3).toFixed(1)} second(s)<br>` : ""}
        <p></p>
        </div>
        </div>
        </div>
        <div id="buyTurret" style="display: ${index > 0 ? "block" : "none"}; position: absolute; color: #fff; text-align: center; font-size: 35px; left: ${window.innerWidth / 2 + 187.5}px; top: ${window.innerHeight / 2 - 25}px; cursor: pointer; width: 325px; height: 50px; border-radius: 6px; background-color: #0f0;">
        BUY
        </div>
        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        <div id="buyMenu" style="position: absolute; display: none; color: #fff; top: ${(window.innerHeight / 2) - (225 / 2)}px; left: ${(window.innerWidth / 2) - (425 / 2)}px; width: 425px; height: 225px; background-color: rgb(0, 0, 0, .7);">
        </div>
        `;
        let weaponImg = getWeaponIcon(module, true);
        weaponImg.style = "width: 100%; height: 100%;";
        document.getElementById("weaponImage").appendChild(weaponImg);
        document.getElementById("buyTurret").onclick = function () {
            document.body.appendChild(document.getElementById("moneyDisplay"));
            document.getElementById("buyMenu").style.display = "block";
            let num = 60;
            document.getElementById("buyMenu").innerHTML = `
            <div style="width: 100%; text-align: center; font-size: 30px;">
            Confirm Purchase
            </div>
            <hr>
            <div id="lo____l" style="position: absolute; cursor: pointer; top: 5px; right: 10px;">
            x
            </div>

            <div style="position: absolute; top: ${num}px; left: ${425 / 2 - 62.5}px; border: solid; border-color: #fff; border-radius: 6px; width: 125px; height: 35px; background-color: rgb(0, 0, 0, 0.2);">
            <div style="position: absolute; top: 0px; left: 0px; width: 35px; height: 35px; background-size: 35px 35px; background-image: url('./images/icons/workshop.png');">
            </div>
            <div style="position: absolute; top: 6.75px; left: 40px;  color: #fff;">
            ${abbreviateNumber(module.cost)}
            </div>
            <div style="position: absolute; text-align: center; top: 46.75px; left: -40px;  color: #fff; width: 200px;">
            The previous turret will be destroyed.
            </div>
            </div>

            <div id="confirm" style="position: absolute; cursor: pointer; font-size: 24px; text-align: center; bottom: 10px; left: ${425 / 2 - 75}px; width: 150px; border-radius: 6px; height: 40px; background-color: #0f0;">
            Confirm
            </div>
            `;
            document.getElementById("confirm").onclick = function () {
                if (player.workshopPoints - module.cost >= 0) {
                    updateMoneyDisplay("workshopPoints", -module.cost);
                    document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"))
                    shape.turrets[slot] = { ...module };
                    shape.turrets[slot].slot = slot;
                    if (shape.using) {
                        customizeMothership(shape);
                    } else {
                        let eee = player.motherships.find(e => e.using);
                        customizeMothership(eee);
                        equipMothership();
                    }
                }
            }
            document.getElementById("lo____l").onclick = function () {
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
                document.getElementById("buyMenu").style.display = "none";
                document.getElementById("storeButton").style.display = "block";
                document.getElementById("inventoryButton").style.display = "block";
            }
        }
        document.getElementById("backButton").onclick = function () {
            document.getElementById("sideDisplay").innerHTML = "";
            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            document.getElementById("mothershipToggle").click();
        }
    }
    function customizeShipTurret(module, shape, slot) {
        let filtered = turretsData.filter(e => e.name != module.name && e.type == module.type).sort((a, b) => a.tier - b.tier);
        filtered.unshift(module);
        let currentIndex = 0;
        document.getElementById("sideDisplay").innerHTML = `
        <div id="WEAPONdisplay" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;">
        </div>
        <div id="goToPre" style="display: none; position: absolute; cursor: pointer; left: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToPreCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_before
        </span>
        </div>
        </div>
        <div id="goToNext" style="position: absolute; transition: .25s; cursor: pointer; right: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToNextCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_next
        </span>
        </div>
        </div>
        `;
        drawMothershipDisplay(filtered[currentIndex], currentIndex, shape, slot);
        if (!filtered[currentIndex - 1]) {
            document.getElementById("goToPre").style.display = "none";
        }
        document.getElementById("goToPre").onclick = function () {
            currentIndex--;
            drawMothershipDisplay(filtered[currentIndex], currentIndex, shape, slot);
            if (!filtered[currentIndex - 1]) {
                document.getElementById("goToPre").style.display = "none";
            } else {
                document.getElementById("goToPre").style.display = "block";
            }
            if (!filtered[currentIndex + 1]) {
                document.getElementById("goToNext").style.display = "none";
            } else {
                document.getElementById("goToNext").style.display = "block";
            }
        }
        if (!filtered[currentIndex + 1]) {
            document.getElementById("goToNext").style.display = "none";
        }
        document.getElementById("goToNext").onclick = function () {
            currentIndex++;
            drawMothershipDisplay(filtered[currentIndex], currentIndex, shape, slot);
            if (!filtered[currentIndex + 1]) {
                document.getElementById("goToNext").style.display = "none";
            } else {
                document.getElementById("goToNext").style.display = "block";
            }
            if (!filtered[currentIndex - 1]) {
                document.getElementById("goToPre").style.display = "none";
            } else {
                document.getElementById("goToPre").style.display = "block";
            }
        }
        document.getElementById("goToNext").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToNextCon").style.color = "#000";
        }
        document.getElementById("goToNext").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToNextCon").style.color = "#fff";
        }
        document.getElementById("goToPre").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToPreCon").style.color = "#000";
        }
        document.getElementById("goToPre").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToPreCon").style.color = "#fff";
        }
    }
    var MOOOOOOOTHERSHIP = mothership;
    function customizeMothership(shape, HA) {
        document.getElementById("mothershipDisplayyy").style.display = "none";
        let infoDisplayTextThing = getMothershipInfoDisplayThing(shape);
        document.getElementById("sideDisplay").innerHTML = `
        <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-image: linear-gradient(rgb(0, 0, 0, 0), ${tierColor(shape)});">
        </div>
        <div style="position: absolute; overflow-y: scroll; left: 80px; top: ${(window.innerHeight / 2) - 250}px; width: 325px; height: 290px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.4);">
        <div style="position: absolute; top: 7px; left: 5px;">
        <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(shape)};">
        ${shape.level}
        </div>
        <div style="position: absolute; height: 32.5px; max-height: 32.5px; overflow-y: scroll; top: 2px; width: 260px; left: 45px; color: #fff; font-size: 24px;">
        <strong>
        ${shape.name}
        </strong>
        </div>
        </div>
        <div style="position: absolute; top: 45px; left: 0px;">
        <hr style="position: absolute; top: 0px; left: 0px; color: #fff; width: 325px;">
        <div style="position: absolute; top: 15px; left: 5px; width: 320px;">
        ${infoDisplayTextThing}
        <p></p>
        </div>
        </div>
        </div>
        <div id="shapeImage" style="position: absolute; left: ${window.innerWidth / 2 - 187.5}px; top: ${window.innerHeight / 2 - 187.5}px; width: 375px; height: 375px;">
        <div id="showDescription" style="position: absolute; cursor: pointer; display: flex; align-items: center; right: 0px; top: 0px; width: 35px; height: 35px; background-color: rgb(255, 255, 255, .4); border-radius: 100%;">
        <div style="width: 100%; color: #fff; text-align: center; font-size: 30px;">
        i
        </div>
        </div>
        </div>
        <div style="position: absolute; overflow-y: scroll; right: 80px; top: ${(window.innerHeight / 2) - 267.5}px; width: 325px; height: 500px; border: solid; border-radius: 6px; border-color: #fff; background-color: rgb(0, 0, 0, 0.2);">
        <div id="weaponDisplay" style="position: absolute; left: 0px; top: 0px; height: 500px; width: 100%; overflow-y: scroll; background-color: rgb(0, 0, 0, 0.1);">
        </div>
        </div>
        <div id="upgradeMenu" style="position: absolute; z-index: 10000; color: #fff; display: none; top: 12.5%; left: 12.5%; width: 75%; height: 75%; background-color: rgb(0, 0, 0, .7);">
        </div>
        <div id="upgradeShape" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: ${window.innerWidth / 2 + 10}px; bottom: 20px; width: 175px; height: 60px; background-color: rgb(0, 255, 0); border-radius: 6px;">
        UPGRADE
        </div>
        <div id="changeShape" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: ${window.innerWidth / 2 - 185}px; bottom: 20px; width: 175px; height: 60px; background-color: #808080; border-radius: 6px;">
        CHANGE
        </div>
        <div id="backButton" style="position: absolute; cursor: pointer; text-align: center; font-size: 40px; color: #fff; left: 20px; bottom: 20px; width: 150px; height: 60px; background-color: rgb(124, 124, 124, 1); border: solid; border-color: #fff; border-radius: 6px;">
        BACK
        </div>
        `;
        let image = getMothershipImage(shape);
        image.style = `
        width: 100%;
        height: 100%;
        `;
        document.getElementById("shapeImage").appendChild(image);
        let order = { "attack": 0, "defense": 1, "support": 2 };
        let tmpT = shape.turrets.sort((a, b) => {
            return order[a.type] - order[b.type];
        });
        for (let i = 0; i < tmpT.length; i++) {
            document.getElementById("weaponDisplay").innerHTML += `
            <div id="${tmpT[i].name}_${i}" style="position: relative; cursor: pointer; height: ${500 / 4}px; width: 100%; background-color: ${i % 2 ? "rgb(0, 0, 0, 0.2);" : "rgb(255, 255, 255, 0.1);"}}">
            </div>
            `;
        }
        for (let i = 0; i < tmpT.length; i++) {
            let weapon = tmpT[i];
            let weaponIcon = getWeaponIcon(weapon, true);
            weaponIcon.style = "width: 125px; height: 125px;";
            let yype = weapon.type;
            document.getElementById(`${tmpT[i].name}_${i}`).appendChild(weaponIcon);
            document.getElementById(`${tmpT[i].name}_${i}`).innerHTML += `
            <div style="position: absolute; color: ${tierColor(weapon)}; top: 5px; left: 135px; font-size: 24px;">
            ${weapon.name}
            <div style="color: #fff; font-size: 14px; margin-top: -5px;">${yype.charAt(0).toUpperCase() + yype.slice(1)}</div></div>
            `;
            document.getElementById(`${tmpT[i].name}_${i}`).onclick = function () {
                customizeShipTurret(weapon, shape, weapon.slot);
            };
        }
        document.getElementById("showDescription").onclick = function () {
            let element = document.createElement("div");
            element.style = `
            position: absolute;
            top: 12.5%;
            left: 12.5%;
            width: 75%;
            height: 75%;
            background-color: rgb(0, 0, 0, 0.75);
            z-index: 99;
            border-radius: 6px;
            `;
            let width = window.innerWidth * .75;
            let height = window.innerHeight * .75;
            let box = width / 2 - 80;
            element.innerHTML = `
            <div style="position: absolute; top: 7px; left: 10px; width: ${width - 10}px;">
            <div style="position: absolute; top: 0px; left: 0px; text-align: center; color: #fff; font-size: 25px; border-radius: 100%; width: 40px; height: 40px; background-color: ${tierColor(shape)};">
            ${shape.level}
            </div>
            <div style="position: absolute; top: 2px; left: 45px; color: #fff; font-size: 24px;">
            <strong>
            ${returnStyledName(shape, shape.name)}
            </strong>
            </div>
            </div>
            <div id="imageShape2" style="position: absolute; top: ${(height / 2) - (box / 2)}px; left: 40px; width: ${box}px; height: ${box}px;">
            </div>
            <div style="position: absolute; color: #a3a3a3; top: 0px; left: ${width / 2}px; width: ${width / 2}px; height: 100%; overflow-y: scroll;">
            <div style="margin-top: 5px;">
            <strong style="color: #fff;">Industry: ${shape.industryName}</strong><br><br>
            ${shape.desc}<br><br>
            Mothership Stats:<br>
            ${infoDisplayTextThing}
            <p></p>
            </div>
            </div>
            `;
            document.getElementById("sideDisplay").append(element);
            element.onclick = function () {
                this.remove();
            }
            let image = getMothershipImage(shape);
            image.style = "width: 100%; height: 100%;";
            document.getElementById("imageShape2").appendChild(image);
        }
        document.getElementById("changeShape").onclick = function () {
            equipMothership();
        }
        document.getElementById("upgradeShape").onclick = function () {
            document.body.appendChild(document.getElementById("moneyDisplay"));
            let adjustwidth = window.innerWidth * .75;
            document.getElementById("upgradeMenu").style.display = "block";
            let cost = getMothershipUpgradeCost(shape.level);
            document.getElementById("upgradeMenu").innerHTML = `
            <div style="width: 100%; text-align: center; margin-top: 5px; font-size: 30px;">
            Lvl ${shape.level} ${shape.name}
            </div>
            <hr>
            <div style="position: absolute; left: 300px; top: 65px;">
            ${enterBarForShip("dmg", shape)}
            ${enterBarForShip("repair", shape)}
            ${enterBarForShip("yellow shield", shape)}
            ${enterBarForShip("effect duration", shape)}
            ${enterBarForShip("healingPercent", shape)}
            ${enterBarForShip("grayHealing", shape)}
            ${enterBarForShip("effectPower", shape)}

            ${enterBarForShip("charge", shape)}
            </div>
            <div id="leaveUpgrade" style="position: absolute; cursor: pointer; right: 10px; top: 10px;">
            X
            </div>
            <div id="UPGRADE" style="position: absolute; width: 200px; height: 80px; cursor: pointer; left: ${adjustwidth / 2 - 100}px; bottom: 10px; background-color: ${shape.level < shape.maxlevel ? "#00ff00" : "#808080"};">
            <div style="width: 100%; text-align: center; color: #fff; font-size: ${shape.level < shape.maxlevel ? 30 : 40}px; margin-top: 10px;">
            ${shape.level < shape.maxlevel ? "UPGRADE" : "MAXED"}
            </div>
            <div style="color: #fff; display: ${shape.level < shape.maxlevel ? "block" : "none"}; width: 100%; text-align: center; font-size: 12px;">
            ${abbreviateNumber(cost)} WKSP
            </div>
            </div>
            `;
            let sprite = getMothershipImage(shape);
            sprite.style = "width: 280px; height: 280px;";
            document.getElementById("upgradeMenu").appendChild(sprite);
            document.getElementById("leaveUpgrade").onclick = function () {
                document.getElementById("upgradeMenu").style.display = "none";
                document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            };
            document.getElementById("UPGRADE").onclick = function () {
                if (player.workshopPoints - cost >= 0 && shape.level < shape.maxlevel) {
                    updateMoneyDisplay("workshopPoints", -cost);
                    upgradeMothership(shape);
                    customizeMothership(shape, true);
                    saveGameData();
                }
            };
        }
        document.getElementById("backButton").onclick = function () {
            document.getElementById("sideDisplay").innerHTML = "";
            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            document.getElementById("mothershipToggle").click();
        }
        if (HA) {
            document.getElementById("upgradeShape").click();
        }
    }
    function equipMothership() {
        document.getElementById("mothershipDisplayyy").style.display = "none";
        let unequipedShapes = player.motherships.filter(e => !e.using);
        let oldShape = player.motherships.find(e => e.using);
        let filteredRobots = [];
        for (let i = 0; i < unequipedShapes.length; i++) {
            filteredRobots.push(unequipedShapes[i]);
        }
        filteredRobots = filteredRobots.sort((a, b) => b.level - a.level).sort((a, b) => b.tier - a.tier);
        if (oldShape) filteredRobots.unshift(oldShape);
        let currentIndex = 0;
        document.getElementById("sideDisplay").innerHTML = `
        <div id="WEAPONdisplay" style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;">
        </div>
        <div id="goToPre" style="display: none; position: absolute; cursor: pointer; left: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToPreCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_before
        </span>
        </div>
        </div>
        <div id="goToNext" style="position: absolute; transition: .25s; cursor: pointer; right: 10px; top: ${window.innerHeight / 2 - 200}px; width: 40px; height: 400px; background-color: rgb(0, 0, 0, 0.3); border-radius: 8px;">
        <div id="goToNextCon" style="overflow: hidden; color: #fff; position: absolute; width: 40px; text-align: center; left: 0px; top: ${200 - 20}px;">
        <span class="material-symbols-outlined" style="font-size: 40px;">
        navigate_next
        </span>
        </div>
        </div>
        <div id="inventoryButton" style="position: absolute; text-align: center; font-size: 25px; color: #000; left: ${window.innerWidth / 2 - 165}px; top: 30px; border-radius: 6px; height: 42.5px; padding-top: 7.5px; width: 150px; background-color: rgb(255, 255, 255, .6);">
        INVENTORY
        </div>
        <div id="storeButton" style="position: absolute; text-align: center; font-size: 35px; cursor: pointer; color: #fff; left: ${window.innerWidth / 2 + 20}px; top: 30px; border-radius: 6px; height: 50px; width: 150px; background-color: rgb(0, 0, 0, .4);">
        STORE
        </div>
        `;
        let inInventory = true;
        let diiiisbled = false;
        document.getElementById("inventoryButton").onclick = function () {
            if (!diiiisbled) {
                this.style.cursor = null;
                this.style.color = "#000";
                this.style.backgroundColor = "rgb(255, 255, 255, .6)";
                document.getElementById("goToPre").style.display = "none";
                document.getElementById("storeButton").style.cursor = "pointer";
                document.getElementById("storeButton").style.color = "#fff";
                document.getElementById("storeButton").style.backgroundColor = "rgb(0, 0, 0, .4)";
                currentIndex = 0;
                inInventory = true;
                if (filteredRobots[currentIndex + 1]) {
                    document.getElementById("goToNext").style.display = "block";
                } else {
                    document.getElementById("goToNext").style.display = "none";
                }
                drawMothershipEquip(inInventory ? filteredRobots : mothershipData.sort((a, b) => a.tier - b.tier), currentIndex, inInventory);
            }
        };
        document.getElementById("storeButton").onclick = function () {
            this.style.cursor = null;
            this.style.color = "#000";
            this.style.backgroundColor = "rgb(255, 255, 255, .6)";
            document.getElementById("goToPre").style.display = "none";
            document.getElementById("inventoryButton").style.cursor = "pointer";
            document.getElementById("inventoryButton").style.color = "#fff";
            document.getElementById("inventoryButton").style.backgroundColor = "rgb(0, 0, 0, .4)";
            currentIndex = 0;
            inInventory = false;
            if (mothershipData[currentIndex + 1]) {
                document.getElementById("goToNext").style.display = "block";
            } else {
                document.getElementById("goToNext").style.display = "none";
            }
            drawMothershipEquip(inInventory ? filteredRobots : mothershipData.sort((a, b) => a.tier - b.tier), currentIndex, inInventory);
        };
        if (filteredRobots.length == 0) {
            document.getElementById("storeButton").click();
            document.getElementById("inventoryButton").style.cursor = null;
            diiiisbled = true;
        }
        drawMothershipEquip(inInventory ? filteredRobots : mothershipData.sort((a, b) => a.tier - b.tier), currentIndex, inInventory);
        if (inInventory ? !filteredRobots[currentIndex + 1] : !mothershipData[currentIndex + 1]) {
            document.getElementById("goToNext").style.display = "none";
        }
        document.getElementById("goToNext").onclick = function () {
            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            if (inInventory ? filteredRobots[currentIndex + 1] : mothershipData[currentIndex + 1]) {
                currentIndex++;
                drawMothershipEquip(inInventory ? filteredRobots : mothershipData.sort((a, b) => a.tier - b.tier), currentIndex, inInventory);
                if (inInventory ? filteredRobots[currentIndex + 1] : mothershipData[currentIndex + 1]) {
                    this.style.display = "block";
                } else {
                    this.style.display = "none";
                }
                if (inInventory ? filteredRobots[currentIndex - 1] : mothershipData[currentIndex - 1]) {
                    document.getElementById("goToPre").style.display = "block";
                } else {
                    document.getElementById("goToPre").style.display = "none";
                }
            }
        }
        document.getElementById("goToNext").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToNextCon").style.color = "#000";
        }
        document.getElementById("goToNext").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToNextCon").style.color = "#fff";
        }
        document.getElementById("goToPre").onclick = function () {
            document.getElementById("hangerUI").appendChild(document.getElementById("moneyDisplay"));
            if (inInventory ? filteredRobots[currentIndex - 1] : mothershipData[currentIndex - 1]) {
                currentIndex--;
                drawMothershipEquip(inInventory ? filteredRobots : mothershipData.sort((a, b) => a.tier - b.tier), currentIndex, inInventory);
                if (inInventory ? filteredRobots[currentIndex - 1] : mothershipData[currentIndex - 1]) {
                    this.style.display = "block";
                } else {
                    this.style.display = "none";
                }
                if (inInventory ? filteredRobots[currentIndex + 1] : mothershipData[currentIndex + 1]) {
                    document.getElementById("goToNext").style.display = "block";
                } else {
                    document.getElementById("goToNext").style.display = "none";
                }
            }
        }
        document.getElementById("goToPre").onmouseover = function () {
            this.style.backgroundColor = "rgb(255, 255, 255, .45)";
            document.getElementById("goToPreCon").style.color = "#000";
        }
        document.getElementById("goToPre").onmouseout = function () {
            this.style.backgroundColor = "rgb(0, 0, 0, 0.3)";
            document.getElementById("goToPreCon").style.color = "#fff";
        }
        saveGameData();
    }
    function updateMothershipDisplay() {
        let adjusted = window.innerWidth - 200;
        let adjustedH = (adjusted / 4) * 2;
        if (document.getElementById("mothershipDisplayyy")) {
            document.getElementById("mothershipDisplayyy").remove();
        }
        let element = document.createElement('div');
        element.id = "mothershipDisplayyy";
        element.style = `
        position: absolute;
        top: ${(window.innerHeight / 2) - (adjustedH / 2)}px;
        left: 100px;
        width: ${adjusted}px;
        border-radius: 12px;
        overflow: hidden;
        height: ${adjustedH}px;
        background-color: rgb(135, 135, 135, 0.8);
        `;
        document.body.append(element);
        let mothership = player.motherships.find(e => e.using);
        if (mothership) {
            element.style.cursor = "pointer";
            element.innerHTML = `
            <div style="position: absolute; font-size: 40px; cursor: pointer; color: #fff; bottom: 5px; right: 10px; text-align: right;">
            Lvl ${mothership.level} ${mothership.name}
            </div>
            `;
            for (let t = 0; t < mothership.turrets.length; t++) {
                let tmpImage = getModuleIcon(mothership.turrets[t], true);
                tmpImage.style = `position: absolute; bottom: ${50 + (80 * (t >= 4 ? t - 4 : t))}px; right: ${t >= 4 ? 85 : 10}px; width: 75px; height: 75px;`;
                element.appendChild(tmpImage);
            }
            let image = getMothershipImage(mothership);
            image.style = `height: ${adjustedH}px;`;
            element.append(image);
            element.onclick = function () {
                customizeMothership(mothership);
            };
        } else {
            element.innerHTML = `
            <div style="position: absolute; font-size: 40px; cursor: pointer; color: #fff; display: flex; justify-content: center; align-items: center; top 0px; left: 0px; width: 100%; height: 100%;">
            Equip Mothership
            </div>
            `;
            element.onclick = function () {
                equipMothership();
            };
        }
    }
    document.getElementById("mothershipToggle").onclick = function () {
        document.getElementById("hangerUI").style.display = "none";
        updateMothershipDisplay();
    }
    function saveGameData() {
        saveValue("settingToggles", JSON.stringify(settingToggles));
        saveValue("hasSaved", 1);
        saveValue("parts", JSON.stringify(player.parts));
        saveValue("exterminationIndx", player.exterminationIndx);
        let shapes = [];
        for (let i = 0; i < player.shapes.length; i++) {
            let shape = player.shapes[i];
            if (!shape.isSold) shapes.push({
                name: shape.name,
                sid: shape.sid,
                level: shape.level,
                slot: shape.slot,
                activeModuleIndex: shape.activeModuleIndex || 0
            });
        }
        let weapons = [];
        for (let i = 0; i < player.weapons.length; i++) {
            let weapon = player.weapons[i];
            if (!weapon.isSold) weapons.push({
                name: weapon.name,
                owner: weapon.owner,
                slot: weapon.slot,
                level: weapon.level
            });
        }
        let modules = [];
        for (let i = 0; i < player.modules.length; i++) {
            let MODLUE = player.modules[i];
            if (!MODLUE.isSold) modules.push({
                name: MODLUE.name,
                owner: MODLUE.owner,
                slot: MODLUE.slot,
                level: MODLUE.level
            });
        }
        let drones = [];
        for (let i = 0; i < player.drones.length; i++) {
            let MODLUE = player.drones[i];
            drones.push({
                name: MODLUE.name,
                owner: MODLUE.owner,
                level: MODLUE.level
            });
        }
        let pilots = [];
        for (let i = 0; i < player.pilots.length; i++) {
            let pilot = player.pilots[i];
            let skills = [];
            pilot.skills.forEach(e => {
                if (!e.legendary) {
                    skills.push({
                        name: e.name,
                        level: e.level,
                        robotOwner: e.robotOwner,
                        slot: e.slot
                    });
                }
            });
            pilots.push({
                name: pilot.name,
                owner: pilot.owner,
                level: pilot.level,
                skills: skills
            });
        }
        let motherships = [];
        for (let i = 0; i < player.motherships.length; i++) {
            let mothership = player.motherships[i];
            let turrets = [];
            mothership.turrets.forEach(e => {
                turrets.push({
                    name: e.name,
                    slot: e.slot
                });
            });
            motherships.push({
                name: mothership.name,
                using: mothership.using,
                level: mothership.level,
                skills: turrets
            });
        }
        saveValue("lootboxSpecialPrize", JSON.stringify(player.lootboxSpecialPrize));
        saveValue("pilots", JSON.stringify(pilots));
        saveValue("profile", JSON.stringify(player.profile));
        saveValue("tokens", JSON.stringify(player.tokens));
        saveValue("slotData", JSON.stringify(slotData));
        saveValue("shapes", JSON.stringify(shapes));
        saveValue("motherships", JSON.stringify(motherships));
        saveValue("drones", JSON.stringify(drones));
        saveValue("weapons", JSON.stringify(weapons));
        saveValue("modules", JSON.stringify(modules));
        saveValue("ULIMATEXP", player.ULIMATEXP);
        saveValue("league", player.league);
        saveValue("league2", player.league2);
        saveValue("keys", player.keys);
        saveValue("sliver", player.sliver);
        saveValue("gold", player.gold);
        saveValue("workshopPoints", player.workshopPoints);
        saveValue("operationData", JSON.stringify(operationData));
        saveValue("workshopQueue", JSON.stringify(workshopQueue));
    }
    setTimeout(() => {
        if (getValue("hasSaved") == 1) {
            player.shapes = [];
            player.weapons = [];
            player.modules = [];
            player.drones = [];
            player.pilots = [];
            if (getValue("exterminationIndx")) {
                player.exterminationIndx = parseInt(getValue("exterminationIndx"));
            }
            if (getValue("settingToggles")) {
                let data = JSON.parse(getValue("settingToggles"));
                for (let i in data) {
                    settingToggles[i] = data[i];
                }
            }
            if (getValue("profile")) {
                player.profile = JSON.parse(getValue("profile"));
            }
            if (getValue("lootboxSpecialPrize") && getValue("lootboxSpecialPrize") != "undefined") {
                player.lootboxSpecialPrize = JSON.parse(getValue("lootboxSpecialPrize"));
            }
            let ShapeData = JSON.parse(getValue("shapes"));
            if (ShapeData.length < 0) {
                saveValue("hasSaved", undefined);
                return;
            }
            let WeaponData = JSON.parse(getValue("weapons"));
            let ModuleData = JSON.parse(getValue("modules"));
            let DronesData = JSON.parse(getValue("drones")) || [];
            let PilotsData = JSON.parse(getValue("pilots")) || [];
            let MothershipData = JSON.parse(getValue("motherships")) || [];
            if (getValue("parts")) {
                let parts = getValue("parts");
                player.parts = JSON.parse(parts);
            }
            for (let i = 0; i < ShapeData.length; i++) {
                let data = ShapeData[i];
                if (data) {
                    try {
                        let Shape = shapeData.find(e => data.name == e.name);
                        let newShape = new shape(Shape, data.slot);
                        newShape.slot = data.slot;
                        if (data.slot) {
                            slotData[data.slot].unlocked = true;
                            slotData[data.slot].used = true;
                        }
                        if (activeModuleData[data.activeModuleIndex]) {
                            newShape.activeModuleIndex = data.activeModuleIndex;
                        } else {
                            newShape.activeModuleIndex = 0;
                        }
                        newShape.sid = data.sid;
                        if (newShape.sid == undefined || newShape.sid == null) {
                            newShape.sid = "get anew";
                        }
                        for (let t = 0; t < Math.min((Shape.titan ? 25 : 14), data.level) - 1; t++) {
                            upgradeShape(newShape, true);
                        }
                        player.shapes.push(newShape);
                    } catch (e) {
                    }
                }
            }
            let largestSid = (player.shapes.filter(e => e.sid >= 0).sort((a, b) => b.sid - a.sid)[0]?.sid || 0) + 1;
            player.shapes.filter(e => e.sid == "get anew").forEach(e => {
                e.sid = largestSid;
                largestSid++;
            });
            player.shapes.forEach(item => {
                if (player.shapes.find(e => e.sid == item.sid && e != item)) {
                    item.sid = largestSid;
                    largestSid++;
                }
            });
            shapeSids = largestSid;
            for (let i = 0; i < WeaponData.length; i++) {
                let data = WeaponData[i];
                if (data) {
                    let Weapon = weaponData.find(e => data.name == e.name);
                    let newWeapon = new weapon(Weapon, data.owner, data.slot);
                    let shapeSid = player.shapes.find(e => e.sid == data.owner);
                    if (!shapeSid) {
                        newWeapon.owner = null;
                        newWeapon.slot = null;
                    }
                    for (let t = 0; t < Math.min((Weapon.titan ? 25 : 14), data.level) - 1; t++) {
                        upgradeWeapon(newWeapon, null, null, true);
                    }
                    player.weapons.push(newWeapon);
                }
            }
            for (let i = 0; i < ModuleData.length; i++) {
                let data = ModuleData[i];
                if (data) {
                    let Module = moduleData.find(e => data.name == e.name);
                    if (Module && Module.name != "Arc Reactor") {
                        let newModule = new module(Module, data.owner, data.slot);
                        let shapeSid = player.shapes.find(e => e.sid == data.owner);
                        if (!shapeSid) {
                            newModule.owner = null;
                            newModule.slot = null;
                        }
                        for (let t = 0; t < data.level - 1; t++) {
                            upgradeModule(newModule, null, null, true);
                        }
                        player.modules.push(newModule);
                    }
                }
            }
            for (let i = 0; i < DronesData.length; i++) {
                let data = DronesData[i];
                if (data) {
                    let Module = dronesData.find(e => data.name == e.name);
                    if (Module) {
                        let newModule = new drone(Module, data.owner);
                        let shapeSid = player.shapes.find(e => e.sid == data.owner);
                        if (!shapeSid) {
                            newModule.owner = null;
                            newModule.slot = null;
                        }
                        for (let t = 0; t < data.level - 1; t++) {
                            upgradeDrone(newModule, null, null, true);
                        }
                        player.drones.push(newModule);
                    }
                }
            }
            for (let i = 0; i < PilotsData.length; i++) {
                let data = PilotsData[i];
                if (data) {
                    let Pilot = pilotsData.find(e => data.name == e.name);
                    if (Pilot) {
                        let thePilot = new pilot(Pilot, data.owner);
                        let shapeSid = player.shapes.find(e => e.sid == data.owner);
                        if (!shapeSid) {
                            thePilot.owner = null;
                        }
                        thePilot.level = data.level;
                        data.skills.forEach(e => {
                            let Skill = pilotSkillList.find(_ => _.name == e.name);
                            if (Skill) {
                                let theSkill = new skill(Skill, e.slot, {
                                    name: e.robotOwner
                                });
                                if (!theSkill.getAbilityBackAtHalfHealth) {
                                    for (let t = 0; t < e.level - 1; t++) {
                                        upgradePilotSkill(theSkill);
                                    }
                                }
                                thePilot.skills.push(theSkill);
                            }
                        });
                        player.pilots.push(thePilot);
                    }
                }
            }
            for (let i = 0; i < MothershipData.length; i++) {
                let data = MothershipData[i];
                if (data) {
                    let Mothership = mothershipData.find(e => data.name == e.name);
                    if (Mothership) {
                        let thePilot = new mothership(Mothership, data.using);
                        for (let i = 0; i < data.level - 1; i++) {
                            upgradeMothership(thePilot)
                        }
                        data.skills.forEach(e => {
                            let Skill = turretsData.find(_ => _.name == e.name);
                            if (Skill) {
                                let index = thePilot.turrets.length;
                                thePilot.turrets.push({ ...Skill });
                                thePilot.turrets[index].slot = e.slot;
                            }
                        });
                        player.motherships.push(thePilot);
                    }
                }
            }
            player.shapes.forEach(item => {
                let weapons = player.weapons.filter(e => item.sid == e.owner);
                let heavy = weapons.filter(e => e.type == "Heavy");
                let light = weapons.filter(e => e.type == "Light");
                if (heavy.length > item.hardpoints.heavy || light.length > item.hardpoints.light) {
                    weapons.forEach(e => {
                        e.owner = null;
                        e.slot = null;
                    });
                }
                let modules = player.modules.filter(e => item.sid == e.owner);
                if (modules.length > item.moduleHardpoints) {
                    modules.forEach(e => {
                        e.slot = null;
                        e.owner = null;
                    });
                }//PilotsData
                let drones = player.drones.filter(e => item.sid == e.owner);
                if (drones.length > 1) {
                    drones.forEach(e => {
                        e.slot = null;
                        e.owner = null;
                    });
                }
                let pilots = player.pilots.filter(e => item.sid == e.owner);
                if (pilots.length > 1) {
                    pilots.forEach(e => {
                        e.owner = null;
                    });
                }
            });
            if (getValue("workshopPoints")) {
                player.workshopPoints = parseInt(getValue("workshopPoints"));
            } else {
                player.workshopPoints = 0;
            }
            let slotdata = JSON.parse(getValue("slotData"));
            if (slotdata) {
                slotData = [...slotdata];
                if (slotData.length < 9) {
                    slotData.push({
                        unlocked: true,
                        used: false,
                        cost: Infinity
                    });
                }
            }
            if (getValue("ULIMATEXP")) {
                player.ULIMATEXP = parseInt(getValue("ULIMATEXP"));
            } else {
                player.ULIMATEXP = 0;
            }
            if (getValue("league2")) {
                player.league2 = parseInt(getValue("league2"));
            } else {
                player.league2 = 0;
            }
            if (getValue("league")) {
                player.league = parseInt(getValue("league"));
            } else {
                player.league = 0;
            }
            if (getValue("workshopQueue")) {
                workshopQueue = JSON.parse(getValue("workshopQueue"));
            }
            if (getValue("tokens")) {
                player.tokens = JSON.parse(getValue("tokens"));
            }
            if (getValue("operationData")) {
                operationData = JSON.parse(getValue("operationData"));
            }
            player.keys = parseInt(getValue("keys"));
            player.sliver = parseInt(getValue("sliver"));
            player.gold = parseInt(getValue("gold"));
            updateMoneyDisplay();
            setUpUIStuffThing();
            setTimeout(() => {
                updateSlots();
                document.getElementById("LOADING SCREEN XD").style.display = "none";
            }, 100)
        } else {
            document.getElementById("LOADING SCREEN XD").style.display = "none";
            updateSlots();
        }
        resize();
    }, 250);
    var offset = {
        x: 0,
        y: 0
    }
    function renderBackground(delta) {
        let cam;
        if (players[0].robotIndex == -1) {
            cam = {
                x: mapInfo.x / 2,
                y: mapInfo.y / 2
            };
        } else {
            cam = {
                x: players[0].robots[players[0].robotIndex].x,
                y: players[0].robots[players[0].robotIndex].y
            };
        }
        let map = mapInfoData.find(e => e.id == player.mapID);
        if (map) {
            if (map.name == "Space Shuttle") {
                ctx.fillStyle = "#909090";
            } else if (map.name == "Rome" || map.name == "Training Grounds") {
                ctx.fillStyle = "#0f0";
            } else if (map.name == "Lost Forest") {
                ctx.fillStyle = "#2e8b57";
            } else {
                ctx.fillStyle = "#000";
            }
        } else {
            ctx.fillStyle = "#0f0";
        }
        ctx.fillRect(0, 0, maxScreen.x, maxScreen.y);
        renderBuildings(delta, true);
        ctx.lineWidth = 8;
        ctx.strokeStyle = map && map.name == "Void" ? "#fff" : "#000";
        ctx.globalAlpha = map && map.name == "Void" ? .5 : 0.06;
        ctx.beginPath();
        for (var x = -cam.x; x < maxScreen.x; x += maxScreen.y / 4) {
            if (x > 0) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, maxScreen.y);
            }
        }
        for (var y = -cam.y; y < maxScreen.y; y += maxScreen.y / 4) {
            if (x > 0) {
                ctx.moveTo(0, y);
                ctx.lineTo(maxScreen.x, y);
            }
        }
        ctx.stroke();
        if (map) {
            if (map.name == "Lost Forest") {
                ctx.fillStyle = "#000";
                ctx.globalAlpha = 0.36;
            } else {
                if (map.id != 1) {
                    ctx.fillStyle = "#000";
                } else {
                    ctx.fillStyle = "#fff";
                }
                ctx.globalAlpha = 1;
            }
        } else {
            ctx.fillStyle = "#000";
            ctx.globalAlpha = 0.18;
        }
        if (offset.x <= 0) {
            ctx.fillRect(0, 0, -offset.x, maxScreen.y);
        } if (mapInfo.x - offset.x <= maxScreen.x) {
            var tmpY = Math.max(0, -offset.y);
            ctx.fillRect(mapInfo.x - offset.x, tmpY, maxScreen.x - (mapInfo.x - offset.x), maxScreen.y - tmpY);
        } if (offset.y <= 0) {
            ctx.fillRect(-offset.x, 0, maxScreen.x + offset.x, -offset.y);
        } if (mapInfo.y - offset.y <= maxScreen.y) {
            var tmpX = Math.max(0, -offset.x);
            var tmpMin = 0;
            if (mapInfo.x - offset.x <= maxScreen.x) tmpMin = maxScreen.x - (mapInfo.x - offset.x);
            ctx.fillRect(tmpX, mapInfo.y - offset.y, (maxScreen.x - tmpX) - tmpMin, maxScreen.y - (mapInfo.y - offset.y));
        }
    }
    var mouseX = 0;
    var mouseY = 0;
    canvas.addEventListener('mousemove', gameInput, false);
    function gameInput(e) {
        e.preventDefault();
        e.stopPropagation();
        mouseX = e.clientX;
        mouseY = e.clientY;
    }
    function renderPhysicalShields(robot, delta, ctx) {
        if (robot.invis) return;
        ctx.globalAlpha = 1;
        let physicals = robot.shields.filter(e => e.type == "normal" || e.type == "purple normal");
        for (let i = 0; i < physicals.length; i++) {
            let shield = physicals[i];
            if (shield) {
                if (shield.globalAlpha == null) shield.globalAlpha = 0;
                shield.globalAlpha = Math.min(shield.globalAlpha + 0.0015 * delta, 1);
                ctx.save();
                ctx.globalAlpha = shield.globalAlpha;
                ctx.rotate(shield.dir - (shield.angleDist / 2));
                ctx.rotate(robot.dir);
                ctx.lineWidth = 12;
                let healthPercentage = shield.health / shield.maxhealth;
                let redValue = Math.floor(128 + 127 * (1 - healthPercentage));
                let otherValues = Math.floor(128 - 127 * (1 - healthPercentage));
                ctx.strokeStyle = shield.type == "purple normal" ? "#800080" : `rgb(${redValue}, ${otherValues}, ${otherValues})`;
                ctx.beginPath();
                ctx.arc(0, 0, robot.scale + 20, 0, shield.angleDist * (shield.barrierField ? 1 : .85));
                ctx.stroke();
                ctx.restore();
            }
        }
    }
    function renderDrone(ctx, parent, drones, delta) {
        for (let i = 0; i < drones.length; i++) {
            let drone = drones[i];

            ctx.save();
            if (drone.visualData.dir == null) drone.visualData.dir = i * (Math.PI * 2 / drones.length);
            let r = (parent.scale + drone.visualData.scale + 40);
            let addon = (delta * .75) / r;
            if (parent.isMe && keysPressed[82]) {
                addon *= 2;
            } else if (parent.shields.find(e => e.droneShield)) {
                addon *= 2;
            }
            let addom = 1;
            for (let i = 0; i < drone.effects.length; i++) {
                let data = drone.effects[i];
                if (data) {
                    data.lastTime -= delta;
                    if (data.name == "speed") {
                        addom += data.amount;
                    }
                    if (data.lastTime <= 0 || !data.lastTime) {
                        drone.effects.splice(i, 1);
                    }
                }
            }
            addon *= addom;
            drone.visualData.dir += addon;
            let tmp = {
                x: Math.cos(drone.visualData.dir) * r,
                y: Math.sin(drone.visualData.dir) * r
            };
            drone.visualData.addOnCoord = tmp;
            ctx.translate(tmp.x, tmp.y);
            if (drone.visualData.dir2 != null && drone.visualData.dir2 != undefined) {
                ctx.rotate(drone.visualData.dir2);
                ctx.rotate(-drone.visualData.dir2);
            }
            renderShapeBody(ctx, drone.visualData, 6);
            ctx.restore();
        }
    }
    function interpolateColor(startColor, endColor, percent) {
        let startRGB = hexToRgb(startColor);
        let endRGB = hexToRgb(endColor);
        let r = Math.round(startRGB.r + (endRGB.r - startRGB.r) * percent);
        let g = Math.round(startRGB.g + (endRGB.g - startRGB.g) * percent);
        let b = Math.round(startRGB.b + (endRGB.b - startRGB.b) * percent);
        return rgbToHex(r, g, b);
    }
    function hexToRgb(hex) {
        let bigint = parseInt(hex.slice(1), 16);
        let r = (bigint >> 16) & 255;
        let g = (bigint >> 8) & 255;
        let b = bigint & 255;
        return { r, g, b };
    }
    function rgbToHex(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    function renderShapeBody(ctx, robot, w) {
        if (w == undefined && !robot.name.includes("Circle")) w = 12;
        let asd = Math.random() * 360;
        if (robot.effects && robot.effects.find(e => e.name == "reflector") && settingToggles.renderReflector) {
            ctx.rotate(asd);
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 16;
            renderStar(ctx, 5, robot.scale + 15, robot.scale + 15);
            ctx.stroke();
            ctx.rotate(asd);
            ctx.strokeStyle = "#00f";
            ctx.lineWidth = 16;
            renderStar(ctx, 4, robot.scale + 10, robot.scale + 10);
            ctx.stroke();
            ctx.rotate(-asd * 2);
        }

        if (robot.effects && robot.effects.find(e => e.name == "dark light")) {
            renderCircle(0, 0, 1200, ctx, false, true, "#fff", "#000", 30);
        }

        if (robot.tracers) {
            ctx.save();
            for (let i = 0; i < robot.tracers.length; i++) {
                let pre = robot.tracers[i - 1];
                let first = robot.tracers[i];
                let next = robot.tracers[i + 1];
                ctx.beginPath();
                ctx.lineWidth = i;
                ctx.strokeStyle = `rgb(255, 255, 0, ${i / robot.tracers.length})`;
                if (pre) {
                    ctx.lineTo(pre.x - robot.x, pre.y - robot.y);
                }
                ctx.lineTo(first.x - robot.x, first.y - robot.y);
                if (next) {
                    ctx.lineTo(next.x - robot.x, next.y - robot.y);
                } else {
                    ctx.lineTo(0, 0);
                }
                ctx.stroke();
            }
            ctx.restore();
        }
        let dir = robot.dir2 || robot.dir;
        if (!robot.industryName) robot.industryName = "";
        if (robot.name.includes("Circle") || robot.industryName.includes("Circle")) {
            if (robot.effects) {
                let force = robot.effects.find(e => e.name == "forcefield");
                if (force) {
                    let percent = 1 - (force.data.health / force.data.maxhealth);
                    let startColor = "#00ffff";
                    let endColor = "#ff0000";
                    let interpolatedColor = interpolateColor(startColor, endColor, percent);
                    renderCircle(0, 0, robot.scale + 5, ctx, false, true, "#fff", interpolatedColor, 15);
                }
            }
            let color = robot.lockdown ? "#800080" : robot.isFREEZE ? "#fff" : robot.borderColor || "#000";
            renderCircle(0, 0, robot.scale, ctx, false, false, robot.color, color, w);
            if (robot.name == "Ultimate Green Circle") {
                renderCircle(0, 0, 600, ctx, false, true, "#fff", "#06a600", 20);
            }
        } else if (robot.name.includes("Pentagon") || robot.industryName.includes("Pentagon")) {
            ctx.rotate(dir + Math.PI / 2);
            if (robot.effects) {
                let force = robot.effects.find(e => e.name == "forcefield");
                if (force) {
                    let percent = 1 - (force.data.health / force.data.maxhealth);
                    let startColor = "#00ffff";
                    let endColor = "#ff0000";
                    let interpolatedColor = interpolateColor(startColor, endColor, percent);
                    ctx.strokeStyle = interpolatedColor;
                    ctx.lineWidth = 15;
                    renderStar(ctx, 2.5, robot.scale + 10, robot.scale + 10);
                    ctx.stroke();
                }
            }
            ctx.strokeStyle = robot.lockdown ? "#800080" : robot.isFREEZE ? "#fff" : (robot.borderColor || "#000");
            ctx.lineWidth = robot.name == "Gray Pentagon" ? 18 : w;
            ctx.fillStyle = robot.color;
            renderStar(ctx, 2.5, robot.scale, robot.scale);
            ctx.stroke();
            ctx.fill();
            ctx.rotate(-(dir + Math.PI / 2));
        } else if (robot.name.includes("Hexagon") || robot.industryName.includes("Hexagon")) {
            ctx.rotate(dir + Math.PI / 2);
            ctx.strokeStyle = robot.lockdown ? "#800080" : robot.isFREEZE ? "#fff" : (robot.borderColor || "#000");
            ctx.lineWidth = robot.effects.filter(e => e.name == "Blink Support").length ? w * (robot.effects.filter(e => e.name == "Blink Support").length + 1) : w;
            ctx.fillStyle = robot.color;
            renderStar(ctx, 3, robot.scale, robot.scale);
            ctx.stroke();
            ctx.fill();
            ctx.rotate(-(dir + Math.PI / 2));
        } else if (robot.name.includes("Heptagon") || robot.industryName.includes("Heptagon")) {
            ctx.rotate(dir + Math.PI / 2);
            if (robot.effects) {
                let force = robot.effects.find(e => e.name == "forcefield");
                if (force) {
                    let percent = 1 - (force.data.health / force.data.maxhealth);
                    let startColor = "#00ffff";
                    let endColor = "#ff0000";
                    let interpolatedColor = interpolateColor(startColor, endColor, percent);
                    ctx.strokeStyle = interpolatedColor;
                    ctx.lineWidth = 15;
                    renderStar(ctx, 3.5, robot.scale + 10, robot.scale + 10);
                    ctx.stroke();
                }
            }
            ctx.strokeStyle = robot.lockdown ? "#800080" : robot.isFREEZE ? "#fff" : "#000";
            ctx.lineWidth = w;
            ctx.fillStyle = robot.color;
            renderStar(ctx, 3.5, robot.scale, robot.scale);
            ctx.stroke();
            ctx.fill();
            ctx.rotate(-(dir + Math.PI / 2));
        } else if (robot.name.includes("Triangle") || robot.industryName.includes("Triangle")) {
            ctx.rotate(dir + Math.PI / 2);
            if (robot.effects) {
                let force = robot.effects.find(e => e.name == "forcefield");
                if (force) {
                    let percent = 1 - (force.data.health / force.data.maxhealth);
                    let startColor = "#00ffff";
                    let endColor = "#ff0000";
                    let interpolatedColor = interpolateColor(startColor, endColor, percent);
                    ctx.strokeStyle = interpolatedColor;
                    ctx.lineWidth = 15;
                    renderStar(ctx, 1.5, robot.scale + 10, robot.scale + 10);
                    ctx.stroke();
                }
            }
            ctx.strokeStyle = robot.lockdown ? "#800080" : robot.isFREEZE ? "#fff" : (robot.borderColor || "#000");
            ctx.lineWidth = w;
            ctx.fillStyle = robot.color;
            renderStar(ctx, 1.5, robot.scale, robot.scale);
            ctx.stroke();
            ctx.fill();
            ctx.rotate(-(dir + Math.PI / 2));
        } else if (robot.name.includes("Octagon") || robot.industryName.includes("Octagon")) {
            ctx.rotate(dir + Math.PI / 2);
            if (robot.effects) {
                let force = robot.effects.find(e => e.name == "forcefield");
                if (force) {
                    let percent = 1 - (force.data.health / force.data.maxhealth);
                    let startColor = "#00ffff";
                    let endColor = "#ff0000";
                    let interpolatedColor = interpolateColor(startColor, endColor, percent);
                    ctx.strokeStyle = interpolatedColor;
                    ctx.lineWidth = 15;
                    renderStar(ctx, 4, robot.scale + 10, robot.scale + 10);
                    ctx.stroke();
                }
            }
            ctx.strokeStyle = robot.lockdown ? "#800080" : robot.isFREEZE ? "#fff" : "#000";
            ctx.lineWidth = w;
            ctx.fillStyle = robot.color;
            renderStar(ctx, 4, robot.scale, robot.scale);
            ctx.stroke();
            ctx.fill();
            ctx.rotate(-(dir + Math.PI / 2));
        } else if (robot.name == "Polygon") {
            renderCircle(0, 0, robot.scale, ctx, false, false, "#e9e9e9", "#000");
            if (robot.polygonTurning1 == null) robot.polygonTurning1 = 0;
            robot.polygonTurning1 += 0.015;
            ctx.rotate(dir + (Math.PI / 2) + robot.polygonTurning1);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 12;
            ctx.fillStyle = "#ffb400";
            renderStar(ctx, 3.5, robot.scale * .7, robot.scale * .7);
            ctx.stroke();
            ctx.fill();
            ctx.rotate(-(dir + (Math.PI / 2) + robot.polygonTurning1));
            ctx.rotate(dir + (Math.PI / 2) - robot.polygonTurning1);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 12;
            ctx.fillStyle = "#ffff00";
            renderStar(ctx, 2.5, robot.scale * .4, robot.scale * .4);
            ctx.stroke();
            ctx.fill();
            if (robot.effects) {
                let force = robot.effects.find(e => e.name == "forcefield");
                if (force) {
                    let percent = 1 - (force.data.health / force.data.maxhealth);
                    let startColor = "#00ffff";
                    let endColor = "#ff0000";
                    let interpolatedColor = interpolateColor(startColor, endColor, percent);
                    renderCircle(0, 0, robot.scale + 25, ctx, false, true, "#fff", interpolatedColor, 15);
                }
            }
        } else if (robot.name.includes("Square") || robot.industryName.includes("Square")) {
            ctx.rotate(dir + Math.PI / 2);
            ctx.strokeStyle = robot.lockdown ? "#800080" : robot.isFREEZE ? "#fff" : (robot.borderColor || "#000");
            ctx.lineWidth = w;
            ctx.fillStyle = robot.color;
            renderStar(ctx, 2, robot.scale, robot.scale);
            ctx.stroke();
            ctx.fill();
            ctx.rotate(-(dir + Math.PI / 2));
        }
        if (robot.effects && robot.effects.find(e => e.name == "stove")) {
            renderCircle(0, 0, 800, ctx, false, true, "#000", "#f00", 12);
        }
    }
    function doBondStuff(bond, delta, i, robot) {
        bond.duration -= delta;
        if (bond.duration <= 0) {
            if (bond.name == "Lasso") {
                let amount = bond.target.maxhealth * .1;
                changeHealth(bond.target, {
                    amount: -amount,
                    damageTypeName: "Lasso",
                    graydmg: 0
                }, false, robot, true);
                let healing = amount * 2;
                robot.grayDamage = Math.max(0, robot.grayDamage - (healing * .2));
                changeHealth(robot, {
                    amount: healing
                }, false, robot);
            } else if (bond.name == "Active Support") {
                if (bond.target.activeSupportIncreaseHealthHAHAHAHA == null) {
                    bond.target.activeSupportIncreaseHealthHAHAHAHA = bond.target.normalMaxHealth * .1;
                }
                bond.target.health += bond.target.activeSupportIncreaseHealthHAHAHAHA;
                bond.target.normalMaxHealth += bond.target.activeSupportIncreaseHealthHAHAHAHA;
                bond.target.maxhealth += bond.target.activeSupportIncreaseHealthHAHAHAHA;
            }
            robot.bonds.splice(i, 1);
        }
    }
    function renderPlayer(delta) {
        let player = players.find(e => e.name == "player");
        let weaponNames = {};
        if (player.robotIndex >= 0) {
            let robot = player.robots[player.robotIndex];
            robot.dir = Math.atan2(mouseY - (innerHeight / 2), mouseX - (innerWidth / 2));
            if (robot.health > 0) {
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.translate(robot.x - offset.x, robot.y - offset.y);
                if (settingToggles.renderWeaponRange) {
                    for (let i = 0; i < robot.weapons.length; i++) {
                        let weapon = robot.weapons[i];
                        if (!weaponNames[weapon.name]) {
                            weaponNames[weapon.name] = weapon.range;
                        }
                    }
                    let weaponArray = [];
                    for (let weaponName in weaponNames) {
                        if (weaponName != "Cinder") {
                            weaponArray.push({ name: weaponName, range: weaponNames[weaponName] });
                        }
                    }
                    weaponArray.sort((a, b) => b.range - a.range);
                    for (let i = 0; i < weaponArray.length; i++) {
                        let weapon = weaponArray[i];
                        let range = weapon.range;
                        let endPointX = range * Math.cos(robot.dir);
                        let endPointY = range * Math.sin(robot.dir);
                        ctx.save();
                        ctx.globalAlpha = 0.2;
                        ctx.lineWidth = 10;
                        ctx.strokeStyle = "#f00";
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(endPointX, endPointY);
                        ctx.stroke();
                        ctx.restore();
                    }
                    let haveAOEWeapon = robot.weapons.find(e => e.name == "Cinder");
                    if (haveAOEWeapon) {
                        renderCircle(0, 0, haveAOEWeapon.range, ctx, false, true, "rgb(255, 0, 0, 0.3)", "rgb(255, 0, 0, 0.6)");
                    }
                }
                if (robot.globalAlpha == null) robot.globalAlpha = 1;
                if (robot.invis) {
                    robot.globalAlpha = Math.max(robot.globalAlpha - (delta * 0.005), 0);
                } else if (robot.effects.find(e => e.name == "phase shift")) {
                    robot.globalAlpha = Math.max(robot.globalAlpha - (delta * 0.0025), 0.4);
                } else {
                    robot.globalAlpha = Math.min(robot.globalAlpha + (delta * 0.0025), 1);
                }
                renderPhysicalShields(robot, delta, ctx);
                ctx.globalAlpha = robot.globalAlpha;
                if (robot.specialOf) {
                    let image = getShapeImage(robot);
                    if (image.isLoaded) {
                        let size = 250;
                        ctx.rotate(robot.dir + Math.PI);
                        ctx.drawImage(image, -(size / 2), -(size / 2), size, size);
                        ctx.rotate(-(robot.dir + Math.PI));
                    }
                } else {
                    renderShapeBody(ctx, robot);
                }
                if (settingToggles.renderDrone_player) {
                    renderDrone(ctx, robot, robot.drones, delta);
                }
                if (robot.bonds) {
                    if (!robot.invis) ctx.globalAlpha = 1;
                    for (let i = 0; i < robot.bonds.length; i++) {
                        let bond = robot.bonds[i];
                        if (bond) {
                            ctx.save();
                            ctx.translate(-(robot.x - offset.x), -(robot.y - offset.y));
                            ctx.lineWidth = bond.name == "Active Support" ? 16 : 32;
                            ctx.strokeStyle = bond.name == "Active Support" ? "rgb(1, 50, 32, .6)" : bond.isAlly ? "rgb(255, 0, 255, .6)" : "rgb(255, 0, 0, .6)";
                            ctx.lineCap = "round";
                            ctx.beginPath();
                            ctx.moveTo(robot.x - offset.x, robot.y - offset.y);
                            ctx.lineTo(bond.target.x - offset.x, bond.target.y - offset.y);
                            ctx.stroke();
                            ctx.restore();
                            doBondStuff(bond, delta, i, robot);
                        }
                    }
                }
                if (robot.effects.find(e => e.name == "track")) {
                    ctx.drawImage(crosshair, -robot.scale, -robot.scale, robot.scale * 2, robot.scale * 2);
                }
                drawCanvasHealthBars(robot, "me", ctx);
                ctx.restore();
                if (settingToggles.renderDrone_player) {
                    let drone = robot.drones[0];
                    if (drone && drone.abilities.find(e => e.name == "Imitating Comet Laser")) {
                        let weapon = drone.abilities.find(e => e.name == "Imitating Comet Laser");
                        if (weapon.droneIsFiring) {
                            let color1 = "rgb(255, 165, 0)";
                            let tmp = drone.visualData.addOnCoord;
                            ctx.save();
                            ctx.lineWidth = 16;
                            ctx.strokeStyle = color1;
                            ctx.beginPath();
                            ctx.moveTo((robot.x + tmp.x) - offset.x, (robot.y + tmp.y) - offset.y);
                            ctx.lineTo(weapon.target.x - offset.x, weapon.target.y - offset.y);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                }
            }
        }
    }
    var enemies = [];
    var projectiles = [];
    function getRandomOffset(offset) {
        let random = Math.randInt(-offset, offset);
        return ((random / 180) * Math.PI);
    }
    function fireWeapon(weapon, shape, isAlly) {
        if ((shape.isMe ? true : shape.target)) {
            let hardpoints = shape.hardpoints.light + shape.hardpoints.heavy;
            let dir = 0;
            let x = 0;
            let y = 0;
            let scale = 0;
            scale = 15;
            if (weapon.name == "Toxin" || weapon.name == "Bane") {
                scale = 30;
            } else if (weapon.name == "Devastator" || weapon.name == "Scatter" || weapon.name == "Disintegrator" || weapon.name == "Havoc" || weapon.name == "Evora" || weapon.name == "Veyron") {
                scale = 25;
            } else if (weapon.name == "Maha Vajra" || weapon.name == "Vajra") {
                scale = 35;
            } else if (weapon.name == "Igniter" || weapon.name == "Discharger" || weapon.name == "Inferno" || weapon.name == "Pyro") {
                scale = 25;
            }
            let hScale = scale / 2;
            if (shape.target && !shape.isMe) {
                shape.dir = Math.atan2(shape.target.y - shape.y, shape.target.x - shape.x);
            }
            if (hardpoints == 1) {
                x = shape.x + Math.cos(shape.dir) * (shape.scale - hScale);
                y = shape.y + Math.sin(shape.dir) * (shape.scale - hScale);
            } else if (hardpoints == 2) {
                if (weapon.slot == 0) {
                    x = shape.x + Math.cos(shape.dir + 1.57) * (shape.scale - hScale);
                    y = shape.y + Math.sin(shape.dir + 1.57) * (shape.scale - hScale);
                } else {
                    x = shape.x + Math.cos(shape.dir - 1.57) * (shape.scale - hScale);
                    y = shape.y + Math.sin(shape.dir - 1.57) * (shape.scale - hScale);
                }
            } else if (hardpoints == 3) {
                if (weapon.slot == 0) {
                    x = shape.x + Math.cos(shape.dir + 1.57) * (shape.scale - hScale);
                    y = shape.y + Math.sin(shape.dir + 1.57) * (shape.scale - hScale);
                } else if (weapon.slot == 1) {
                    x = shape.x + Math.cos(shape.dir) * (shape.scale - hScale);
                    y = shape.y + Math.sin(shape.dir) * (shape.scale - hScale);
                } else {
                    x = shape.x + Math.cos(shape.dir - 1.57) * (shape.scale - hScale);
                    y = shape.y + Math.sin(shape.dir - 1.57) * (shape.scale - hScale);
                }
            } else {
                if (weapon.slot == 0 || weapon.slot == 4) {
                    x = shape.x + Math.cos(shape.dir + 1.57) * (shape.scale - 7.5);
                    y = shape.y + Math.sin(shape.dir + 1.57) * (shape.scale - 7.5);
                } else if (weapon.slot == 1 || weapon.slot == 5) {
                    x = shape.x + Math.cos(shape.dir + 0.39) * (shape.scale - 7.5);
                    y = shape.y + Math.sin(shape.dir + 0.39) * (shape.scale - 7.5);
                } else if (weapon.slot == 2 || weapon.slot == 6) {
                    x = shape.x + Math.cos(shape.dir - 0.39) * (shape.scale - 7.5);
                    y = shape.y + Math.sin(shape.dir - 0.39) * (shape.scale - 7.5);
                } else {
                    x = shape.x + Math.cos(shape.dir - 1.57) * (shape.scale - 7.5);
                    y = shape.y + Math.sin(shape.dir - 1.57) * (shape.scale - 7.5);
                }
            }
            if (!shape.isMe) {
                if (shape.target) {
                    dir = Math.atan2(shape.target.y - y, shape.target.x - x);
                }
            } else {
                let offsetX = x - offset.x;
                let offsetY = y - offset.y;
                let mosX = (mouseX / window.innerWidth) * maxScreen.x;
                let mosY = (mouseY / window.innerHeight) * maxScreen.y;
                dir = Math.atan2(mosY - offsetY, mosX - offsetX);
            }
            //defensePointsBypass: (1 - weapon.defenseBypass),
            if (weapon.name == "Brisant" || weapon.name == "Shatter") {
                projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    splitData: {
                        range: 550,
                        amount: 30,
                        spread: weapon.spread
                    },
                    slowEffect: {
                        name: "slowdown",
                        last: 7e3,
                        power: 0.025
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    color: "./images/bullets/bullet.png",
                    avoidBuildings: shape.avoidBuildings,
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Punisher" || weapon.name == "Ultimate Punisher" || weapon.name == "Retaliator" || weapon.name == "Vengeance") {
                for (let i = 0; i < (weapon.name == "Ultimate Punisher" ? 2 : 1); i++) projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    color: "./images/bullets/bullet.png",
                    avoidBuildings: shape.avoidBuildings,
                    motherShipCharge: weapon.motherShipCharge,
                    defensePointsBypass: (1 - weapon.defenseBypass),
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Sorrow" || weapon.name == "Grief") {
                projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    color: `./images/bullets/${(weapon.firedTime / 2e3) == 1 ? "red_bullet" : "bullet"}.png`,
                    avoidBuildings: shape.avoidBuildings,
                    grayDamageAmount: (weapon.firedTime / 2e3) == 1 ? .8 : undefined,
                    owner: shape,
                    autoTargetData: {
                        type: "nearest",
                        range: 800,
                        better: true
                    },
                    motherShipCharge: weapon.motherShipCharge,

                    changeDirSpeed: 0.045,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Anguisher" || weapon.name == "Ruiner") {
                for (let i = 0; i < 7; i++) projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.35,
                    dmg: weapon.dmg / 7,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    color: `./images/bullets/dot_bullet.png`,
                    avoidBuildings: true,
                    owner: shape,
                    dotEffect: {
                        name: "dot",
                        last: 5e3,
                        dmg: weapon.dotDamage / 7,
                        owner: shape
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    defensePointsBypass: (1 - weapon.defenseBypass),
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Vortex" || weapon.name == "Thermite") {
                for (let i = 0; i < 7; i++) projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.1,
                    dmg: weapon.dmg / 7,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    color: `./images/bullets/rocket.png`,
                    avoidBuildings: true,
                    owner: shape,
                    aoeRange: weapon.aoeRange,
                    autoTargetData: {
                        type: "nearest",
                        range: shape.scale * 2,
                        better: true
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    changeDirSpeed: 0.045,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Talon" || weapon.name == "Jaw") {
                projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    autoTargetData: {
                        type: "nearest",
                        range: shape.scale,
                        better: true
                    },
                    rustEffect: {
                        name: "rust",
                        power: 0.01,
                        last: 10e3
                    },
                    fragEffect: {
                        name: "frag",
                        power: 0.025,
                        last: 10e3
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    changeDirSpeed: 0.05,
                    speed: 0.15,
                    aoeRange: weapon.aoeRange,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    color: `./images/bullets/rocket.png`,
                    avoidBuildings: true,
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Kramola" || weapon.name == "Razdor" || weapon.name == "Discordia" || weapon.name == "Tumultus") {
                for (let i = 0; i < 2; i++) projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    autoTargetData: {
                        type: weapon.name == "Razdor" || weapon.name == "Kramola" ? "cursor" : "nearest",
                        range: weapon.name == "Razdor" || weapon.name == "Kramola" ? 800 : 350,
                        better: true
                    },
                    shadow: {
                        size: 45,
                        color: "#fff",
                        spriteSize: weapon.name == "Razdor" || weapon.name == "Kramola" ? 1.5 : 2.5
                    },
                    defensePointsBypass: (1 - weapon.defenseBypass),
                    changeDirSpeed: weapon.name == "Razdor" || weapon.name == "Kramola" ? 0.13 : 0.09,
                    speed: 0.35,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    color: `./images/bullets/${weapon.firedTime / 2e3 == 1 ? "red_bullet" : "bullet"}.png`,
                    avoidBuildings: shape.avoidBuildings,
                    motherShipCharge: weapon.motherShipCharge,
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Razor" || weapon.name == "Smuta") {
                for (let i = 0; i < 2; i++) projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    autoTargetData: {
                        type: "nearest",
                        range: 550
                    },
                    changeDirSpeed: 0.045,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    motherShipCharge: weapon.motherShipCharge,
                    color: "./images/bullets/bullet.png",
                    avoidBuildings: shape.avoidBuildings,
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Subduer") {
                projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.35,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    rustEffect: {
                        name: "rust",
                        power: 0.0048,
                        last: 6e3
                    },
                    dotEffect: {
                        name: "dot",
                        last: 10e3,
                        dmg: weapon.dotDamage,
                        owner: shape
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    color: "rgb(0, 0, 0)",
                    avoidBuildings: shape.avoidBuildings,
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Trickster" || weapon.name == "Tamer") {
                projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.3,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    rustEffect: {
                        effectID: "tamer",
                        name: "rust",
                        power: 0.034,
                        last: 15e3
                    },
                    motherShipCharge: weapon.motherShipCharge,

                    color: "./images/bullets/orange_bullet.png",
                    avoidBuildings: shape.avoidBuildings,
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Deceiver" || weapon.name == "Damper") {
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    avoidBuildings: shape.avoidBuildings,
                    dotEffect: {
                        name: "dot",
                        last: 15e3,
                        dmg: weapon.dotDamage,
                        owner: shape
                    },
                    motherShipCharge: weapon.motherShipCharge,

                    color: "./images/bullets/red_bullet.png",
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Rime" || weapon.name == "Glacier") {
                projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    projType: weapon.projType,
                    vely: 0,
                    scale: scale,
                    speed: 0.12,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    color: "./images/bullets/white_bullet.png",
                    avoidBuildings: shape.avoidBuildings,
                    aoeRange: weapon.aoeRange,
                    owner: shape,
                    freezeEffect: {
                        name: "freezing",
                        last: weapon.name == "Glacier" ? 7500 : 5e3,
                        power: weapon.name == "Glacier" ? .18 : .09
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level,
                        cold: true
                    }
                });
            } else if (weapon.name == "Orkan" || weapon.name == "Rupture" || weapon.name == "Landslide" || weapon.name == "Avalanche") {
                projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    projType: weapon.projType,
                    vely: 0,
                    scale: scale,
                    speed: 0.15,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    color: "./images/bullets/rocket.png",
                    avoidBuildings: shape.avoidBuildings,
                    aoeRange: weapon.aoeRange,
                    owner: shape,
                    motherShipCharge: weapon.motherShipCharge,
                    defensePointsBypass: (1 - weapon.defenseBypass),
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Scald" || weapon.name == "Incinerator") {
                projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    projType: weapon.projType,
                    vely: 0,
                    scale: scale,
                    speed: 0.15,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    color: "./images/bullets/red_bullet.png",
                    avoidBuildings: shape.avoidBuildings,
                    blastEffect: {
                        name: "blast",
                        last: 5e3,
                        power: weapon.effectIncrease
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    aoeRange: weapon.aoeRange,
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Labrys" || weapon.name == "Cestus") {
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    avoidBuildings: shape.avoidBuildings,
                    speed: 0.3,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    aoeRange: weapon.aoeRange,
                    dir: dir,
                    isAlly: isAlly,
                    color: `#ffff00`,
                    owner: shape,
                    blastEffect: {
                        name: "blast",
                        last: 10e3,
                        power: weapon.effectIncrease
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Slumber" || weapon.name == "Delay") {
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    avoidBuildings: shape.avoidBuildings,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.35,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    slowEffect: {
                        name: "slowdown",
                        last: 5e3,
                        power: 0.0043
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    color: "./images/bullets/purple_bullet.png",
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Lance" || weapon.name == "Glaive") {
                let multi = 1;
                let thing = weapon.ammoFired % 4;
                if (thing == 0) {
                    multi = 1;
                } else if (thing == 1) {
                    multi = 1.5;
                } else if (thing == 2) {
                    multi = 2;
                } else {
                    multi = 2.5;
                }
                weapon.ammoFired++;
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    avoidBuildings: shape.avoidBuildings,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: .2,
                    dmg: weapon.dmg * multi,
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    color: "./images/bullets/energy_bullet.png",
                    owner: shape,
                    motherShipCharge: weapon.motherShipCharge,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Blight" || weapon.name == "Decay") {
                let ammoFired = weapon.ammoFired;
                let index = Math.floor(ammoFired / 3) % 3;
                let dmgMulti = [1, 2, 3];
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    avoidBuildings: shape.avoidBuildings,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale * dmgMulti[index],
                    speed: .25,
                    dmg: weapon.dmg * dmgMulti[index],
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    color: index == 2 ? "#f00" : index == 1 ? "#ffff00" : "#0f0",
                    owner: shape,
                    motherShipCharge: weapon.motherShipCharge,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Shocker" || weapon.name == "Reaper" || weapon.name == "Vendicatore" || weapon.name == "Volt" || weapon.name == "Gauss") {
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    avoidBuildings: weapon.name == "Vendicatore" ? true : shape.avoidBuildings,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: .4,
                    dmg: weapon.dmg * (weapon.chargingMechanic ? (weapon.ammo / weapon.maxammo) : 1),
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    color: "./images/bullets/bullet.png",
                    owner: shape,
                    motherShipCharge: weapon.motherShipCharge,
                    bypassReflector: weapon.name == "Reaper" ? true : false,
                    defensePointsBypass: weapon.name == "Vendicatore" ? 0 : weapon.name == "Reaper" ? 0 : undefined,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Bane" || weapon.name == "Toxin") {
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    avoidBuildings: shape.avoidBuildings,
                    speed: 0.2,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    dotEffect: {
                        name: "dot",
                        last: 4e3,
                        dmg: weapon.dotDamage,
                        owner: shape
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    color: "./images/bullets/dot_bullet.png",
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Blaze" || weapon.name == "Ember") {
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    avoidBuildings: shape.avoidBuildings,
                    speed: 0.065,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    aoeRange: scale,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    color: `rgb(255, ${(Math.random() < .5 ? 255 : 0)}, 0, ${Math.randInt(6, 10) / 10})`,
                    owner: shape,
                    motherShipCharge: weapon.motherShipCharge,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Inferno" || weapon.name == "Pyro" || weapon.name == "Igniter" || weapon.name == "Discharger") {
                for (let i = 0; i < 2; i++) projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: weapon.name == "Igniter" || weapon.name == "Discharger" ? 20 : scale,
                    avoidBuildings: shape.avoidBuildings,
                    speed: weapon.name == "Igniter" || weapon.name == "Discharger" ? 0.125 : 0.1,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    aoeRange: weapon.name == "Igniter" || weapon.name == "Discharger" ? 120 : scale * 4,
                    blastEffect: weapon.name == "Igniter" || weapon.name == "Discharger" ? {
                        name: "blast",
                        last: 10e3,
                        power: weapon.name == "Discharger" ? 0.02 : 0.01
                    } : undefined,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    color: `rgb(0, ${(Math.random() < .5 ? 255 : 0)}, 255, ${Math.randInt(8, 10) / 10})`,
                    owner: shape,
                    defensePointsBypass: (1 - weapon.defenseBypass),
                    motherShipCharge: weapon.motherShipCharge,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Maha Vajra" || weapon.name == "Vajra") {
                for (let i = 0; i < 7; i++) projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    avoidBuildings: shape.avoidBuildings,
                    speed: 0.35,
                    dmg: weapon.dmg / 7,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    color: `rgb(128, 0, 128)`,

                    owner: shape,
                    slowEffect: {
                        name: "slowdown",
                        last: 15e3,
                        power: 0.0089
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Taran" || weapon.name == "Redeemer") {
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    avoidBuildings: shape.avoidBuildings,
                    speed: 0.3,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    aoeRange: weapon.aoeRange,
                    dir: dir,
                    isAlly: isAlly,
                    color: `#f00`,
                    owner: shape,
                    motherShipCharge: weapon.motherShipCharge,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Destroyer" || weapon.name == "Ultimate Destroyer") {
                for (let i = 0; i < (weapon.name == "Ultimate Destroyer" ? 8 : 4); i++) projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    avoidBuildings: shape.avoidBuildings,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    color: "./images/bullets/bullet.png",
                    owner: shape,
                    defensePointsBypass: (1 - weapon.defenseBypass),
                    motherShipCharge: weapon.motherShipCharge,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Evora" || weapon.name == "Veyron" || weapon.name == "Disintegrator" || weapon.name == "Havoc") {
                let spread = weapon.spread;
                for (let i = 0; i < weapon.shotsPerFire; i++) projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir + getRandomOffset(spread),
                    isAlly: isAlly,
                    avoidBuildings: shape.avoidBuildings,
                    color: "./images/bullets/sonic_blast.png",
                    owner: shape,
                    motherShipCharge: weapon.motherShipCharge,
                    defensePointsBypass: (1 - weapon.defenseBypass),
                    grayDamageAmount: 1,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Devastator" || weapon.name == "Scatter" || weapon.name == "Screamer" || weapon.name == "Growler") {
                for (let i = 0; i < (weapon.name == "Screamer" || weapon.name == "Growler" ? 4 : 10); i++) {
                    projectiles.push({
                        projType: weapon.projType,
                        x: x,
                        y: y,
                        oldX: x,
                        oldY: y,
                        velx: 0,
                        vely: 0,
                        scale: scale,
                        speed: 0.25,
                        dmg: weapon.dmg / (weapon.name == "Screamer" || weapon.name == "Growler" ? 4 : 10),
                        range: weapon.range,
                        dir: dir + getRandomOffset(weapon.spread),
                        isAlly: isAlly,
                        motherShipCharge: weapon.motherShipCharge,
                        avoidBuildings: shape.avoidBuildings,
                        color: "./images/bullets/sonic_blast.png",
                        owner: shape,
                        knockback: weapon.name == "Screamer" || weapon.name == "Growler" ? undefined : 0.07,
                        grayDamageAmount: 1,
                        weaponOwner: {
                            name: weapon.name,
                            level: weapon.level
                        }
                    });
                }
            } else if (weapon.name == "Thunder" || weapon.name == "Storm") {
                for (let i = 0; i < 16; i++) {
                    projectiles.push({
                        projType: weapon.projType,
                        x: x,
                        y: y,
                        oldX: x,
                        oldY: y,
                        velx: 0,
                        vely: 0,
                        scale: scale,
                        speed: 0.25,
                        dmg: weapon.dmg / 16,
                        range: weapon.range,
                        dir: dir + getRandomOffset(weapon.spread),
                        isAlly: isAlly,
                        motherShipCharge: weapon.motherShipCharge,
                        avoidBuildings: shape.avoidBuildings,
                        color: "./images/bullets/bullet.png",
                        owner: shape,
                        weaponOwner: {
                            name: weapon.name,
                            level: weapon.level
                        }
                    });
                }
            } else if (weapon.name == "Viper" || weapon.name == "Sting") {
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    avoidBuildings: shape.avoidBuildings,
                    dotEffect: {
                        name: "dot",
                        last: 5e3,
                        dmg: weapon.dotDamage,
                        owner: shape
                    },
                    motherShipCharge: weapon.motherShipCharge,
                    color: "./images/bullets/dot_bullet.png",
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Atomizer" || weapon.name == "Nucleon") {
                let spread = (weapon.firedTime / 10e3) * weapon.spread;
                for (let i = 0; i < 2; i++) projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    avoidBuildings: shape.avoidBuildings,
                    dir: dir + getRandomOffset(spread),
                    isAlly: isAlly,
                    motherShipCharge: weapon.motherShipCharge,
                    color: "./images/bullets/energy_bullet.png",
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Flux") {
                projectiles.push({
                    projType: weapon.projType,
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    antiTier4_5: true,
                    avoidBuildings: shape.avoidBuildings,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    motherShipCharge: weapon.motherShipCharge,
                    color: "./images/bullets/energy_bullet.png",
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Mace" || weapon.name == "Hammer") {
                for (let i = 0; i < 7; i++) projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    motherShipCharge: weapon.motherShipCharge,
                    speed: 0.2,
                    aoeRange: weapon.aoeRange,
                    dmg: weapon.dmg / 7,
                    range: weapon.range,
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    blastEffect: {
                        name: "blast",
                        last: 7e3,
                        power: weapon.effectIncrease
                    },
                    color: `./images/bullets/red_bullet.png`,
                    avoidBuildings: shape.avoidBuildings,
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            } else if (weapon.name == "Ultimate Halo" || weapon.name == "Ultimate Glory" || weapon.name == "Halo" || weapon.name == "Glory") {
                for (let i = 0; i < 10; i++) projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    projType: weapon.projType,
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    motherShipCharge: weapon.motherShipCharge,
                    speed: 0.3,
                    aoeRange: weapon.aoeRange,
                    dmg: weapon.dmg / 10,
                    range: weapon.range,
                    lockdownEffect: {
                        name: "lockdown acc",
                        last: 5e3,
                        power: weapon.effectIncrease / 10
                    },
                    defensePointsBypass: (1 - weapon.defenseBypass),
                    dir: dir + getRandomOffset(weapon.spread),
                    isAlly: isAlly,
                    color: `./images/bullets/purple_bullet.png`,
                    avoidBuildings: shape.avoidBuildings,
                    owner: shape,
                    weaponOwner: {
                        name: weapon.name,
                        level: weapon.level
                    }
                });
            }
        }
    }
    function resetDataStuff() {
        player.gameMode = -1;
        player.mapID = -1;
        document.getElementById("mapName").style.display = "none";
        enemies = [];
        projectiles = [];
        players = [];
        buildings = [];
        shieldEffects = [];
        KILLLOGS = [];
        beaconPoints.enemy = 0;
        beaconPoints.ally = 0;
        text = [];
        bombeffect = [];
        gameTimePlayed = 0;
        let allElements = document.getElementsByTagName("*");
        let elementsWithTracer = [];
        for (let i = 0; i < allElements.length; i++) {
            let element = allElements[i];
            if (element.id) {
                if (element.id.indexOf("radar") !== -1) {
                    elementsWithTracer.push(element);
                }
            }
        }
        elementsWithTracer.forEach(e => {
            e.remove();
        });
    }
    function getLeagueName(league) {
        if (league > 5e3) {
            return "Champion";
        } else if (league >= 3801 && league <= 5e3) {
            return "Master";
        } else if (league >= 2901 && league <= 3800) {
            return "Expert";
        } else if (league >= 2101 && league <= 2900) {
            return "Diamond";
        } else if (league >= 1501 && league <= 2100) {
            return "Gold";
        } else if (league >= 1001 && league <= 1500) {
            return "Silver";
        } else if (league >= 701 && league <= 1000) {
            return "Bronze";
        } else if (league >= 451 && league <= 700) {
            return "Private";
        } else {
            return "Recruit";
        }
    }
    function getWinHonor(league) {
        let name = getLeagueName(league);
        if (name == "Champion") {
            return 423;
        } else if (name == "Master") {
            return 380;
        } else if (name == "Expert") {
            return 289;
        } else if (name == "Diamond") {
            return 289;
        } else if (name == "Gold") {
            return 220;
        } else if (name == "Silver") {
            return 168;
        } else if (name == "Bronze") {
            return 108;
        } else if (name == "Private") {
            return 0;
        } else {
            return 0;
        }
    }
    function getBeaconKillHonor(league) {
        let name = getLeagueName(league);
        if (name == "Champion") {
            return 34;
        } else if (name == "Master") {
            return 50;
        } else if (name == "Expert" || name == "Diamond") {
            return 28;
        } else if (name == "Gold") {
            return 24;
        } else if (name == "Silver") {
            return 19;
        } else if (name == "Bronze") {
            return 9;
        } else {
            return 0;
        }
    }
    function setBattleStats(player, isWin, league, gameMode) {
        if (player.name == "Bluebell") player.honor += 333;
        for (let i = 0; i < player.robots.length; i++) {
            let robot = player.robots[i];
            if (robot && robot.battleStats) {
                if (robot.battleStats.dmg) {
                    let dmg = Math.abs(robot.battleStats.dmg);
                    dmg /= 6250;
                    dmg = Math.round(dmg / 2);
                    player.honor += dmg;
                    dmg = Math.abs(robot.battleStats.dmg);
                    dmg /= 1e6;
                    dmg = Math.round(dmg);
                    player.honor += dmg * 50;
                }
                if (robot.battleStats.kills) {
                    let kills = Math.abs(robot.battleStats.kills);
                    player.honor += kills * getBeaconKillHonor(league) * (gameMode == 4 ? 2.5 : 1);
                    player.honor += Math.round(kills / 5) * getBeaconKillHonor(league) * (gameMode == 4 ? 2.5 : 1);
                }
                if (robot.battleStats.beacons) {
                    let beacons = Math.abs(robot.battleStats.beacons);
                    player.honor += beacons * getBeaconKillHonor(league);
                    player.honor += Math.round(beacons / 10) * getBeaconKillHonor(league);
                }
            }
        }
        if ((player.isAlly && isWin) || (!player.isAlly && !isWin)) {
            player.honor += getWinHonor(league);
        }
    }
    function getRank1Honor(league) {
        let name = getLeagueName(league);
        if (name == "Champion") {
            return 360;
        } else if (name == "Master") {
            return 300;
        } else if (name == "Expert" || name == "Diamond") {
            return 221;
        } else if (name == "Gold") {
            return 160;
        } else if (name == "Silver") {
            return 108;
        } else if (name == "Bronze") {
            return 72;
        } else {
            return 0;
        }
    }
    function getRank2Honor(league) {
        let name = getLeagueName(league);
        if (name == "Champion") {
            return 216;
        } else if (name == "Master") {
            return 180;
        } else if (name == "Expert" || name == "Diamond") {
            return 131;
        } else if (name == "Gold") {
            return 99;
        } else if (name == "Silver") {
            return 66;
        } else if (name == "Bronze") {
            return 42;
        } else {
            return 0;
        }
    }
    function getRank3Honor(league) {
        let name = getLeagueName(league);
        if (name == "Champion") {
            return 108;
        } else if (name == "Master") {
            return 90;
        } else if (name == "Expert" || name == "Diamond") {
            return 68;
        } else if (name == "Gold") {
            return 50;
        } else if (name == "Silver") {
            return 30;
        } else if (name == "Bronze") {
            return 24;
        } else {
            return 0;
        }
    }
    function setGlobalStats(data, isWin, league) {
        let thingy = [];
        for (let i = 0; i < data.length; i++) {
            let _ = data[i];
            if (_) {
                _.robots.forEach(e => {
                    if (e && e.battleStats) {
                        if (!thingy[i]) {
                            thingy[i] = {
                                index: i,
                                dmg: e.battleStats.dmg || 0,
                                beacons: e.battleStats.beacons || 0
                            };
                        } else {
                            if (e.battleStats.dmg) thingy[i].dmg += e.battleStats.dmg;
                            if (e.battleStats.beacons) thingy[i].beacons += e.battleStats.beacons;
                        }
                    }
                });
            }
        }
        if (data.length) {
            for (let i = 0; i < 3; i++) {
                let dmgThing = thingy.sort((a, b) => b.dmg - a.dmg)[i];
                let beaconThing = thingy.sort((a, b) => b.beacons - a.beacons)[i];
                if (!dmgThing || !beaconThing) continue;
                if (i == 0) {
                    data[dmgThing.index].honor += getRank1Honor(league);
                    data[beaconThing.index].honor += getRank1Honor(league);
                } else if (i == 1 && data.length >= 2) {
                    data[dmgThing.index].honor += getRank2Honor(league);
                    data[beaconThing.index].honor += getRank2Honor(league);
                } else if (i == 2 && data.length >= 3) {
                    data[dmgThing.index].honor += getRank3Honor(league);
                    data[beaconThing.index].honor += getRank3Honor(league);
                }
            }
        }
    }
    var LegauePointRewardData = {
        Champion: {
            win: [39, 30, 21, 12, 9, 6],
            lose: [21, 9, -15, -33, -51, -66]
        },
        Master: {
            win: [51, 39, 30, 21, 12, 9],
            lose: [21, 9, 3, -15, -33, -51]
        },
        Expert: {
            win: [51, 39, 30, 21, 12, 9],
            lose: [21, 9, 3, -15, -33, -51]
        },
        Diamond: {
            win: [51, 39, 30, 21, 12, 9],
            lose: [30, 21, 9, 3, -15, -33]
        },
        Gold: {
            win: [51, 39, 30, 21, 12, 9],
            lose: [30, 21, 9, 3, -15, -33]
        },
        Silver: {
            win: [66, 51, 39, 21, 12, 9],
            lose: [30, 21, 9, 3, -15, -33]
        },
        Bronze: {
            win: [66, 51, 39, 21, 12, 9],
            lose: [30, 21, 9, 3, 0, 0]
        },
        Private: {
            win: [81, 66, 51, 39, 21, 12],
            lose: [30, 21, 9, 3, 0, 0]
        },
        Recruit: {
            win: [81, 66, 51, 39, 21, 12],
            lose: [39, 30, 21, 9, 3, 0]
        }
    };
    function getLegauePointReward(league, place, isWin, gameMode) {
        let name = getLeagueName(league);
        if (isWin) {
            let data = LegauePointRewardData[name].win;
            return data[place] || (data[data.length - 1]);
        } else {
            let data = LegauePointRewardData[name].lose;
            if (gameMode == 4 && place <= 5) {
                data = LegauePointRewardData[name].win;
            }
            return data[place] || (data[data.length - 1]);
        }
    }
    function getRewardsForGame(type, player, league) {
        let total = {
            sliver: 0,
            gold: 0,
            oxp: 0,
            playerXP: 0,
            keys: 0
        };
        let dmg = Math.round(player.robots.filter(item => item && item.battleStats && item.battleStats.dmg).map(item => item.battleStats.dmg).reduce((acc, current) => acc + current, 0));
        let kills = player.robots.filter(item => item && item.battleStats && item.battleStats.kills).map(item => item.battleStats.kills).reduce((acc, current) => acc + current, 0);
        let beacons = Math.round(player.robots.filter(item => item && item.battleStats && item.battleStats.beacons).map(item => item.battleStats.beacons).reduce((acc, current) => acc + current, 0));
        if (type == "pvp") {
            total.sliver += (player.honor / 5) * 5e3;
            total.sliver += (player.honor / 100) * 20e3;
            total.sliver += (player.honor / 1e3) * 150e3;
            total.sliver = Math.round(total.sliver);

            total.gold += player.honor * .8;
            total.gold += (player.honor / 1e3) * 250;
            total.gold = Math.round(total.gold);

            total.oxp += player.honor / 10;
            total.oxp += (player.honor / 100) * 25;
            total.oxp = Math.round(total.oxp);

            total.playerXP += player.honor / 5;
            total.playerXP += (player.honor / 100) * 25;
            total.playerXP = Math.round(total.playerXP);

            total.keys += kills * 2;
            total.keys += beacons * 2;
            total.keys += (dmg / 500e3) * 25;
            total.keys += (dmg / 100e3) * 5;
            total.keys += (dmg / 15e3);
            total.keys = Math.round(total.keys);
        } else if (type == "pve") {
            total.sliver += (dmg / 100e3) * 50e3;
            total.sliver += kills * 15e3;
            total.sliver = Math.round(total.sliver);
            if (player.rewardBonus && player.rewardBonus.silver) {
                total.sliver += player.rewardBonus.silver;
            }

            total.gold += kills * 1.5;
            total.gold += (dmg / 100e3) * 10;
            total.gold = Math.round(total.gold);
            if (player.rewardBonus && player.rewardBonus.gold) {
                total.gold += player.rewardBonus.gold;
            }

            total.playerXP += kills / 2;
            total.playerXP += (dmg / 100e3) * 25;
            total.playerXP = Math.round(total.playerXP);

            total.oxp += kills / 5;
            total.oxp += (dmg / 200e3) * 25;
            total.oxp = Math.round(total.oxp);
            if (player.rewardBonus && player.rewardBonus.OXP) {
                total.oxp += player.rewardBonus.OXP;
            }

            total.keys += kills * 2;
            total.keys += (dmg / 500e3) * 25;
            total.keys += (dmg / 100e3) * 5;
            total.keys += (dmg / 15e3);
            total.keys = Math.round(total.keys);
            if (player.rewardBonus && player.rewardBonus.keys) {
                total.keys += player.rewardBonus.keys;
            }

            if (player.rewardBonus && player.rewardBonus.WSP) {
                if (total.workshopPoints == null) total.workshopPoints = 0;
                total.workshopPoints += player.rewardBonus.WSP;
            }
        }
        total.playerXP *= 5;
        if (total.playerXP >= 5e3) {
            let amount = total.playerXP - 1e3;
            total.playerXP = 1e3;
            total.playerXP += amount * .75;
        }
        total.playerXP = Math.round(total.playerXP);
        return total;
    }
    function endGame(playersData, isWin, notFinish) {
        let gameMode = player.gameMode;
        document.getElementById("hangerUI").style.display = "none";
        document.getElementById("sideDisplay").style.display = "block";
        document.getElementById("goToBattle").style.display = "block";
        document.getElementById("gameModesDisplay").style.display = "none";
        document.getElementById("abilityCharges2").innerHTML = "";
        document.getElementById("useAbility2").style.display = "none";
        document.getElementById("titanChargeBar").style.display = "none";
        document.getElementById("healthBar").style.display = "none";
        document.getElementById("useAbility").style.display = "none";
        document.getElementById("weaponThing").style.display = "none";
        document.getElementById("mothershipBar").style.display = "none";
        document.getElementById("useActiveModule").style.display = "none";
        if (document.getElementById("useSlot8")) document.getElementById("useSlot8").style.display = "none";
        resetDataStuff();
        let allies = [];
        let enemies = [];
        for (let i = 0; i < playersData.length; i++) {
            let data = playersData[i];
            if (data.honor == null) data.honor = 0;
            if (i == 0) data.isMe = true;
            if (data.isAlly) {
                allies.push(data);
            } else {
                enemies.push(data);
            }
        }
        allies.forEach(e => {
            setBattleStats(e, isWin, player.league, player.gameMode);
        });
        enemies.forEach(e => {
            setBattleStats(e, isWin, player.league, player.gameMode);
        });
        setGlobalStats(allies, isWin, player.league);
        setGlobalStats(enemies, isWin, player.league);
        allies = allies.sort((a, b) => {
            if (a.isMe && a.honor === 0) {
                return 1;
            } else if (b.isMe && b.honor === 0) {
                return -1;
            } else {
                return b.honor - a.honor;
            }
        });
        enemies = enemies.sort((a, b) => b.honor - a.honor);
        let leagueReward = getLegauePointReward(player.league, allies.findIndex(e => e.isMe), isWin, gameMode);
        if (gameMode == 9 || gameMode == 2 || gameMode == 7) {
            let rewards = getRewardsForGame("pvp", allies.find(e => e.isMe), player.league);
            let width = window.innerWidth / 2 - 10 - 60;
            let width2 = window.innerWidth - 120;
            let height = window.innerHeight - 490;
            let text = `
            <div style="position: absolute; top: 0px; text-align: center; left: 250px; color: #fff; width: 75px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 52px;">
            military_tech
            </span>
            </div>
            <div style="position: absolute; top: 0px; text-align: center; left: 337.5px; color: #fff; width: 150px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 50px;">
            destruction
            </span>
            </div>
            <div style="position: absolute; top: 2.5px; text-align: center; left: 500px; color: #fff; width: 75px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 45px;">
            missing_controller
            </span>
            </div>
            <div style="position: absolute; top: 2.5px; text-align: center; left: 575px; color: #fff; width: 75px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 45px;">
            skull
            </span>
            </div>
            `;
            document.getElementById("sideDisplay").innerHTML = `
            <div style="position: absolute; color: #fff; text-align: center; font-size: 35px; top: 10px; left: 60px; width: ${width2}px; height: 50px; background: linear-gradient(to right, transparent 0%, transparent 20%, ${isWin ? "#0f0" : "#f00"} 50%, transparent 80%, transparent 100%);">
            ${isWin ? "Victory" : "Defeat"}
            </div>
            <div style="position: absolute; top: 150px; left: 60px; width: ${width}px; height: 50px; background-color: rgb(0, 255, 0, .75); overflow-x: scroll;">
            <div style="font-size: 35px; color: #fff; margin-left: 10px;">ALLIES</div>
            ${text}
            </div>
            <div style="position: absolute; top: 150px; right: 60px; width: ${width}px; height: 50px; background-color: rgb(255, 0, 0, .75); overflow-x: scroll;">
            <div style="font-size: 35px; color: #fff; margin-left: 10px;">ENEMIES</div>
            ${text}
            </div>
            <div id="allies" style="position: absolute; top: 210px; left: 60px; width: ${width}px; height: ${height}px; overflow: scroll;">
            </div>
            <div id="enemies" style="position: absolute; top: 210px; right: 60px; width: ${width}px; height: ${height}px; overflow: scroll;">
            </div>
            <div id="rewards" style="position: absolute; left: ${window.innerWidth / 2 - 200}px; bottom: 20px; width: 400px; height: 200px; border-radius: 6px; background-color: rgb(0, 0, 0, 0.25); overflow-y: scroll;">
            </div>
            <div style="position: absolute; font-size: 35px; text-align: center; left: ${window.innerWidth / 2 - 200}px; bottom: 225px; width: 400px;">
            REWARDS
            </div>
            `;
            let allyE = document.getElementById("allies");
            for (let i = 0; i < allies.length; i++) {
                let data = allies[i];
                if (data) {
                    allyE.innerHTML += `
                    <div style="position: absolute; ${i == 0 ? `top: 0px;` : `top: ${50 * i}px; border: solid; border-width: 5px 0px 0px 0px; border-color: #000;`} height: 50px; width: 100%; background-color: rgb(0, 0, 0, .25);">
                    <div style="position: absolute; cursor: pointer; top: 13.5px; left: 5px; color: #fff;">
                    ${data.name}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 250px; color: #fff; width: 75px;">
                    ${data.honor}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 337.5px; color: #fff; width: 150px;">
                    ${abbreviateNumber(Math.round(data.robots.filter(item => item && item.battleStats && item.battleStats.dmg).map(item => item.battleStats.dmg).reduce((acc, current) => acc + current, 0)))}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 500px; color: #fff; width: 75px;">
                    ${Math.round(data.robots.filter(item => item && item.battleStats && item.battleStats.beacons).map(item => item.battleStats.beacons).reduce((acc, current) => acc + current, 0))}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 575px; color: #fff; width: 75px;">
                    ${data.robots.filter(item => item && item.battleStats && item.battleStats.kills).map(item => item.battleStats.kills).reduce((acc, current) => acc + current, 0)}
                    </div>
                    </div>
                    `;
                }
            }
            let enemyE = document.getElementById("enemies");
            for (let i = 0; i < enemies.length; i++) {
                let data = enemies[i];
                if (data) {
                    enemyE.innerHTML += `
                    <div style="position: absolute; ${i == 0 ? `top: 0px;` : `top: ${50 * i}px; border: solid; border-width: 5px 0px 0px 0px; border-color: #000;`} height: 50px; width: 100%; background-color: rgb(0, 0, 0, .25);">
                    <div style="position: absolute; cursor: pointer; top: 13.5px; left: 5px; color: #fff;">
                    ${data.name}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 250px; color: #fff; width: 75px;">
                    ${data.honor}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 337.5px; color: #fff; width: 150px;">
                    ${abbreviateNumber(Math.round(data.robots.filter(item => item && item.battleStats && item.battleStats.dmg).map(item => item.battleStats.dmg).reduce((acc, current) => acc + current, 0)))}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 500px; color: #fff; width: 75px;">
                    ${Math.round(data.robots.filter(item => item && item.battleStats && item.battleStats.beacons).map(item => item.battleStats.beacons).reduce((acc, current) => acc + current, 0))}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 575px; color: #fff; width: 75px;">
                    ${data.robots.filter(item => item && item.battleStats && item.battleStats.kills).map(item => item.battleStats.kills).reduce((acc, current) => acc + current, 0)}
                    </div>
                    </div>
                    `;
                }
            }
            let index = 1;
            let elemtn = document.getElementById("rewards");
            elemtn.innerHTML += `
            <div style="position: absolute; top: 0px; left: 0px; width: 100%;">
            <div style="position: absolute; top: 0px; left: 0px; width: 50px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 50px; color: #ffff00;">
            rewarded_ads
            </span>
            </div>
            <div style="position: absolute; color: #fff; font-size: 35px; top: 0px; right: 5px;">
            ${leagueReward * (gameMode == 7 && !isWin ? -1 : 1)}
            </div>
            </div>
            `;
            updateMoneyDisplay("league", leagueReward * (gameMode == 7 && !isWin ? -1 : 1));
            for (let i in rewards) {
                if (gameMode == 7 && !isWin) {
                    rewards[i] *= .25;
                    rewards[i] = Math.round(rewards[i]);
                }
                if (i == "sliver" || i == "gold" || i == "keys") {
                    elemtn.innerHTML += `
                    <div style="position: absolute; top: ${50 * index}px; left: 0px; width: 100%;">
                    <div style="position: absolute; top: 0px; left: 0px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${i == "sliver" ? agSource : i == "keys" ? keysSource : auSource}');">
                    </div>
                    <div style="position: absolute; color: #fff; font-size: 35px; top: 0px; right: 5px;">
                    ${abbreviateNumber(rewards[i])}
                    </div>
                    </div>
                    `;
                    updateMoneyDisplay(i, rewards[i]);
                } else if (i == "oxp" || i == "playerXP") {
                    elemtn.innerHTML += `
                    <div style="position: absolute; top: ${50 * index}px; left: 0px; width: 100%;">
                    <div style="position: absolute; top: 0px; left: 0px; width: 50px; height: 50px;">
                    <span class="material-symbols-outlined" style="font-size: 50px; color: ${i == "playerXP" ? "#bdbdbd" : "#ffff00"};">
                    ${i == "playerXP" ? "token" : "star"}
                    </span>
                    </div>
                    <div style="position: absolute; color: #fff; font-size: 35px; top: 0px; right: 5px;">
                    ${abbreviateNumber(rewards[i])}
                    </div>
                    </div>
                    `;
                    if (i == "oxp") {
                        addOperationXP(rewards[i]);
                    } else {
                        updateMoneyDisplay("player_xp", rewards[i]);
                    }
                }
                index++;
            }
        } else if (gameMode == 0) {
            let me = allies.find(e => e.isMe);
            let rewards = isWin ? player.exterminationData.rewards : {};
            if (player.exterminationIndx > player.exterminationData.indx) {
                rewards = {};
            }
            if (isWin && player.exterminationIndx < player.exterminationData.indx + 1) {
                player.exterminationIndx = player.exterminationData.indx + 1;
            }
            player.exterminationData = null;
            let width = window.innerWidth - 20 - 120;
            let width2 = window.innerWidth - 120;
            let height = window.innerHeight - 490;
            let text = `
            <div style="position: absolute; top: 0px; text-align: center; left: 337.5px; color: #fff; width: 150px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 50px;">
            destruction
            </span>
            </div>
            <div style="position: absolute; top: 2.5px; text-align: center; left: 500px; color: #fff; width: 75px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 45px;">
            skull
            </span>
            </div>
            `;
            document.getElementById("sideDisplay").innerHTML = `
            <div style="position: absolute; color: #fff; text-align: center; font-size: 35px; top: 10px; left: 60px; width: ${width2}px; height: 50px; background: linear-gradient(to right, transparent 0%, transparent 20%, ${isWin ? "#0f0" : "#808080"} 50%, transparent 80%, transparent 100%);">
            Battle Overview
            </div>
            <div style="position: absolute; top: 150px; left: 60px; width: ${width}px; height: 50px; background: linear-gradient(to right, #808080, transparent); overflow-x: scroll;">
            <div style="font-size: 35px; color: #fff; margin-left: 10px;">ROBOTS</div>
            ${text}
            </div>
            <div id="robots" style="position: absolute; top: 210px; left: 60px; width: ${width}px; height: ${height}px; overflow: scroll;">
            </div>
            <div id="rewards" style="position: absolute; left: ${window.innerWidth / 2 - 200}px; bottom: 20px; width: 400px; height: 200px; border-radius: 6px; background-color: rgb(0, 0, 0, 0.25); overflow-y: scroll;">
            </div>
            <div style="position: absolute; font-size: 35px; text-align: center; left: ${window.innerWidth / 2 - 200}px; bottom: 225px; width: 400px;">
            REWARDS
            </div>
            `;
            let allyE = document.getElementById("robots");
            for (let i = 0; i < me.robots.length; i++) {
                let data = me.robots[i];
                if (data) {
                    allyE.innerHTML += `
                    <div style="position: absolute; ${i == 0 ? `top: 0px;` : `top: ${50 * i}px; border: solid; border-width: 5px 0px 0px 0px; border-color: #000;`} height: 50px; width: 100%; background-color: rgb(0, 0, 0, .25);">
                    <div style="position: absolute; cursor: pointer; top: 13.5px; left: 5px; color: #fff;">
                    ${data.name}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 337.5px; color: #fff; width: 150px;">
                    ${data.battleStats ? Math.round(data.battleStats.dmg || 0) : 0}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 500px; color: #fff; width: 75px;">
                    ${data.battleStats ? Math.round(data.battleStats.kills || 0) : 0}
                    </div>
                    </div>
                    `;
                }
            }
            let index = 0;
            let elemtn = document.getElementById("rewards");
            for (let i in rewards) {
                if (i == "sliver" || i == "gold" || i == "keys" || i == "workshopPoints") {
                    elemtn.innerHTML += `
                    <div style="position: absolute; top: ${50 * index}px; left: 0px; width: 100%;">
                    <div style="position: absolute; top: 0px; left: 0px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${i == "sliver" ? agSource : i == "keys" ? keysSource : i == "workshopPoints" ? "./images/icons/workshop.png" : auSource}');">
                    </div>
                    <div style="position: absolute; color: #fff; font-size: 35px; top: 0px; right: 5px;">
                    ${abbreviateNumber(rewards[i])}
                    </div>
                    </div>
                    `;
                    updateMoneyDisplay(i, rewards[i]);
                } else if (i == "oxp") {
                    elemtn.innerHTML += `
                    <div style="position: absolute; top: ${50 * index}px; left: 0px; width: 100%;">
                    <div style="position: absolute; top: 0px; left: 0px; width: 50px; height: 50px;">
                    <span class="material-symbols-outlined" style="font-size: 50px; color: ${i == "playerXP" ? "#bdbdbd" : "#ffff00"};">
                    star
                    </span>
                    </div>
                    <div style="position: absolute; color: #fff; font-size: 35px; top: 0px; right: 5px;">
                    ${abbreviateNumber(rewards[i])}
                    </div>
                    </div>
                    `;
                    if (i == "oxp") {
                        addOperationXP(rewards[i]);
                    } else {
                        updateMoneyDisplay("player_xp", rewards[i]);
                    }
                }
                index++;
            }
        } else if (gameMode == 4) {
            let me = allies.find(e => e.isMe);
            let rewards = getRewardsForGame("pvp", me, player.league);
            let width = window.innerWidth - 20 - 120;
            let width2 = window.innerWidth - 120;
            let height = window.innerHeight - 490;
            let text = `
            <div style="position: absolute; top: 0px; text-align: center; left: 250px; color: #fff; width: 75px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 52px;">
            military_tech
            </span>
            </div>
            <div style="position: absolute; top: 0px; text-align: center; left: 337.5px; color: #fff; width: 150px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 50px;">
            destruction
            </span>
            </div>
            <div style="position: absolute; top: 2.5px; text-align: center; left: 500px; color: #fff; width: 75px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 45px;">
            skull
            </span>
            </div>
            `;
            document.getElementById("sideDisplay").innerHTML = `
            <div style="position: absolute; color: #fff; text-align: center; font-size: 35px; top: 10px; left: 60px; width: ${width2}px; height: 50px; background: linear-gradient(to right, transparent 0%, transparent 20%, #808080 50%, transparent 80%, transparent 100%);">
            Battle Overview
            </div>
            <div style="position: absolute; top: 150px; left: 60px; width: ${width}px; height: 50px; background: linear-gradient(to right, #808080, transparent); overflow-x: scroll;">
            <div style="font-size: 35px; color: #fff; margin-left: 10px;">ROBOTS</div>
            ${text}
            </div>
            <div id="robots" style="position: absolute; top: 210px; left: 60px; width: ${width}px; height: ${height}px; overflow: scroll;">
            </div>
            <div id="rewards" style="position: absolute; left: ${window.innerWidth / 2 - 200}px; bottom: 20px; width: 400px; height: 200px; border-radius: 6px; background-color: rgb(0, 0, 0, 0.25); overflow-y: scroll;">
            </div>
            <div style="position: absolute; font-size: 35px; text-align: center; left: ${window.innerWidth / 2 - 200}px; bottom: 225px; width: 400px;">
            REWARDS
            </div>
            `;
            let allyE = document.getElementById("robots");
            for (let i = 0; i < allies.length + enemies.length; i++) {
                let data = allies[i] || enemies[i - allies.length];
                if (data) {
                    allyE.innerHTML += `
                    <div style="position: absolute; ${i == 0 ? `top: 0px;` : `top: ${50 * i}px; border: solid; border-width: 5px 0px 0px 0px; border-color: #000;`} height: 50px; width: 100%; background-color: rgb(0, 0, 0, .25);">
                    <div style="position: absolute; cursor: pointer; top: 13.5px; left: 5px; color: #fff;">
                    ${data.name}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 250px; color: #fff; width: 75px;">
                    ${data.honor}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 337.5px; color: #fff; width: 150px;">
                    ${abbreviateNumber(Math.round(data.robots.filter(item => item && item.battleStats && item.battleStats.dmg).map(item => item.battleStats.dmg).reduce((acc, current) => acc + current, 0)))}
                    </div>
                    <div style="position: absolute; top: 13.5px; text-align: center; left: 500px; color: #fff; width: 75px;">
                    ${abbreviateNumber(Math.round(data.robots.filter(item => item && item.battleStats && item.battleStats.kills).map(item => item.battleStats.kills).reduce((acc, current) => acc + current, 0)))}
                    </div>
                    </div>
                    `;
                }
            }
            let index = 1;
            let elemtn = document.getElementById("rewards");
            elemtn.innerHTML += `
            <div style="position: absolute; top: 0px; left: 0px; width: 100%;">
            <div style="position: absolute; top: 0px; left: 0px; width: 50px; height: 50px;">
            <span class="material-symbols-outlined" style="font-size: 50px; color: #ffff00;">
            rewarded_ads
            </span>
            </div>
            <div style="position: absolute; color: #fff; font-size: 35px; top: 0px; right: 5px;">
            ${leagueReward}
            </div>
            </div>
            `;
            updateMoneyDisplay("league", leagueReward);
            for (let i in rewards) {
                if (i == "sliver" || i == "gold" || i == "keys" || i == "workshopPoints") {
                    elemtn.innerHTML += `
                    <div style="position: absolute; top: ${50 * index}px; left: 0px; width: 100%;">
                    <div style="position: absolute; top: 0px; left: 0px; width: 50px; height: 50px; background-size: 50px 50px; background-image: url('${i == "sliver" ? agSource : i == "keys" ? keysSource : i == "workshopPoints" ? "./images/icons/workshop.png" : auSource}');">
                    </div>
                    <div style="position: absolute; color: #fff; font-size: 35px; top: 0px; right: 5px;">
                    ${abbreviateNumber(rewards[i])}
                    </div>
                    </div>
                    `;
                    updateMoneyDisplay(i, rewards[i]);
                } else if (i == "oxp" || i == "playerXP") {
                    elemtn.innerHTML += `
                    <div style="position: absolute; top: ${50 * index}px; left: 0px; width: 100%;">
                    <div style="position: absolute; top: 0px; left: 0px; width: 50px; height: 50px;">
                    <span class="material-symbols-outlined" style="font-size: 50px; color: ${i == "playerXP" ? "#bdbdbd" : "#ffff00"};">
                    ${i == "playerXP" ? "token" : "star"}
                    </span>
                    </div>
                    <div style="position: absolute; color: #fff; font-size: 35px; top: 0px; right: 5px;">
                    ${abbreviateNumber(rewards[i])}
                    </div>
                    </div>
                    `;
                    if (i == "oxp") {
                        addOperationXP(rewards[i]);
                    } else {
                        updateMoneyDisplay("player_xp", rewards[i]);
                    }
                }
                index++;
            }
        }
        for (let i = 0; i < allies.length; i++) {
            let data = allies[i];
            if (data && data.isMe) {
                if (player.profile.dmg == null) player.profile.dmg = [];
                player.profile.dmg.push(Math.round(data.robots.filter(item => item && item.battleStats && item.battleStats.dmg).map(item => item.battleStats.dmg).reduce((acc, current) => acc + current, 0)));
                if (player.profile.dmg.length > 25) {
                    player.profile.dmg.shift();
                }
            }
        }
        if (player.profile.wins == null) player.profile.wins = [];
        player.profile.wins.push(isWin ? 1 : 0);
        if (player.profile.wins.length > 25) {
            player.profile.wins.shift();
        }
        saveGameData();
        document.getElementById("sideDisplay").innerHTML += `
        <div id="backButton" style="cursor: pointer; position: absolute; bottom: 15px; left: 10px; text-align: center; width: 150px; height: 40px; font-size: 30px; border-radius: 6px; background-color: rgb(0, 0, 0, .35);">
        BACK
        </div>
        `;
        document.getElementById("backButton").onclick = function () {
            document.getElementById("sideDisplay").innerHTML = "";
            document.getElementById("hangerUI").style.display = "block";
        }
    }
    var deltaTimer = 0;
    var shieldEffects = [];
    function addGrayDamage(shape, amount, graydmg, isDotDamage, maxhealthDamage) {
        let grayDamageMulti = 1;
        if (shape.modules && shape.modules.length) {
            shape.modules.forEach(e => {
                if (e.grayDamageDecrease) {
                    grayDamageMulti -= e.grayDamageDecrease;
                }
            });
        }
        grayDamageMulti = Math.max(grayDamageMulti, 0);
        let grayDmg = (graydmg + 1 >= 1 ? graydmg : .4);
        if ((shape.name == "Mauler" || shape.name == "Tan Circle" || shape.name == "Ultimate Tan Circle" || shape.name == "Blue-Outlined Tan Circle" || shape.name == "Pink Circle") && isDotDamage) {
            grayDmg *= shape.name == "Pink Circle" ? .2 : 0;
        } else if (shape.hullIntegrity) {
            grayDmg *= (1 - shape.hullIntegrity);
        }
        if (shape.drones && shape.drones.length) {
            for (let i = 0; i < shape.drones.length; i++) {
                if (shape.drones[i].abilities.find(e => e.name == "On Deployment: Protect Hull")) {
                    grayDmg *= .65;
                }
            }
        }
        if (maxhealthDamage) grayDmg *= .5;
        if (shape.grayDamage < 0) shape.grayDamage = 0;
        shape.grayDamage += Math.abs(amount * grayDmg * grayDamageMulti);
        if (shape.effects && shape.effects.find(e => ["Cannonier", "extra health"].includes(e.name) && e.health > 0)) {
            let effect = shape.effects.find(e => ["Cannonier", "extra health"].includes(e.name) && e.health > 0);
            if (effect.grayDamage == null) effect.grayDamage = 0;
            effect.grayDamage += Math.abs(amount * grayDmg * grayDamageMulti);
        }
    }
    var domains = [];
    function doPaldinStuff(robot, isAlly) {
        bombeffect.push({
            location: robot,
            scale: 0,
            maxScale: 1200,
            color: "blue"
        });
        for (let t = 0; t < players.length; t++) {
            let player = players[t].robots[players[t].robotIndex];
            if (player && players[t].isAlly != isAlly) {
                if (!player.effects.find(e => e.name == "phase shift") && Math.hypot(player.y - robot.y, player.x - robot.x) <= 1200 + player.scale) {
                    player.weapons.forEach(e => {
                        if (e.name != "Atomizer" && e.name != "Nucleon") {
                            e.ammo = 0;
                        }
                    });
                    if (player.abilities.length) {
                        for (let i = 0; i < player.abilities.length; i++) {
                            let ability = player.abilities[i];
                            if (ability.abilityLast > 0) {
                                doAbilityEndFunction(player, 0, undefined, ability);
                            }
                            ability.abilityLast = 0;
                            ability.abilityReload = ability.reload;
                            if (ability.charges) {
                                ability.charges = 0;
                            }
                        }
                    }
                    player.effects.forEach(e => {
                        if (e.name == "Ultimate Mending" || e.name == "stampede" || e.name == "overload") {
                            e.lastTime = 0;
                        } else if (e.name == "slowdown" && e.power == .8) {
                            e.lastTime = 0;
                        } else if (e.name == "defense points" && e.amount == 9e3) {
                            e.lastTime = 0;
                        } else if (e.abilityEffect || e.isAbility) {
                            e.lastTime = 0;
                        }
                    });
                    player.shields.forEach(e => {
                        if (e.regen || e.type == "purple") {
                            if (e.type == "purple") {
                                e.kill = true;
                            } else {
                                e.health = 0;
                            }
                        }
                    });
                }
            }
        }
    }
    function killIfBorder(robot) {
        if (player.mapID == 1) {
            let player1 = findPlayerBySid(robot.inGameSid);
            addLogger({ name: "Game" }, null, player1);
            robot.kill = true;
        }
    }
    function doBorderCollision(robot, delta) {
        if (robot.x + (robot.velx * delta) >= robot.scale && robot.x + (robot.velx * delta) <= mapInfo.x - robot.scale) {
            robot.x += (robot.velx * delta);
        } else {
            if (robot.x + (robot.velx * delta) >= mapInfo.x - robot.scale) {
                robot.x = mapInfo.x - robot.scale;
                killIfBorder(robot);
            } else {
                robot.x = robot.scale;
                killIfBorder(robot);
            }
        }
        if (robot.y + (robot.vely * delta) >= robot.scale && robot.y + (robot.vely * delta) <= mapInfo.y - robot.scale) {
            robot.y += (robot.vely * delta);
        } else {
            if (robot.y + (robot.vely * delta) >= mapInfo.y - robot.scale) {
                robot.y = mapInfo.y - robot.scale;
                killIfBorder(robot);
            } else {
                robot.y = robot.scale;
                killIfBorder(robot);
            }
        }
    }
    function decelerateRobot(robot, delta) {
        let m = 0.994;
        if (robot.velx) robot.velx *= Math.pow(m, delta);
        if (robot.vely) robot.vely *= Math.pow(m, delta);
    }
    function convertDamageToDOT(robot) {
        if (robot.dotConverter && robot.dotConverter.length) {
            let amount = 0;
            let doers = [];
            let duration = robot.dotConverter[0].duration;
            for (let i = 0; i < robot.dotConverter.length; i++) {
                let info = robot.dotConverter[i];
                if (!doers.find(e => e.owner == info.doer)) {
                    doers.push({
                        owner: info.doer,
                        dmg: (info.amount / duration)
                    });
                } else {
                    let index = doers.findIndex(e => e.owner == info.doer);
                    doers[index].dmg += (info.amount / duration);
                }
                amount += info.amount;
            }
            robot.effects.push({
                name: "dot",
                dmg: Math.abs(amount) / duration,
                owners: doers,
                turned: true,
                lastTime: duration * 1000
            });
            if (robot.stampedeV2) {
                robot.effects.push({
                    name: "defense points",
                    amount: robot.dotConverter.length,
                    lastTime: 7e3
                });
            }
        }
        robot.dotConverter = [];
    }
    function doPlayerMovement(robot, delta, { hasStampede, slowdownMulti, speedMulti, isAlly }) {
        if (robot.lockdown) {
            robot.velx = 0;
            robot.vely = 0;
            return;
        }

        if ((robot.isMe ? (keysPressed[87] || keysPressed[65] || keysPressed[83] || keysPressed[68]) : true)) {
            let moveDir = undefined;
            if (robot.isMe) {
                let dx = (keysPressed[68]) - (keysPressed[65]);
                let dy = (keysPressed[83]) - (keysPressed[87]);
                moveDir = Math.atan2(dy, dx);
            } else {
                moveDir = doMoveStuff(robot, isAlly);
            }
            if (moveDir == undefined || moveDir == null) return;
            robot.targetDir = moveDir;
            if (hasStampede && (robot.name == "Ultimate Tan Circle" ? true : hasStampede.lastTime > 4e3)) {
                if (robot.movedir == null) {
                    robot.movedir = moveDir;
                }
                if (robot.movedir != moveDir) {
                    robot.movedir %= (Math.PI * 2);
                    let netAngle = (robot.movedir - moveDir + (Math.PI * 2)) % (Math.PI * 2);
                    let amnt = Math.min(Math.abs(netAngle - (Math.PI * 2)), netAngle, (robot.name == "Ultimate Tan Circle" ? .0036 : .0018) * delta);
                    let sign = (netAngle - Math.PI) >= 0 ? 1 : -1;
                    if (!isNaN(netAngle)) {
                        robot.movedir += sign * amnt + (Math.PI * 2);
                    }
                    moveDir = robot.movedir;
                }
            } else {
                robot.movedir = moveDir;
            }
            let moveSpeed = robot.speed * robot.reloadMoveMulti;
            moveSpeed *= robot.abilitySpeedMulti;
            moveSpeed *= slowdownMulti;
            moveSpeed *= speedMulti;
            moveSpeed *= (robot.isFREEZE ? .2 : 1);
            if (!robot.avoidBuildings && buildings.find(e => e.name == "pond" && dist(e, robot) <= e.tmpScale)) {
                moveSpeed *= (1 / 3);
            }
            if ((robot.name == "Ultimate Brown Pentagon" || robot.name == "Brown Pentagon") && robot.abilities[0].mode == 1) {
                if (robot.name == "Ultimate Brown Pentagon") {
                    moveSpeed *= .5;
                } else {
                    moveSpeed *= (1 / 3);
                }
            }
            robot.velx += Math.cos(moveDir) * (moveSpeed * delta);
            robot.vely += Math.sin(moveDir) * (moveSpeed * delta);
        }
    }
    function doModulesStuff(robot, delta) {
        let shieldRegenMulti = 1;
        let amountOfLastStand = robot.modules.filter(e => e.name == "Last Stand");
        if (amountOfLastStand.length && !robot.lastStandUpdate) {
            robot.lastStandDuration = (amountOfLastStand.sort((a, b) => b.lastingTime - a.lastingTime)[0]).lastingTime;
            robot.lastStandUpdate = true;
            robot.lastStandThreshold = 0;
            for (let i = 0; i < amountOfLastStand.length; i++) {
                robot.lastStandThreshold += amountOfLastStand[i].immunePercent;
            }
            robot.lastStandThreshold = Math.min(robot.lastStandThreshold, 0.99);
        } else if (!robot.lastStandUpdate) {
            robot.lastStandDuration = 0;
            robot.lastStandUpdate = true;
            robot.lastStandThreshold = 0;
        }
        robot.modules.forEach(module => {
            if (module.shieldRegen) {
                shieldRegenMulti -= module.shieldRegen;
            }
            if ((module.name == "Titan Self-Fix Unit" || module.name == "Self Fix Unit") && module.selfFixRepair && !robot.isFREEZE) {
                if (module.lastRepair == null) module.lastRepair = 0;
                module.lastRepair -= delta;
                if (module.lastRepair <= 0) {
                    module.lastRepair = 1000;
                    changeHealth(robot, {
                        amount: module.selfFixRepair
                    }, true, robot);
                }
            }
        });
        if (!robot.usedLastStand && robot.health <= (robot.lastStandThreshold * robot.maxhealth)) {
            robot.health = (robot.lastStandThreshold * robot.maxhealth);
            robot.effects.push({
                name: "last stand",
                lastTime: robot.lastStandDuration
            });
            robot.killed = false;
            robot.usedLastStand = true;
        }
        let amountOfAmps = robot.effects.filter(e => e.name == "nuclear amps").length;
        let highestMultiAmp = (robot.modules.filter(e => e.name == "Nuclear Amplifier").sort((a, b) => b.nuclearAmp - a.nuclearAmp)[0]);
        if (highestMultiAmp && (robot.oldAmountOfAmps != null || robot.oldAmountOfAmps != undefined)) {
            highestMultiAmp = highestMultiAmp.nuclearAmp;
            if (robot.abilities.length) {
                for (let i = 0; i < robot.abilities.length; i++) {
                    let ability = robot.abilities[i];
                    if (ability.dmg) {
                        ability.dmg /= 1 + (highestMultiAmp * robot.oldAmountOfAmps);
                        ability.dmg *= 1 + (highestMultiAmp * amountOfAmps);
                    }
                    if (ability.dotDamage) {
                        ability.dotDamage /= 1 + (highestMultiAmp * robot.oldAmountOfAmps);
                        ability.dotDamage *= 1 + (highestMultiAmp * amountOfAmps);
                    }
                }
            }
            let drone = undefined;

            if (robot.drones.length) {
                for (let i = 0; i < robot.drones.length; i++) {
                    let ahah = robot.drones[i].abilities.find(e => e.weapon);
                    if (ahah) {
                        ahah.dmg /= 1 + (highestMultiAmp * robot.oldAmountOfAmps);
                        ahah.dmg *= 1 + (highestMultiAmp * amountOfAmps);
                    }
                }
            }

            robot.weapons.forEach(item => {
                item.dmg /= 1 + (highestMultiAmp * robot.oldAmountOfAmps);
                item.dmg *= 1 + (highestMultiAmp * amountOfAmps);
            });
        }
        robot.oldAmountOfAmps = amountOfAmps;
        return {
            shieldRegenMulti: shieldRegenMulti
        };
    }
    function drawShieldBars(robot) {
        document.getElementById("shields").innerHTML = "";
        let canDo = robot.shields.filter(e => e.type != "normal");
        for (let i = 0; i < canDo.length; i++) {
            let shield = canDo[i];
            if (i > 5) break;
            document.getElementById("shields").innerHTML += `
            <div style="opacity: ${shield.notActive ? .4 : 1}; position: absolute; top: ${30 * i}px; left: 10px; width: 300px; height: 25px; background-color: rgb(0, 0, 0, 0.2); border: solid; border-color: #fff; border-width: 1px;">
            <div style="position: absolute; top: 0px; left: 0px; width: ${shield.type == "purple normal" ? Math.min(100, 100 * (shield.health / shield.limit)) : shield.type == "purple" ? 100 : (100 * (shield.health / shield.maxhealth))}%; height: 100%; background-color: ${shield.type == "yellow" ? "#ffff00" : shield.type == "purple" || shield.type == "purple normal" ? "#800080" : "#02ccaa"};">
            </div>
            <div style="display: ${shield.type == "purple" || shield.type == "purple normal" ? "none" : "block"}; position: absolute; top: 0px; left: 5px; font-size: 17px;">
            ${removeDecimals(shield.health)}
            </div>
            </div>
            `;
        }
    }
    var shieldPowerLevel = {
        "normal": 0,
        "energy": 1,
        "yellow": 2,
        "purple": 3,
        "purple normal": 3
    }
    function doShieldsStuff(robot, delta, { shieldRegenMulti, isAlly }) {
        let shields = robot.shields.sort((a, b) => shieldPowerLevel[b.type] - shieldPowerLevel[a.type]);
        for (let i = 0; i < shields.length; i++) {
            let shield = shields[i];
            if (shield) {
                if (shield.regen) {
                    if (shield.lastRegen == null) shield.lastRegen = false;
                    if (Date.now() - shield.lastRegen >= (5e3 * robot.shieldRegen * shieldRegenMulti * ((robot.name == "Ultimate Brown Pentagon" || robot.name == "Brown Pentagon") && robot.abilities.find(e => e.mode == 1) ? .1 : 1))) {
                        shield.lastRegen = Date.now();
                        shield.health += shield.maxhealth * shield.regen;
                    }
                    if (shield.health > shield.maxhealth) {
                        shield.health = shield.maxhealth;
                    }
                }
                if (shield.health == shield.maxhealth && shield.baseShield && robot.name == "Cyan Pentagon") {
                    if (shield.lastRegenPlayer == null) shield.lastRegenPlayer = 0;
                    shield.lastRegenPlayer -= delta;
                    if (shield.lastRegenPlayer <= 0) {
                        shield.lastRegenPlayer = 1e3;
                        changeHealth(robot, {
                            amount: robot.maxhealth * 0.05
                        }, true, robot);
                    }
                }
                if (shield.health < 0) {
                    shield.health = 0;
                }
                if (shield.lastTime) {
                    shield.lastTime -= delta;
                    if (shield.lastTime <= 0) {
                        if (shield.absorption) {
                            let health = shield.health;
                            changeHealth(robot, {
                                amount: health * .5
                            }, false, robot);
                            let asdasd = robot.shields.find(e => e.Absorption);
                            if (asdasd) {
                                asdasd.kill = false;
                                asdasd.maxhealth += health;
                                asdasd.health += health;
                            } else {
                                robot.shields.push({
                                    type: "yellow",
                                    health: health,
                                    Absorption: true,
                                    maxhealth: health,
                                    regen: 0
                                });
                            }
                        }
                        shield.kill = true;
                    }
                }
                if (!shield.notActive && (shield.health > 0 || shield.type == "purple" || shield.type == "purple normal")) {
                    if (shield.type == "normal" || shield.type == "purple normal") {
                        let touchBullets = projectiles.filter(e => e.isAlly != isAlly && checkIfHit(e, robot, "shield") && Math.getAngleDist((shield.dir + robot.dir) + Math.PI, e.dir) <= shield.angleDist / 2);
                        for (let t = 0; t < touchBullets.length; t++) {
                            let bullet = touchBullets[t];
                            changeHealth(shield, {
                                amount: (bullet.dmg * (bullet.projType == "normal" && shield.type == "normal" ? 2 : 1)) * (shield.type == "purple normal" ? 1 : -1),
                            }, false, bullet.owner);
                            if (bullet.aoeRange) {
                                if (shield.type == "purple normal") {
                                    bullet.dmg = 0;
                                    bullet.kill = true;
                                }
                            } else {
                                bullet.dmg = 0;
                                bullet.kill = true;
                            }
                        }
                    } else {
                        let touchBullets = projectiles.filter(e => e.dmg && !e.bypassShields && e.isAlly != isAlly && e.projType != shield.type && checkIfHit(e, robot, "shield"));
                        for (let t = 0; t < touchBullets.length; t++) {
                            shieldEffects.push({
                                location: robot,
                                scale: robot.scale + 20,
                                dir: Math.atan2(touchBullets[t].y - robot.y, touchBullets[t].x - robot.x),
                                type: shield.type
                            });
                            changeHealth(shield, {
                                amount: (touchBullets[t].dmg * (shield.type == "purple" ? 1 : -1)),
                            }, false, touchBullets[t].owner);
                            touchBullets[t].dmg = 0;
                            touchBullets[t].kill = true;
                        }
                    }
                }
                if ((shield.health <= 0 && shield.type != "purple" && shield.type != "purple normal" && !shield.regen) || shield.kill) {
                    if (!shield.droneShield && (shield.health <= 0 && shield.type != "purple" && shield.type != "purple normal" && !shield.regen) && shield.type == "yellow" && robot.abilities.length && robot.abilities[0].name == "Paladin") {
                        doPaldinStuff(robot, isAlly);
                    } else if (shield.grayOvalShield) {
                        if (shield.health > 0) {
                            robot.grayDamage *= .75;
                        }
                        changeHealth(robot, {
                            amount: shield.repair
                        }, false, robot);
                    }
                    robot.shields.splice(i, 1);
                }
            }
        }
    }
    function checkIfHitByProj(robot, isAlly) {
        let touchBullets = projectiles.filter(e => e.isAlly != isAlly && checkIfHit(e, robot));
        let hasColdPulse = robot.effects.find(e => e.name == "freeze" && e.lastTime > 0);
        let hasLockdown = robot.effects.find(e => e.name == "lockdown" && e.lastTime > 0);
        for (let t = 0; t < touchBullets.length; t++) {
            let bullet = touchBullets[t];
            if (bullet.dmg > 0 && bullet.antiTier4_5) {
                bullet.dmg = antiTier4_5(bullet, robot);
            }
            if (bullet.dmg > 0) {
                if (bullet.dmgPercentage) {
                    bullet.dmg = robot.maxhealth * bullet.dmgPercentage;
                }
                let hadHealth = robot.health > 0;
                if (bullet.knockback) {
                    robot.velx += Math.cos(bullet.dir) * bullet.knockback;
                    robot.vely += Math.sin(bullet.dir) * bullet.knockback;
                }
                if (bullet.fragEffect) {
                    robot.effects.push({
                        neg: true,
                        name: "frag",
                        power: bullet.fragEffect.power,
                        lastTime: bullet.fragEffect.last
                    });
                }
                if (bullet.rustEffect) {
                    if (bullet.rustEffect.effectID ? robot.effects.filter(e => e.name == "rust" && e.effectID == bullet.rustEffect.effectID).length < 30 : true) {
                        robot.effects.push({
                            neg: true,
                            effectID: bullet.rustEffect.effectID,
                            name: bullet.rustEffect.name,
                            power: bullet.rustEffect.power,
                            lastTime: bullet.rustEffect.last
                        });
                    }
                }
                if (bullet.dotEffect) {
                    robot.effects.push({
                        neg: true,
                        name: bullet.dotEffect.name,
                        effectID: bullet.dotEffect.effectID,
                        dmg: bullet.dotEffect.dmg,
                        lastTime: bullet.dotEffect.last,
                        owner: bullet.owner
                    });
                }
                if (bullet.deathmarkEffect) {
                    robot.effects.push({
                        neg: true,
                        name: bullet.deathmarkEffect.name,
                        power: bullet.deathmarkEffect.power,
                        lastTime: bullet.deathmarkEffect.last
                    });
                }
                if (bullet.slowEffect) {
                    robot.effects.unshift({
                        neg: true,
                        name: bullet.slowEffect.name,
                        power: bullet.slowEffect.power,
                        lastTime: bullet.slowEffect.last
                    });
                }
                if (bullet.lockdownEffect && !hasLockdown) {
                    let e = robot.effects.find(e => e.name == bullet.lockdownEffect.name && e.lastTime > 0);
                    if (!e) {
                        robot.effects.push({
                            neg: true,
                            name: bullet.lockdownEffect.name,
                            power: bullet.lockdownEffect.power,
                            lastTime: bullet.lockdownEffect.last
                        });
                    } else {
                        e.power += bullet.lockdownEffect.power;
                        if (e.lastTime < bullet.lockdownEffect.last) {
                            e.lastTime = bullet.lockdownEffect.last;
                        }
                    }
                }
                if (bullet.blastEffect) {
                    let e = robot.effects.find(e => e.name == bullet.blastEffect.name && e.lastTime > 0);
                    if (!e) {
                        robot.effects.push({
                            neg: true,
                            owner: bullet.owner,
                            name: bullet.blastEffect.name,
                            power: bullet.blastEffect.power,
                            lastTime: bullet.blastEffect.last
                        });
                    } else {
                        e.power += bullet.blastEffect.power;
                        e.owner = bullet.owner;
                        if (e.lastTime < bullet.blastEffect.last) {
                            e.lastTime = bullet.blastEffect.last;
                        }
                    }
                }
                if (bullet.freezeEffect && !hasColdPulse) {
                    let e = robot.effects.find(e => e.name == bullet.freezeEffect.name && e.lastTime > 0);
                    if (!e) {
                        robot.effects.push({
                            neg: true,
                            name: bullet.freezeEffect.name,
                            power: bullet.freezeEffect.power,
                            lastTime: bullet.freezeEffect.last
                        });
                    } else {
                        e.power += bullet.freezeEffect.power;
                        if (e.lastTime < bullet.freezeEffect.last) {
                            e.lastTime = bullet.freezeEffect.last;
                        }
                    }
                }
                if (robot.NRS == null) robot.NRS = 0;

                if (bullet.weaponOwner && bullet.weaponOwner.name == "Nuclear Rocket Shot") {
                    robot.NRS++;
                }

                if (!bullet.aoeRange) {
                    changeHealth(robot, {
                        amount: -bullet.dmg * (bullet.weaponOwner && bullet.weaponOwner.name == "Nuclear Rocket Shot" ? (robot.NRS == 1 ? 1 : 2 ** (robot.NRS - 1)) : 1),
                        graydmg: bullet.grayDamageAmount,
                        defensePointsBypass: bullet.defensePointsBypass,
                        bypassReflector: bullet.bypassReflector,
                        motherShipCharge: bullet.motherShipCharge,
                        execute: bullet.execute,
                        maxhealthDamage: bullet.weaponOwner && ["Ultimate Punisher", "Ultimate Destroyer"].includes(bullet.weaponOwner.name) ? true : false
                    }, bullet.owner.isMe, bullet.owner, (bullet.weaponOwner && ["Reaper"].includes(bullet.weaponOwner.name) ? true : false));
                } else {
                    let nearest = getNearest({
                        x: robot.x,
                        y: robot.y,
                        scale: robot.scale
                    }, bullet.aoeRange, bullet.isAlly);
                    nearest.forEach(e => {
                        changeHealth(e, {
                            amount: -bullet.dmg * (bullet.weaponOwner && bullet.weaponOwner.name == "Nuclear Rocket Shot" ? (robot.NRS == 1 ? 1 : 2 ** (robot.NRS - 1)) : 1),
                            graydmg: bullet.grayDamageAmount,
                            defensePointsBypass: bullet.defensePointsBypass,
                            bypassReflector: bullet.bypassReflector,
                            motherShipCharge: bullet.motherShipCharge,
                            execute: bullet.execute
                        }, bullet.owner.isMe, bullet.owner);
                    });
                    bombeffect.push({
                        x: bullet.x,
                        y: bullet.y,
                        scale: 0,
                        color: bullet.weaponOwner && bullet.weaponOwner.cold ? "white" : "",
                        maxScale: bullet.aoeRange
                    });
                }
                if (robot.lastStandThreshold && !robot.usedLastStand) {
                } else if (robot.health <= 0 && hadHealth && !robot.revive) {
                    let player1 = findPlayerBySid(robot.inGameSid);
                    let player2 = findPlayerBySid(bullet.owner.inGameSid);
                    if (player1 && player2) {
                        addLogger(player2, bullet.weaponOwner, player1);
                    }
                }
            }
            bullet.dmg = 0;
            bullet.kill = true;
        }
    }
    function findRobotBySid(sid) {
        for (let i = 0; i < players.length; i++) {
            for (let t = 0; t < players[i].robots.length; t++) {
                let robot = players[i].robots[t];
                if (robot && robot.inGameSid == sid) {
                    return robot;
                }
            }
        }
    }
    function hasPlayers() {
        return player.gameMode == 9 || player.gameMode == 2 || player.gameMode == 4 || player.gameMode == 7;
    }
    function doDamageToPhysicalShields(shields, dmg, doer) {
        for (let i = 0; i < shields.length; i++) {
            if (shields[i].type == "normal" || shields[i].type == "purple normal") {
                changeHealth(shields[i], {
                    amount: dmg * (shields[i].type == "purple normal" ? 1 : -1),
                }, false, doer);
            }
        }
    }
    function getNearest(robot, abilityRange, isAlly, ha) {
        let near = [];
        if (hasPlayers() || (isAlly == false && player.gameMode == 0)) {
            for (let t = 0; t < players.length; t++) {
                let player = players[t].robots[players[t].robotIndex];
                if (player && (ha ? players[t].isAlly == isAlly : players[t].isAlly != isAlly)) {
                    if (Math.hypot(player.y - robot.y, player.x - robot.x) <= abilityRange + player.scale) {
                        /*if (robot == player || (robot == player && robot.abilities.length && robot.abilities[0].name == "Active Support")) {
                            continue;
                        }*/
                        near.push(player);
                    }
                }
            }
        } else if (robot.abilities && robot.abilities.length && robot.abilities[0].name == "Active Support") {
            return [];
        } else {
            if ((robot.name == "Remote Repair" || robot.name == "healfield") && dist(robot.owner, robot) <= abilityRange + robot.owner.scale) {
                return [robot.owner];
            }
            near = enemies.filter(e => Math.hypot(e.y - robot.y, e.x - robot.x) <= abilityRange + e.scale);
        }
        return near;
    }
    function doEffectStuff(robot, delta, isAlly) {
        robot.dotDamage = 0;
        let effectNames = {};
        let lastStand = undefined;
        let slowdownMulti = 1;
        let speedMulti = 1;
        let hasPhaseShift = robot.effects.find(e => e.name == "phase shift");
        if (robot.health <= robot.maxhealth * .3) {
            if (robot.onLowDefense && !robot.effects.find(e => e.name == "defense points" && e.onLowDefense_1)) {
                robot.gaveObjectOnLowEffects_1111 = true;
                robot.effects.push({
                    name: "defense points",
                    onLowDefense_1: true,
                    amount: robot.onLowDefense,
                    lastForever: true,
                    lastTime: 1
                });
            }
            if (robot.onLowSpeed && !robot.effects.find(e => e.name == "speed" && e.onLowSpeed_1)) {
                robot.gaveObjectOnLowEffects_1111 = true;
                robot.effects.unshift({
                    name: "speed",
                    onLowSpeed_1: true,
                    power: robot.onLowSpeed,
                    lastForever: true,
                    lastTime: 1
                });
            }
        } else {
            if (robot.gaveObjectOnLowEffects_1111) {
                robot.effects.forEach(e => {
                    if (e.name == "defense points" || e.name == "speed") {
                        if (e.onLowSpeed_1 || e.onLowDefense_1) {
                            robot.gaveObjectOnLowEffects_1111 = false;
                            e.lastForever = false;
                        }
                    }
                });
            }
        }
        let hasLockdownImmune = robot.effects.find(e => e.name == "lockdown immune");
        let hasSlowdownImmune = robot.effects.find(e => e.name == "slowdown immune");
        let hasFreezeImmune = robot.effects.find(e => e.name == "freeze immune");
        let hasRustImmune = robot.effects.find(e => e.name == "rust immune");
        let hasEMPImmune = robot.effects.find(e => e.name == "anti emp");
        let hasBlindImmune = robot.effects.find(e => e.name == "anti blind");
        let hasSuppressionImmune = robot.effects.find(e => e.name == "anti suppression");
        let DoTEffects = robot.effects.filter(e => e.name == "dot" && !e.AdditionalDamageDependingDoT);
        let hasReflector = robot.effects.find(e => e.name == "reflector" && !e.gottenTheCringeAhhEffect && e.lastTime);
        if (hasReflector) {
            if (robot.drones && robot.drones.length) {
                for (let i = 0; i < robot.drones.length; i++) {
                    if (robot.drones[i].abilities.find(e => e.name == "On Reflector: Shield Break")) {
                        hasReflector.gottenTheCringeAhhEffect = true;
                        robot.effects.push({
                            name: "shield break",
                            lastTime: 15e3
                        });
                    }
                }
            }
        }
        if (robot.drones && robot.drones.length) {
            if (DoTEffects.length) {
                for (let i = 0; i < robot.drones.length; i++) {
                    let hi = robot.drones[i].abilities.find(e => e.name == "Additional Damage Depending DoT");
                    if (hi && robot.effects.filter(e => e.name == "attack" && e.AdditionalDamageDependingDoT).length < hi.limit) {
                        DoTEffects.forEach(e => {
                            e.AdditionalDamageDependingDoT = true;
                            robot.effects.push({
                                name: "attack",
                                AdditionalDamageDependingDoT: true,
                                power: hi.dmgDependingDoT,
                                lastTime: e.lastTime
                            });
                        });
                    }
                }
            }
            if (robot.effects.find(e => e.name == "blind" && e.lastTime > 0)) {
                let hi = robot.drones[0].abilities.find(e => e.name == "On Blind: Remove");
                if (hi) {
                    if (!robot.effects.find(e => e.name == "cooldown_timer" && e.onBlindRemoveDronethingy)) {
                        hasBlindImmune = true;
                        robot.effects.push({
                            name: "anti blind",
                            lastTime: 10e3
                        });
                    }
                }
            }
        }
        robot.blind = false;
        robot.emp = false;
        robot.lockdown = false;
        for (let i = 0; i < robot.effects.length; i++) {
            let effect = robot.effects[i];
            if (effect) {
                let hasCleanse = robot.effects.find(e => e.name == "cleanse" && !e.used);
                if (effect.neg && effect.name != "dot" && !effect.LMAOOOOOKAOSDKASOIDKASDIOAS && robot.negEffectReduction) {
                    effect.LMAOOOOOKAOSDKASOIDKASDIOAS = true;
                    effect.lastTime *= robot.negEffectReduction;
                } else if (effect.name != "cooldown_timer" && !effect.abilityEffect && !effect.neg && !effect.LMAOOOOOKAOSDKASOIDKASDIOAS && robot.increaseDurationOfPositiveEffects) {
                    effect.LMAOOOOOKAOSDKASOIDKASDIOAS = true;
                    effect.lastTime *= (1 + robot.increaseDurationOfPositiveEffects);
                }
                if (effect.oldLastTime == null) effect.oldLastTime = effect.lastTime;
                if (effect.lastTime > 0) {
                    if (!effect.lastForever) effect.lastTime -= delta;
                    if (hasPhaseShift && effect.neg && effect.name != "cooldown_timer") {
                        effect.lastTime = 0;
                        continue;
                    } else if ((effect.name == "freezing" || effect.name == "freeze") && hasFreezeImmune) {
                        effect.lastTime = 0;
                        continue;
                    } else if (effect.name == "rust" && (hasRustImmune || hasCleanse)) {
                        if (hasCleanse && !hasRustImmune) {
                            hasCleanse.lastForever = false;
                            hasCleanse.used = true;
                            hasRustImmune = true;
                            robot.effects.push({
                                name: "rust immune",
                                lastTime: 5e3
                            });
                        }
                        effect.lastTime = 0;
                        continue;
                    } else if (effect.name == "lockdown" && (hasLockdownImmune || hasCleanse)) {
                        if (hasCleanse && !hasLockdownImmune) {
                            hasCleanse.lastForever = false;
                            hasCleanse.used = true;
                            hasLockdownImmune = true;
                            robot.effects.push({
                                name: "lockdown immune",
                                lastTime: 5e3
                            });
                        }
                        effect.lastTime = 0;
                        continue;
                    } else if (effect.name == "slowdown" && (hasSlowdownImmune || hasCleanse)) {
                        if (hasCleanse && !hasSlowdownImmune) {
                            hasCleanse.lastForever = false;
                            hasCleanse.used = true;
                            hasSlowdownImmune = true;
                            robot.effects.push({
                                name: "slowdown immune",
                                lastTime: 5e3
                            });
                        }
                        effect.lastTime = 0;
                        continue;
                    } else if (effect.name == "blind" && (hasBlindImmune || hasCleanse)) {
                        if (hasCleanse && !hasBlindImmune) {
                            hasCleanse.lastForever = false;
                            hasCleanse.used = true;
                            hasBlindImmune = true;
                            robot.effects.push({
                                name: "anti blind",
                                lastTime: 5e3
                            });
                        }
                        effect.lastTime = 0;
                        continue;
                    } else if (effect.name == "emp" && (hasEMPImmune || hasCleanse)) {
                        if (hasCleanse && !hasEMPImmune) {
                            hasCleanse.lastForever = false;
                            hasCleanse.used = true;
                            hasEMPImmune = true;
                            robot.effects.push({
                                name: "anti emp",
                                lastTime: 5e3
                            });
                        }
                        effect.lastTime = 0;
                        continue;
                    } else if (effect.name == "suppression" && (hasSuppressionImmune || hasCleanse)) {
                        if (hasCleanse && !hasSuppressionImmune) {
                            hasCleanse.lastForever = false;
                            hasCleanse.used = true;
                            hasSuppressionImmune = true;
                            robot.effects.push({
                                name: "anti suppression",
                                lastTime: 5e3
                            });
                        }
                        effect.lastTime = 0;
                        continue;
                    } else {
                        let indexName = effect.name;
                        if (effect.name == "cooldown_timer") {
                            effectNames[effect.name + " " + i] = {
                                amount: 1,
                                duration: effect.lastTime,
                                orginal: effect.oldLastTime,
                                neg: effect.neg
                            };
                        } else {
                            indexName += " " + effect.lastForever + " " + effect.isActiveModuleEffect;
                            if (effectNames[indexName] == null) {
                                effectNames[indexName] = {
                                    amount: effect.stacks || 1,
                                    duration: effect.lastTime,
                                    orginal: effect.oldLastTime,
                                    neg: effect.neg
                                };
                                if (effect.name == "dot" || effect.name == "rust") {
                                    effectNames[indexName].neg = true;
                                }
                                if (effect.lastForever || effect.isActiveModuleEffect) {
                                    if (effect.thingyX == null) effect.thingyX = 0;
                                    if (effect.HaThingyX == null) effect.HaThingyX = 1;
                                    if (effect.HaThingyX == 1 && effect.thingyX + (125 * .275 * effect.HaThingyX) >= 125) {
                                        effect.thingyX = 125 - (125 * .275);
                                        effect.HaThingyX = -1;
                                    } else if (effect.HaThingyX == -1 && effect.thingyX <= -(125 * .275)) {
                                        effect.HaThingyX = 1;
                                        effect.thingX = -(125 * .275);
                                    }
                                    effect.thingyX += 0.25 * effect.HaThingyX * delta;
                                    effectNames[indexName].thingyX = effect.thingyX;
                                    effectNames[indexName].lastForever = true;
                                }
                            } else {
                                effectNames[indexName].amount++;
                                effectNames[indexName].duration = effect.lastTime;
                            }
                            if (effectNames[indexName].orginal < effect.lastTime) {
                                effectNames[indexName].orginal = effect.lastTime;
                            }
                        }
                    }
                    if (effect.name == "freeze") {
                        robot.isFREEZE = true;
                    } else if (effect.name == "reflector") {
                        if (effect.abilityEffect == "Ultimate Reflector") {
                            speedMulti = 0;
                        }
                    } else if (effect.name == "dot") {
                        if (effect.dmgOverTime == null) effect.dmgOverTime = 0;
                        effect.dmgOverTime -= delta;
                        robot.dotDamage += (Math.floor(effect.lastTime / 1e3) * effect.dmg) * (robot.dotResistance ? robot.dotResistance : 1);
                        if (effect.dmgOverTime <= 0) {
                            if (effect.owner) {
                                changeHealth(robot, {
                                    amount: -effect.dmg,
                                    isDotDamage: true,
                                    noAmp: effect.noAmp,
                                    graydmg: effect.noGrayDamage ? 0 : .4
                                }, effect.owner.isMe, effect.owner, true);
                            } else {
                                effect.owners.forEach(e => {
                                    let enemy = findRobotBySid(e.owner);
                                    if (!enemy) {
                                        enemy = findEnemyBySid(e.owner);
                                    }
                                    if (enemy) {
                                        changeHealth(robot, {
                                            amount: e.dmg,
                                            isDotDamage: true,
                                            noAmp: effect.noAmp,
                                            graydmg: effect.noGrayDamage ? 0 : .4
                                        }, enemy.isMe, enemy, true);
                                    }
                                });
                            }
                            effect.dmgOverTime = 1000;
                        }
                    } else if (effect.name == "last stand") {
                        if (effect.LOLOL == null) effect.LOLOL = 0;
                        effect.LOLOL += delta;
                        if (effect.LOLOL >= 100) {
                            effect.LOLOL = 0;
                            if (robot.isMe) {
                                if (document.getElementById("lastStand").style.display == "none") {
                                    lastStand = "block";
                                } else {
                                    lastStand = "none";
                                }
                            }
                        }
                    } else if (effect.name == "stealth dash") {
                        if (effect.lastTime >= effect.oldLastTime - 350) {
                            let moveSpeed = 0.02 * robot.reloadMoveMulti * slowdownMulti * speedMulti;
                            robot.velx += Math.cos(effect.dir) * (moveSpeed * delta);
                            robot.vely += Math.sin(effect.dir) * (moveSpeed * delta);
                        }
                        robot.invis = true;
                    } else if (effect.name == "stealth") {
                        robot.invis = true;
                    } else if (effect.name == "dark light") {

                        if (effect.l == null) effect.l = 0;

                        effect.l -= delta;

                        if (effect.l <= 0) {
                            effect.l = 500;

                            let abilityRange = 1200;
                            let near = [];

                            if (hasPlayers()) {
                                for (let t = 0; t < players.length; t++) {
                                    let player = players[t].robots[players[t].robotIndex];
                                    if (player && players[t].isAlly != isAlly) {
                                        if (Math.hypot(player.y - robot.y, player.x - robot.x) <= abilityRange + player.scale) {
                                            near.push(player);
                                        }
                                    }
                                }
                            } else {
                                near = enemies.filter(e => Math.hypot(e.y - robot.y, e.x - robot.x) <= abilityRange + e.scale);
                            }

                            for (let it = 0; it < near.length; it++) {
                                let enemy = near[it];
                                if (enemy) {
                                    enemy.effects.push({
                                        name: "deathmark",
                                        lastTime: 3e3,
                                        power: effect.deathmark
                                    });
                                }
                            }
                        }
                    } else if (effect.name == "slowdown") {
                        slowdownMulti -= effect.power;
                        slowdownMulti = Math.max(slowdownMulti, 0.01);
                    } else if (effect.name == "speed") {
                        speedMulti += effect.power;
                    } else if (effect.name == "lockdown") {
                        robot.lockdown = true;
                    } else if (effect.name == "phase shift") {
                        if (!effect.isActiveModuleEffect) speedMulti += (effect.speed || (robot.name == "Sharanga" ? .5 : 1.5));
                    } else if (effect.name == "dash") {
                        if (effect.dmg || effect.abilityEffect == "Frog Splash") {
                            robot.avoidBuildings = true;
                        }
                        let moveSpeed = ((effect.abilityEffect == "Debut" ? 0.035 : effect.abilityEffect == "Comet Splash" ? 0.0085 : effect.abilityEffect == "Frog Splash" ? 0.03 : 0.015) * (effect.POWER ? effect.POWER : 1));
                        robot.velx += Math.cos(effect.dir) * (moveSpeed * delta);
                        robot.vely += Math.sin(effect.dir) * (moveSpeed * delta);
                    } else if (effect.name == "stampede") {
                        if (!effect.a && (effect.lastTime > 4e3 || robot.name.includes("Ultimate"))) speedMulti += 2;
                        robot.turnDmgIntoDOT = true;
                        if (effect.dmgOverTime == null) effect.dmgOverTime = 0;
                        effect.dmgOverTime -= delta;
                        if (effect.dmgOverTime <= 0 && !effect.a) {
                            effect.dmgOverTime = robot.name.includes("Ultimate") ? 250 : effect.lastTime > 4e3 ? 150 : 300;
                            let abilityRange = 400;
                            bombeffect.push({
                                location: robot,
                                scale: 0,
                                maxScale: abilityRange,
                                color: "stamp"
                            });
                            let near = [];
                            if (hasPlayers()) {
                                for (let t = 0; t < players.length; t++) {
                                    let player = players[t].robots[players[t].robotIndex];
                                    if (player && players[t].isAlly != isAlly) {
                                        if (Math.hypot(player.y - robot.y, player.x - robot.x) <= abilityRange + player.scale) {
                                            near.push(player);
                                        }
                                    }
                                }
                            } else {
                                near = enemies.filter(e => Math.hypot(e.y - robot.y, e.x - robot.x) <= abilityRange + e.scale);
                            }
                            for (let it = 0; it < near.length; it++) {
                                let enemy = near[it];
                                if (enemy) {
                                    let angle = Math.atan2(enemy.y - robot.y, enemy.x - robot.x);
                                    enemy.velx += Math.cos(angle);
                                    enemy.vely += Math.sin(angle);
                                    if (enemy.shields) {
                                        doDamageToPhysicalShields(enemy.shields, effect.dmg, robot);
                                    }
                                    changeHealth(enemy, {
                                        amount: -effect.dmg
                                    }, enemy.isMe, robot, robot.name.includes("Ultimate"));
                                }
                            }
                        }
                    } else if (effect.name == "defense points") {
                        robot.builtInDefensePoints += effect.amount;
                    } else if (effect.name == "Ultimate Reflecting Dash") {
                        robot.builtInDefensePoints += effect.amount;
                        if (effect.delta == null) effect.delta = 0;
                        effect.delta += delta;
                        if (effect.delta <= 1000 && !effect.pressed) {
                            robot.avoidBuildings = true;
                            let moveSpeed = 0.03;
                            robot.velx += Math.cos(effect.dir) * (moveSpeed * delta);
                            robot.vely += Math.sin(effect.dir) * (moveSpeed * delta);
                        } else {
                            speedMulti = 0;
                        }
                    } else if (effect.name == "overload") {
                        speedMulti += 1;
                    } else if (effect.name == "Ultimate Mending") {
                        robot.builtInDefensePoints += 200;
                        speedMulti += 1.5;
                        if (effect.healOverTime == null) effect.healOverTime = 0;
                        effect.healOverTime -= delta;
                        if (effect.healOverTime <= 0) {
                            effect.healOverTime = 500;
                            let amount = robot.maxhealth * .15;
                            robot.grayDamage = Math.max(robot.grayDamage - (amount * .15), 0);
                            changeHealth(robot, {
                                amount: amount
                            }, robot.isMe, robot);
                        }
                    } else if (effect.name == "Castling") {
                        robot.builtInDefensePoints += effect.amount;
                        if (effect.stage == null && effect.oldLastTime - effect.lastTime >= 1e3) {
                            let increase = 1;
                            if (robot.fixedExtraShieldHealthL1 + 1 >= 1) {
                                increase += robot.fixedExtraShieldHealthL1;
                            }
                            let fortifier = robot.modules.filter(e => e.shieldHealth);
                            fortifier.forEach(e => {
                                increase += e.shieldHealth;
                            });
                            let data = robot.baseShielding;
                            let t = (Math.PI * 2) / data.amountOfShields;
                            for (let i = 0; i < data.amountOfShields; i++) {
                                robot.shields.push({
                                    maxhealth: (data.health * increase) / (i == 0 ? 2 : data.amountOfShields),
                                    health: (data.health * increase) / (i == 0 ? 2 : data.amountOfShields),
                                    baseShield: true,
                                    dir: t * i,
                                    angleDist: t,
                                    type: data.type,
                                    regen: data.regen
                                });
                            }
                            effect.stage = 1;
                        } else if (effect.stage == 1) {
                            robot.abilities[0].iconSource = "./images/abilities/full_action.png";
                            speedMulti = 0;
                            if (effect.dngs2 == null) effect.dngs2 = 0;
                            effect.dngs2 += delta;
                            if (effect.dngs2 >= 2e3) {
                                effect.dir = robot.dir;
                                effect.stage++;
                            }
                        } else if (effect.stage == 2) {
                            robot.avoidBuildings = true;
                            robot.abilities[0].iconSource = "./images/abilities/dash.png";
                            let moveSpeed = 0.011 * robot.reloadMoveMulti;
                            robot.velx += Math.cos(effect.dir) * (moveSpeed * delta);
                            robot.vely += Math.sin(effect.dir) * (moveSpeed * delta);
                            if (effect.dngs == null) effect.dngs = 0;
                            effect.dngs += delta;
                            speedMulti = 0;
                            if (effect.dngs >= 6e3) {
                                effect.stage++;
                                if (robot.isMe) transitionProgress = 0;
                                robot.flightVisualData = .15;
                            }
                        } else if (effect.stage == 3) {
                            if (effect.lastTime > 2e3) effect.lastTime = 2e3;
                            robot.abilities[0].iconSource = "./images/weapons/cinder.png";
                            if (effect.dmgOverTime == null) effect.dmgOverTime = 0;
                            effect.dmgOverTime -= delta;
                            if (effect.dmgOverTime <= 0) {
                                effect.dmgOverTime = 150;
                                let abilityRange = 800;
                                bombeffect.push({
                                    location: robot,
                                    scale: 0,
                                    maxScale: abilityRange,
                                    color: "stamp"
                                });
                                let near = [];
                                if (hasPlayers()) {
                                    for (let t = 0; t < players.length; t++) {
                                        let player = players[t].robots[players[t].robotIndex];
                                        if (player && players[t].isAlly != isAlly) {
                                            if (Math.hypot(player.y - robot.y, player.x - robot.x) <= abilityRange + player.scale) {
                                                near.push(player);
                                            }
                                        }
                                    }
                                } else {
                                    near = enemies.filter(e => Math.hypot(e.y - robot.y, e.x - robot.x) <= abilityRange + e.scale);
                                }
                                for (let it = 0; it < near.length; it++) {
                                    let enemy = near[it];
                                    if (enemy) {
                                        let angle = Math.atan2(enemy.y - robot.y, enemy.x - robot.x);
                                        enemy.velx += Math.cos(angle) * .75;
                                        enemy.vely += Math.sin(angle) * .75;
                                        if (enemy.shields) {
                                            doDamageToPhysicalShields(enemy.shields, effect.dmg, robot);
                                        }
                                        changeHealth(enemy, {
                                            amount: -effect.dmg
                                        }, enemy.isMe, robot);
                                    }
                                }
                            }
                        } else {
                            speedMulti = 0;
                            robot.abilities[0].iconSource = "./images/abilities/self_heal.png";
                        }
                    } else if (effect.name == "healing") {
                        if (effect.lastDone == null) effect.lastDone = 0;
                        effect.lastDone -= delta;
                        if (effect.lastDone <= 0) {
                            effect.lastDone = effect.rate;
                            let amount = 0;
                            if (effect.type == "percent") {
                                amount = robot.maxhealth * effect.power;
                            } else if (effect.type == "fixed") {
                                amount = effect.power;
                            }
                            if (effect.grayDamage) {
                                robot.grayDamage = Math.max(0, robot.grayDamage - (amount * effect.grayDamage));
                            }
                            changeHealth(robot, {
                                amount: amount
                            }, false, effect.owner ? effect.owner : robot);
                        }
                    } else if (effect.name == "Blink Support") {
                        speedMulti += .5;
                        robot.builtInDefensePoints += effect.amount;
                    } else if (effect.name == "Matrix") {
                        robot.invis = true;
                        let near = getNearest(robot, robot.scale, isAlly);
                        near.forEach(e => {
                            let angle = Math.atan2(e.y - robot.y, e.x - robot.x);
                            e.velx += Math.cos(angle) * .1;
                            e.vely += Math.sin(angle) * .1;
                            changeHealth(e, {
                                amount: -effect.dmg
                            }, false, robot);
                        });
                        if (effect.dmgOverTime == null) effect.dmgOverTime = 0;
                        effect.dmgOverTime -= delta;
                        if (effect.dmgOverTime <= 0) {
                            effect.dmgOverTime = 200;
                            let abilityRange = 400;
                            bombeffect.push({
                                location: robot,
                                scale: abilityRange + robot.scale,
                                indexM: -1,
                                color: "stamp"
                            });
                            let near = getNearest(robot, abilityRange, isAlly);
                            for (let it = 0; it < near.length; it++) {
                                let enemy = near[it];
                                if (enemy) {
                                    let angle = Math.atan2(enemy.y - robot.y, enemy.x - robot.x);
                                    enemy.velx += Math.cos(angle) * -1.5;
                                    enemy.vely += Math.sin(angle) * -1.5;
                                }
                            }
                        }
                    } else if (effect.name == "Support") {
                        robot.builtInDefensePoints += (robot.name.includes("Ultimate") ? 400 : 150);
                        speedMulti += (robot.name.includes("Ultimate") ? 1.25 : .75);
                        if (effect.las == null) effect.las = 0;
                        effect.las -= delta;
                        if (effect.las <= 0) {
                            effect.las = (robot.name.includes("Ultimate") ? 250 : 500);
                            let abilityRange = (robot.name.includes("Ultimate") ? 500 : 400);
                            bombeffect.push({
                                location: robot,
                                doFaster: true,
                                Color: "rgb(0, 255, 0, .3)",
                                Color2: "#047502",
                                scale: 0,
                                maxScale: abilityRange
                            });
                            let near = [];
                            for (let t = 0; t < players.length; t++) {
                                let player = players[t].robots[players[t].robotIndex];
                                if (player && players[t].isAlly == isAlly) {
                                    if (Math.hypot(player.y - robot.y, player.x - robot.x) <= abilityRange + player.scale) {
                                        near.push(player);
                                    }
                                }
                            }
                            near.forEach(e => {
                                let healing = robot.abilities[0].healingPower;
                                if (robot.name.includes("Ultimate")) {
                                    e.grayDamage = Math.max(0, e.grayDamage - (healing * .15));
                                }
                                changeHealth(e, {
                                    amount: healing
                                }, false, robot);
                            });
                        }
                    } else if (effect.name == "Cannonier") {
                        speedMulti += (robot.name == "Eiffel" ? .75 : 1);
                        robot.avoidBuildings = true;
                        if (effect.stage == 1 || effect.stage == 2) {
                            if (effect.dashLast == null) effect.dashLast = Date.now();
                            if (Date.now() - effect.dashLast <= 250) {
                                let moveSpeed = 0.03;
                                robot.velx += Math.cos(effect.dir) * (moveSpeed * delta);
                                robot.vely += Math.sin(effect.dir) * (moveSpeed * delta);
                            }
                        }
                    } else if (effect.name == "extra health") {
                        if (robot.name == "Dark Tan Circle") {
                            speedMulti += .75;
                        }
                    } else if (effect.name == "blind") {
                        robot.blind = true;
                    } else if (effect.name == "emp") {
                        robot.emp = true;
                    } else if (effect.name == "forcefield") {
                        if (effect.abilityEffect == "Skyward") {
                            robot.avoidBuildings = true;
                            robot.abilitySpeedMulti += 1.5;
                        }
                    } else if (effect.name == "absorption") {
                        let dir = 0;
                        if (effect.weapon1 == null) effect.weapon1 = 0;
                        let dmgMulti = 0;
                        let shield = robot.shields.find(e => e.absorption);
                        if (shield) {
                            dmgMulti += shield.health * .025;
                        }
                        if (effect.weaponSlotThingyAbility == null) effect.weaponSlotThingyAbility = 0;
                        if (effect.weapon2 == null) effect.weapon2 = 0;
                        if (Date.now() - effect.weapon2 >= 150) {
                            effect.weapon2 = Date.now();
                            projectiles.push({
                                x: robot.x,
                                y: robot.y,
                                oldX: robot.x,
                                oldY: robot.y,
                                velx: 0,
                                vely: 0,
                                scale: 25,
                                speed: 0.15,
                                projType: "rocket",
                                dmg: (effect.dmg / 2) + Math.min(dmgMulti, effect.dmg * 2.5),
                                range: 2e3,
                                dir: robot.dir,
                                blastEffect: {
                                    name: "blast",
                                    power: .25,
                                    last: 30e3
                                },
                                color: "./images/bullets/red_bullet.png",
                                isAlly: isAlly,
                                owner: robot,
                                weaponOwner: {
                                    name: "Absorption WPN2",
                                    level: robot.level
                                }
                            });
                        }
                        if (effect.weapon3 == null) effect.weapon3 = 0;
                        if (effect.weaponSlotThingyAbility2 == null) effect.weaponSlotThingyAbility2 = 3;
                        if (Date.now() - effect.weapon3 >= 75) {
                            effect.weapon3 = Date.now();
                            if (effect.weaponSlotThingyAbility2 % 4 == 0) {
                                x = robot.x + Math.cos(robot.dir + 1.57) * (robot.scale - 7.5);
                                y = robot.y + Math.sin(robot.dir + 1.57) * (robot.scale - 7.5);
                            } else if (effect.weaponSlotThingyAbility2 % 4 == 1) {
                                x = robot.x + Math.cos(robot.dir + 0.39) * (robot.scale - 7.5);
                                y = robot.y + Math.sin(robot.dir + 0.39) * (robot.scale - 7.5);
                            } else if (effect.weaponSlotThingyAbility2 % 4 == 2) {
                                x = robot.x + Math.cos(robot.dir - 0.39) * (robot.scale - 7.5);
                                y = robot.y + Math.sin(robot.dir - 0.39) * (robot.scale - 7.5);
                            } else {
                                x = robot.x + Math.cos(robot.dir - 1.57) * (robot.scale - 7.5);
                                y = robot.y + Math.sin(robot.dir - 1.57) * (robot.scale - 7.5);
                            }
                            effect.weaponSlotThingyAbility2++;
                            if (robot.isMe) {
                                let offsetX = x - offset.x;
                                let offsetY = y - offset.y;
                                let mosX = (mouseX / window.innerWidth) * maxScreen.x;
                                let mosY = (mouseY / window.innerHeight) * maxScreen.y;
                                dir = Math.atan2(mosY - offsetY, mosX - offsetX);
                            } else if (robot.target) {
                                dir = Math.atan2(robot.target.y - y, robot.target.x - x);
                            }
                            projectiles.push({
                                x: x,
                                y: y,
                                oldX: x,
                                oldY: y,
                                velx: 0,
                                vely: 0,
                                scale: 25,
                                speed: 0.2,
                                projType: "normal",
                                dmg: (effect.dmg * .25) + Math.min(dmgMulti, effect.dmg * 2.5),
                                range: 2e3,
                                dir: dir,
                                color: "./images/bullets/bullet.png",
                                isAlly: isAlly,
                                owner: robot,
                                changeDirSpeed: 0.045,
                                autoTargetData: {
                                    type: "nearest",
                                    range: robot.scale * 3,
                                    better: true
                                },
                                weaponOwner: {
                                    name: "Absorption WPN3",
                                    level: robot.level
                                }
                            });
                        }
                        if (Date.now() - effect.weapon1 >= 50) {
                            effect.weapon1 = Date.now();
                            if (effect.weaponSlotThingyAbility % 4 == 0) {
                                x = robot.x + Math.cos(robot.dir + 1.57) * (robot.scale - 7.5);
                                y = robot.y + Math.sin(robot.dir + 1.57) * (robot.scale - 7.5);
                            } else if (effect.weaponSlotThingyAbility % 4 == 1) {
                                x = robot.x + Math.cos(robot.dir + 0.39) * (robot.scale - 7.5);
                                y = robot.y + Math.sin(robot.dir + 0.39) * (robot.scale - 7.5);
                            } else if (effect.weaponSlotThingyAbility % 4 == 2) {
                                x = robot.x + Math.cos(robot.dir - 0.39) * (robot.scale - 7.5);
                                y = robot.y + Math.sin(robot.dir - 0.39) * (robot.scale - 7.5);
                            } else {
                                x = robot.x + Math.cos(robot.dir - 1.57) * (robot.scale - 7.5);
                                y = robot.y + Math.sin(robot.dir - 1.57) * (robot.scale - 7.5);
                            }
                            effect.weaponSlotThingyAbility++;
                            if (robot.isMe) {
                                let offsetX = x - offset.x;
                                let offsetY = y - offset.y;
                                let mosX = (mouseX / window.innerWidth) * maxScreen.x;
                                let mosY = (mouseY / window.innerHeight) * maxScreen.y;
                                dir = Math.atan2(mosY - offsetY, mosX - offsetX);
                            } else if (robot.target) {
                                dir = Math.atan2(robot.target.y - y, robot.target.x - x);
                            }
                            projectiles.push({
                                x: x,
                                y: y,
                                oldX: x,
                                oldY: y,
                                velx: 0,
                                vely: 0,
                                scale: 25,
                                speed: 0.2,
                                projType: "energy",
                                dmg: effect.dmg + Math.min(dmgMulti, effect.dmg * 2.5),
                                range: 2e3,
                                dir: dir,
                                color: "./images/bullets/energy_bullet.png",
                                isAlly: isAlly,
                                owner: robot,
                                weaponOwner: {
                                    name: "Absorption WPN1",
                                    level: robot.level
                                }
                            });
                        }
                    } else if (effect.name == "stove") {
                        if (effect.dmgOverTime == null) effect.dmgOverTime = 0;
                        effect.dmgOverTime -= delta;
                        if (effect.dmgOverTime <= 0) {
                            effect.dmgOverTime = (1e3 / 3);
                            let enemies = getNearest(robot, 800, isAlly);
                            enemies.forEach(e => {
                                changeHealth(e, {
                                    amount: -effect.dmg,
                                    defensePointsBypass: 0
                                }, false, robot);
                            });
                        }
                    } else if (effect.name == "Blink") {
                        robot.builtInDefensePoints += 100 + (robot.blinkVV2 ? 150 : 0);
                        speedMulti += .75;
                    }
                }
                if (effect.lastTime <= 0) {
                    if (effect.name == "reflector" && effect.abilityEffect == "Ultimate Reflector") {
                        robot.effects.push({
                            name: "healing",
                            power: 25e3,
                            type: "fixed",
                            rate: 1e3,
                            lastTime: 4e3
                        });
                    }
                    if (effect.name == "Clain Blink" || effect.name == "Blink") {
                        doAbilityEndFunction(robot, 0, effect, robot.abilities.find(e => e.name == effect.name));
                    }
                    if (effect.name == "forcefield") {
                        if (effect.abilityEffect == "Skyward") {
                            let weapon = robot.weapons.find(e => e.name == "Skyward");
                            weapon.notActive = true;
                            weapon.ammo = 0;
                        }
                    }
                    if (effect.name == "Cannonier" || effect.name == "extra health") {
                        if (effect.name == "extra health" && robot.name == "Dark Tan Circle") {
                            robot.color = "#7a6951";
                        }
                        if (effect.health > 0) {
                            robot.maxhealth -= effect.maxhealth;
                            robot.grayDamage -= (effect.grayDamage || 0);
                            effect.health = 0;
                        }
                        if (effect.abilityEffect) {
                            if (robot.isMe) {
                                transitionProgress = 0;
                            }
                            robot.flightVisualData = 0.0001;
                            for (let i = 0; i < robot.weapons.length; i++) {
                                let weapon = robot.weapons[i];
                                if (weapon.targetedWeaponsToUse) {
                                    weapon.notActive = true;
                                }
                            }
                        }
                    }
                    if (effect.name == "Castling") {
                        doAbilityEndFunction(robot, delta, undefined, robot.abilities.find(e => e.name == effect.name));
                    }
                    if (effect.name == "Matrix") {
                        let near = getNearest(robot, 800, isAlly);
                        bombeffect.push({
                            location: robot,
                            doFaster: true,
                            blastttt: false,
                            scale: 0,
                            maxScale: 800
                        });
                        near.forEach(e => {
                            let angle = Math.atan2(e.y - robot.y, e.x - robot.x);
                            e.velx += Math.cos(angle) * 8;
                            e.vely += Math.sin(angle) * 8;
                            changeHealth(e, {
                                amount: -effect.dmg * 5
                            }, false, robot);
                            e.effects.push({
                                neg: true,
                                name: "suppression",
                                power: .1,
                                lastTime: 10e3
                            });
                        });
                    }
                    if (effect.name == "Blink Support") {
                        let healthIncreased = effect.healthIncreased;
                        let multi = robot.health / robot.maxhealth;
                        let multi2 = robot.grayDamage / robot.maxhealth;
                        robot.maxhealth -= healthIncreased;
                        robot.health = multi * robot.maxhealth;
                        robot.grayDamage = multi2 * robot.maxhealth;
                    }
                    if (effect.name == "stampede" && !effect.a && robot.name == "Ultimate Tan Circle") {
                        let dotStacks = robot.effects.filter(e => e.name == "dot" && e.lastTime > 0);

                        for (let t = 0; t < dotStacks.length; t++) {
                            let DoT = dotStacks[t];
                            DoT.lastTime = 0;

                            robot.effects.push({
                                name: "block",
                                lastTime: 30e3
                            });
                        }
                    }
                    if (effect.name == "overload" || (effect.dmg && effect.name == "dash")) {
                        let near = [];
                        let abilityRange = effect.name == "overload" ? effect.abilityEffect == "Comet Splash" ? 600 : effect.abilityEffect == "Blast Wave" ? 800 : 500 : effect.abilityEffect == "Frog Splash" ? 600 : 900;
                        bombeffect.push({
                            location: robot,
                            doFaster: true,
                            speed: effect.abilityEffect == "Blast Wave" ? 3.5 : undefined,
                            blastttt: effect.name == "overload" ? false : true,
                            scale: 0,
                            maxScale: abilityRange
                        });
                        if (hasPlayers()) {
                            for (let t = 0; t < players.length; t++) {
                                let player = players[t].robots[players[t].robotIndex];
                                if (player && players[t].isAlly != isAlly) {
                                    if (Math.hypot(player.y - robot.y, player.x - robot.x) <= abilityRange + player.scale) {
                                        near.push(player);
                                    }
                                }
                            }
                        } else {
                            near = enemies.filter(e => Math.hypot(e.y - robot.y, e.x - robot.x) <= abilityRange + e.scale);
                        }
                        for (let i = 0; i < near.length; i++) {
                            let enemy = near[i];
                            if (enemy) {
                                let angle = Math.atan2(enemy.y - robot.y, enemy.x - robot.x);
                                enemy.velx += Math.cos(angle) * (effect.name == "overload" ? effect.abilityEffect == "Blast Wave" ? 2.5 : 1.5 : 5);
                                enemy.vely += Math.sin(angle) * (effect.name == "overload" ? effect.abilityEffect == "Blast Wave" ? 2.5 : 1.5 : 5);
                                changeHealth(enemy, {
                                    amount: -effect.dmg,
                                    defensePointsBypass: effect.abilityEffect == "Blast Wave" ? 0 : effect.abilityEffect == "Frog Splash" ? 0 : undefined
                                }, enemy.isMe, robot);
                                if (enemy.shields) {
                                    doDamageToPhysicalShields(enemy.shields, effect.dmg, robot);
                                }
                                if (robot.cometSplashV2) {
                                    enemy.effects.push({
                                        neg: true,
                                        name: "emp",
                                        lastTime: 6e3
                                    });
                                }
                                if (effect.abilityEffect == "Frog Splash") {
                                    enemy.effects.push({
                                        neg: true,
                                        name: "suppression",
                                        power: .6,
                                        lastTime: 10e3,
                                        owner: robot
                                    });
                                }
                                if (effect.dotDamage) {
                                    enemy.effects.push({
                                        neg: true,
                                        name: "dot",
                                        dmg: effect.dotDamage,
                                        lastTime: 10e3,
                                        owner: robot
                                    });
                                }
                            }
                        }
                    }
                    if (effect.isAbility || effect.abilityEffect) {
                        for (let iasd = 0; iasd < robot.abilities.length; iasd++) {
                            let ability = robot.abilities[iasd];
                            if (ability.oldIconSource) {
                                ability.iconSource = ability.oldIconSource;
                            }
                        }
                    }
                }
            }
        }
        let blastEffectThingy = robot.effects.find(e => e.name == "blast" && e.power >= 1 && e.lastTime > 0)
        if (blastEffectThingy) {
            let damage = Math.floor(blastEffectThingy.power) * 20e3;
            let blastEffectOwner = blastEffectThingy.owner;
            blastEffectThingy.power = blastEffectThingy.power - Math.floor(blastEffectThingy.power);
            if (blastEffectThingy.power <= 0) {
                blastEffectThingy.lastTime = 0;
            }
            let nearest = getNearest(robot, 300 + robot.scale, !isAlly);
            nearest.forEach(e => {
                doDamageToPhysicalShields(e.shields, damage, blastEffectOwner);
                changeHealth(e, {
                    amount: -(damage),
                    graydmg: 0,
                    bypassReflector: true,
                    damageTypeName: "BLAST EFFECT"
                }, blastEffectOwner.isMe, blastEffectOwner, true);
            });
            bombeffect.push({
                location: robot,
                doFaster: true,
                scale: 0,
                maxScale: 300 + robot.scale
            });
        }
        let freezingEffect = robot.effects.find(e => e.name == "freezing" && e.power >= 1 && e.lastTime > 0);
        if (freezingEffect) {
            freezingEffect.power = 0;
            freezingEffect.lastTime = 0;
            robot.effects.push({
                name: "freeze",
                neg: true,
                lastTime: 5e3
            });
        }
        let lockdownEffect = robot.effects.find(e => e.name == "lockdown acc" && e.power >= 1 && e.lastTime > 0);
        if (lockdownEffect) {
            lockdownEffect.power = 0;
            lockdownEffect.lastTime = 0;
            robot.effects.push({
                name: "lockdown",
                neg: true,
                lastTime: 6e3
            });
        }
        slowdownMulti = Math.max(slowdownMulti, 0.01);
        for (let i = 0; i < robot.effects.length; i++) {
            let effect = robot.effects[i];
            if (effect) {
                if (effect.lastTime <= 0) {
                    robot.effects.splice(i, 1);
                }
            }
        }
        let repairampps = robot.effects.find(e => e.name == "repair amp");
        if (repairampps) {
            let percent = 0.0003 * repairampps.stacks;
            if (robot.LASTREPAIRAMPHEALHA == null) robot.LASTREPAIRAMPHEALHA = 0;
            robot.LASTREPAIRAMPHEALHA -= delta;
            if (robot.LASTREPAIRAMPHEALHA <= 0) {
                robot.LASTREPAIRAMPHEALHA = 1e3;
                changeHealth(robot, {
                    amount: percent * robot.maxhealth
                }, robot.isMe, robot);
            }
        }
        if (robot.abilities.length) {
            for (let i = 0; i < robot.abilities.length; i++) {
                let ability = robot.abilities[i];
                let effect = robot.effects.find(e => e.abilityEffect == ability.name);
                if ((robot.isFREEZE || robot.emp) && effect && ability.abilityLast != null && ability.abilityLast != 0) {
                    ability.abilityLast = effect.lastTime;
                }
            }
        }
        return {
            effectNames: effectNames,
            lastStand: lastStand,
            slowdownMulti: slowdownMulti,
            speedMulti: speedMulti
        };
    }
    function getEffectIcon(name) {
        let index1 = name.split(" ");
        let index = "";
        for (let i = 0; i < index1.length - 2; i++) {
            index += index1[i];
            if (i + 1 < index1.length - 2) index += " ";
        }
        if (index == "blast") {
            return {
                name: "bomb"
            };
        } else if (index == "repair amp") {
            return "./images/modules/repair_amplifier.png";
        } else if (index == "overload" || index == "stove") {
            return "./images/weapons/cinder.png";
        } else if (index == "defense points") {
            return "./images/abilities/full_action.png";
        } else if (index == "stampede") {
            return "./images/abilities/stampede.png";
        } else if (index == "freezing") {
            return "./images/weapons/rime.png";
        } else if (index == "dot") {
            return "./images/weapons/sting.png";
        } else if (index == "last stand") {
            return "./images/modules/last_stand.png";
        } else if (index == "phase shift") {
            return "./images/abilities/phase_shift.png";
        } else if (index == "dash") {
            return "./images/abilities/dash.png";
        } else if (index == "stealth dash" || index == "stealth") {
            return "./images/stealth.png";
        } else if (index == "slowdown") {
            return "./images/slowdown_effect.png";
        } else if (index == "rust") {
            return "./images/rust.png";
        } else if (index == "Ultimate Mending" || index == "healing" || index == "Support") {
            return "./images/abilities/self_heal.png";
        } else if (index == "Castling") {
            return "./images/abilities/castling.png";
        } else if (index == "Immune Amplifier") {
            return "./images/modules/immune_amplifier.png";
        } else if (index == "Matrix") {
            return "./images/abilities/matrix.png";
        } else if (index == "nuclear amps" || index == "attack") {
            return {
                name: "destruction"
            }
        } else if (index == "suppression") {
            return "./images/icons/suppression.png";
        } else if (name.includes("cooldown_timer")) {
            return {
                name: "timer"
            };
        } else if (index == "speed") {
            return {
                name: "speed"
            };
        } else if (index == "deathmark") {
            return {
                name: "skull"
            };
        } else if (index == "slowdown immune") {
            return "./images/icons/slowdown_immune.png";
        } else if (index == "freeze immune") {
            return "./images/icons/freeze_immune.png";
        } else if (index == "rust immune") {
            return "./images/icons/rust_immune.png";
        } else if (index == "Blink Support" || index == "Cannonier") {
            return "./images/abilities/shield_t.png";
        } else if (index == "anti defense mig") {
            return "./images/icons/anti_defense_mitigation.png";
        } else if (index == "Ultimate Reflecting Dash") {
            return "./images/abilities/ultimate_reflecting_dash.png";
        } else if (index == "frag") {
            return "./images/fragility.png";
        } else if (index == "defense amp") {
            return "./images/modules/defense_amplifier.png";
        } else if (index == "Clain Blink") {
            return "./images/abilities/clain_blink.png";
        } else if (index == "forcefield") {
            return "./images/forcefield.png";
        } else if (index == "extra health") {
            return "./images/modules/heavy_armor_plating.png";
        } else if (index == "blind") {
            return "./images/icons/blind.png";
        } else if (index == "anti blind") {
            return "./images/icons/anti_blind.png";
        } else if (index == "emp") {
            return "./images/icons/emp.png";
        } else if (index == "anti emp") {
            return "./images/icons/anti_emp.png";
        } else if (index == "anti suppression") {
            return "./images/icons/anti_suppression.png";
        } else if (index == "block") {
            return "./images/icons/block.png";
        } else if (index == "reflector") {
            return "./images/icons/reflector.png";
        } else if (index == "shield break") {
            return "./images/icons/shield_break.png";
        } else if (index == "absorption" || index == "Absorber") {
            return "./images/abilities/absorption.png";
        } else if (index == "track") {
            return "./images/weapons/reaper.png";
        } else if (index == "cleanse") {
            return "./images/icons/cleanse.png";
        } else if (index == "defense breach") {
            return "./images/abilities/dismantle.png";
        } else if (index == "counter suppression") {
            return "./images/icons/counter_suppression.png";
        } else if (index == "lockdown" || index == "lockdown acc") {
            return "./images/icons/lockdown.png";
        } else if (index == "Blink") {
            return "./images/abilities/blink.png";
        } else if (index == "lockdown immune") {
            return "./images/icons/lockdown_immune.png"
        } else {
            return "./images/abilities/cold_pulse.png";
        }
    }
    function drawEffect(MATH1HA___, effect, i, INDEXXXXXX) {
        let string = (effect.duration / 1000).toString();
        let DOTINDEXXX = string.indexOf('.');
        if (DOTINDEXXX == -1) {
            string += ".0";
        } else string = string.slice(0, DOTINDEXXX + 2);
        if (effect.duration >= 1e100) {
            string = "";
        }
        if (i == "dot") {
            effect.neg = true;
        }
        document.getElementById("LMAOLMAOLMAOLMAO").innerHTML += `
        <div style="position: absolute; left: 20px; width: 125px; height: 43px; background-color: rgb(0, 0, 0, 0.35); bottom: ${(48 * INDEXXXXXX) + (MATH1HA___ + 15)}px; ${effect.amount > 1 ? `background-repeat: no-repeat; background-size: 100px 43px; background-image: linear-gradient(to right, ${effect.neg ? "rgba(255, 0, 0, 0.6)" : "rgba(0, 0, 255, 0.6)"}, rgba(0, 0, 0, 0));` : ""} border-radius: 2px; overflow: hidden;">
        <div style="position: absolute; top: 0px; left: ${effect.amount >= 100 ? 40 : effect.amount >= 10 ? 30 : effect.amount > 1 ? 20 : 5}px; height: 40px; width: 40px; background-size: 40px 40px; ${typeof getEffectIcon(i) == "object" ? "" : `background-image: url('${getEffectIcon(i)}');`}">
        ${typeof getEffectIcon(i) == "object" ? `
        <span class="material-symbols-outlined" style="color: #fff; font-size: 40px;">
        ${getEffectIcon(i).name}
        </span>
        ` : ""}
        </div>
        <div style="position: absolute; display: ${effect.amount <= 1 ? "none" : "block"}; top: 9px; left: 5px; color: #fff;">
        ${effect.amount}
        </div>
        <div style="position: absolute; display: ${effect.lastForever ? "none" : "block"}; top: 9px; right: 5px; color: #fff;">
        ${!string.includes("-") ? string : ""}
        </div>
        <div style="position: absolute; bottom: 0px; left: 0px; height: 3px; width: 100%; background-color: ${effect.thingyX != null || effect.thingyX != undefined ? "rgb(255, 255, 255, 0.4)" : "rgb(255, 255, 255, 0.6)"};">
        <div style="position: absolute; bottom: 0px; left: ${effect.thingyX || 0}px; height: 3px; width: ${effect.thingyX != null || effect.thingyX != undefined ? 55 : ((effect.duration / effect.orginal) * 100)}%; ${effect.thingyX != undefined || effect.thingyX != null ? `background-image: linear-gradient(to right, rgba(255, 255, 255, 0.3), ${!effect.neg ? "#00ffff" : "#f00"}, rgba(255, 255, 255, .3));` : `background-color: ${!effect.neg ? "#00f" : "#f00"};`}">
        </div>
        </div>
        </div>
        `;
    }
    function drawEffects(MATH1HA___, effectNames) {
        let INDEXXXXXX = 0;
        let negativeEffects = {};
        let nonNegativeEffects = {};
        for (let i in effectNames) {
            if (effectNames[i].neg) {
                negativeEffects[i] = effectNames[i];
            } else {
                nonNegativeEffects[i] = effectNames[i];
            }
        }
        for (let i in negativeEffects) {
            if (INDEXXXXXX < 7) {
                drawEffect(MATH1HA___, negativeEffects[i], i, INDEXXXXXX);
            }
            INDEXXXXXX++;
        }
        for (let i in nonNegativeEffects) {
            if (INDEXXXXXX < 7) {
                drawEffect(MATH1HA___, nonNegativeEffects[i], i, INDEXXXXXX);
            }
            INDEXXXXXX++;
        }
        if (INDEXXXXXX > 7) {
            document.getElementById("LMAOLMAOLMAOLMAO").innerHTML += `
            <div style="position: absolute; left: 20px; width: 125px; bottom: ${(48 * 7) + (MATH1HA___ + 15)}px;">
            +${INDEXXXXXX - 7} More
            </div>
            `;
        }
    }
    function drawWeaponUI(robot, delta) {
        let index = 0;
        let doWeaponss = robot.weapons.sort((a, b) => a.slot - b.slot);
        for (let i = 0; i < doWeaponss.length; i++) {
            let weapon = doWeaponss[i];
            let rgb = "";
            if (weapon.name == "Atomizer" || weapon.name == "Nucleon" || weapon.name == "Igniter" || weapon.name == "Discharger" || weapon.name == "Inferno" || weapon.name == "Pyro") {
                let colorValue = ((weapon.firedTime / weapon.overheatTime) * 100);
                rgb = `rgb(${Math.min(255, Math.floor((colorValue) * 255 / 100))}, ${Math.min(235, Math.floor((100 - colorValue) * 235 / 100))}, 0)`;
            } else if (weapon.name == "Lance" || weapon.name == "Glaive") {
                if (weapon.ammoFired == null) weapon.ammoFired = 0;
                let colorValue = (((weapon.ammoFired % 4) / 3) * 100);
                rgb = `rgb(${Math.min(255, Math.floor((colorValue) * 255 / 100))}, ${Math.min(235, Math.floor((100 - colorValue) * 235 / 100))}, 0)`;
            }
            let thingy = undefined;
            if (weapon.name == "Veyron" || weapon.name == "Evora" || weapon.name == "Disintegrator" || weapon.name == "Havoc") {
                thingy = (weapon.firedTime / 2e3) * 100;
            } else if (weapon.name == "Discordia" || weapon.name == "Tumultus" || weapon.name == "Kramola" || weapon.name == "Razdor") {
                thingy = (weapon.firedTime / 2e3) * 100;
            } else if (weapon.name == "Sorrow" || weapon.name == "Grief") {
                thingy = (weapon.firedTime / 2e3) * 100;
            } else if (weapon.name == "Ultimate Punisher" || weapon.name == "Ultimate Destroyer") {
                thingy = (weapon.firedTime / 2e3) * 100;
            }
            document.getElementById("weaponThing").innerHTML += `
            <div style="opacity: ${weapon.disabled || weapon.notActive ? .4 : 1}; position: absolute; bottom: ${80 * (index >= 4 ? index - 4 : index)}px; left: ${index >= 4 ? 320 : 0}px; width: 200px; height: 75px; margin-top: 20px;">
            <div id="weaponICON${i}" style="position: absolute; z-index: 2; top: 0px; left: 0px; background-color: #404040; border-radius: 100%; width: 75px; height: 75px;">
            </div>
            <div style="display: ${thingy != undefined ? "block" : "none"}; position: absolute; top: 33px; left: 50px; background-color: #404040; border-radius: 12px; width: 210px; height: 30px;">
            <div style="width: ${thingy}%; height: 100%; border-radius: 12px; background-color: #00ffff;">
            </div>
            </div>
            <div style="position: absolute; top: 23px; left: 60px; background-color: #404040; border-radius: 12px; width: 250px; height: 30px;">
            <div style="width: ${weapon.overheatTime ? ((weapon.firedTime / weapon.overheatTime) * 100) : ((weapon.ammo / weapon.maxammo) * 100)}%; height: 100%; border-radius: 12px; background-color: ${(weapon.overheatTime || weapon.name == "Lance" || weapon.name == "Glaive") ? rgb : "#fff"};">
            </div>
            <div id="weaponReloadNumber${i}" style="position: absolute; right: 5px; top: 5.5px; font-size: 12px; color: #ffff00;">
            </div>
            </div>
            </div>
            `;
            index++;
        }
    }
    Math.getAngleDist = (a, b) => {
        let angleDifference = Math.abs(b - a) % (2 * Math.PI);
        return angleDifference > Math.PI ? (2 * Math.PI) - angleDifference : angleDifference;
    };
    function doLaserDamage(robot, weapon, taker, dmgMulti) {
        dmgMulti = dmgMulti || 1;
        if (["Leiming", "Fengbao"].includes(weapon.name) ? false : taker.invis) return;
        let shieldBreak = robot.effects.find(e => e.name == "shield break" && e.lastTime > 0);
        if (taker.shields) {
            for (let i = 0; i < taker.shields.length; i++) {
                let shield = taker.shields[i];
                if (shield && !shield.notActive && (shield.health > 0 || shield.type == "purple" || shield.type == "purple normal")) {
                    if (shield.type == "normal" || shield.type == "purple normal") {
                        if (Math.getAngleDist((shield.dir + taker.dir) + Math.PI, robot.dir) <= shield.angleDist / 2) {
                            changeHealth(shield, {
                                amount: (weapon.dmg * (shield.type == "normal" && weapon.projType == "normal" ? 2 : 1)) * (shield.type == "purple normal" ? 1 : -1),
                            }, false, robot);
                            return;
                        }
                    } else if (!shieldBreak) {
                        shieldEffects.push({
                            location: taker,
                            scale: taker.scale + 20,
                            dir: Math.atan2(robot.y - taker.y, robot.x - taker.x),
                            type: shield.type
                        });
                        changeHealth(shield, {
                            amount: (weapon.dmg * (shield.type == "purple" ? 1 : -1)),
                        }, false, robot);
                        return;
                    }
                }
            }
        }
        let hasHealth = taker.health > 0;
        let dmgIncrease = 1;
        if (taker.tier == 4) {
            if ((weapon.name == "Fulgur" || weapon.name == "Tonans")) {
                dmgIncrease = 3.25;
            } else if (weapon.name == "Skyward") {
                dmgIncrease = 2.5;
            }
            if (weapon.name == "Skyward" || weapon.name == "Fulgur" || weapon.name == "Tonans") {
                if (weapon.name == "Fulgur" || weapon.name == "Tonans") {
                    dmgIncrease += 1.5;
                } else dmgIncrease += .5;
            }
        }
        let dmg = weapon.dmg;
        if (weapon.chargingMechanic) {
            dmg = Math.round(weapon.dmg * (weapon.ammo / weapon.maxammo));
        }
        if (weapon.name == "Spark" || weapon.name == "Calamity") {
            let damage = 1;
            let scale = 350 + weapon.target.scale;
            if (dist(weapon.target, robot) <= scale) {
                damage += 1 - (dist(weapon.target, robot) / scale);
                damage = Math.min(damage, 2);
            } else {
                let distance = dist(weapon.target, robot) - scale;
                damage = 1 - (distance / weapon.range);
                damage = Math.max(damage, 0.05);
            }
            dmg *= damage;
        }
        changeHealth(taker, {
            amount: -(dmg * dmgIncrease * dmgMulti),
            defensePointsBypass: (weapon.name == "Skyward" ? 0 : (1 - weapon.defenseBypass)),
            onDamageHealBack: weapon.healBackOnDamage,
            motherShipCharge: weapon.motherShipCharge,
            bypassReflector: weapon.name == "Skyward"
        }, false, robot);
        if (taker.health <= 0 && hasHealth) {
            let player1 = findPlayerBySid(robot.inGameSid);
            let player2 = findPlayerBySid(taker.inGameSid);
            if (player1 && player2) {
                addLogger(player1, {
                    name: weapon.name,
                    level: weapon.level
                }, player2);
            }
        }
    }
    function doLaserStuff(robot, weapon, isAlly) {
        if (weapon.name == "Calamity" || weapon.name == "Spark" || weapon.name == "Striker" || weapon.name == "Athos" || weapon.name == "Aramis" || weapon.name == "Fulgur" || weapon.name == "Tonans") {
            if (weapon.target || robot.target) {
                let target = weapon.target || robot.target;
                if (target && dist(target, robot) <= weapon.range) {
                    doLaserDamage(robot, weapon, target);
                }
            }
        } else if (weapon.name == "Skyward") {
            let direction = robot.dir;
            let angle = 0.72;
            if (weapon.target || robot.target) {
                let target = weapon.target || robot.target;
                if (target && dist(target, robot) <= weapon.range) {
                    doLaserDamage(robot, weapon, target);
                }
            }
            if (hasPlayers()) {
                for (let i = 0; i < players.length; i++) {
                    let player = players[i].robots[players[i].robotIndex];
                    if (player && players[i].isAlly != isAlly) {
                        let dir = Math.atan2(player.y - robot.y, player.x - robot.x);
                        if ((["Leiming", "Fengbao"].includes(weapon.name) ? true : !player.invis) && Math.getAngleDist(direction, dir) <= angle && dist(player, robot) <= weapon.range + player.scale) {
                            doLaserDamage(robot, weapon, player);
                        }
                    }
                }
            } else {
                for (let i = 0; i < enemies.length; i++) {
                    let player = enemies[i];
                    if (player) {
                        let dir = Math.atan2(player.y - robot.y, player.x - robot.x);
                        if (Math.getAngleDist(direction, dir) <= angle && dist(player, robot) <= weapon.range + player.scale) {
                            doLaserDamage(robot, weapon, player, .5);
                        }
                    }
                }
            }
        } else {
            let direction = robot.dir;
            let angle = weapon.name == "Comet Laser" ? Math.PI : ["Leiming", "Fengbao"].includes(weapon.name) ? (Math.PI / 2) : 0.72;
            if (hasPlayers()) {
                for (let i = 0; i < players.length; i++) {
                    let player = players[i].robots[players[i].robotIndex];
                    if (player && players[i].isAlly != isAlly) {
                        let dir = Math.atan2(player.y - robot.y, player.x - robot.x);
                        if ((["Leiming", "Fengbao"].includes(weapon.name) ? true : !player.invis) && Math.getAngleDist(direction, dir) <= angle && dist(player, robot) <= weapon.range + player.scale) {
                            doLaserDamage(robot, weapon, player);
                        }
                    }
                }
            } else {
                for (let i = 0; i < enemies.length; i++) {
                    let player = enemies[i];
                    if (player) {
                        let dir = Math.atan2(player.y - robot.y, player.x - robot.x);
                        if (Math.getAngleDist(direction, dir) <= angle && dist(player, robot) <= weapon.range + player.scale) {
                            doLaserDamage(robot, weapon, player);
                        }
                    }
                }
            }
        }
    }
    function doWeaponTargetStuff(weapon, robot, isAlly) {
        if (!robot.isMe) return;
        let enemies = getNearest(robot, weapon.range, isAlly);
        if (enemies.length) {
            enemies = enemies.filter(e => !e.invis);
            if (weapon.name == "Spark" || weapon.name == "Calamity") {
                let enemy = enemies.sort((a, b) => dist(robot.cursorLocation, a) - dist(robot.cursorLocation, b)).find(e => dist(e, robot.cursorLocation) <= e.scale * 2 + 20);
                if (enemy) {
                    weapon.target = enemy;
                } else {
                    weapon.target = undefined;
                }
            } else {
                let enemy = enemies.sort((a, b) => dist(robot.cursorLocation, a) - dist(robot.cursorLocation, b))[0];
                if (enemy) {
                    weapon.target = enemy;
                } else {
                    weapon.target = undefined;
                }
            }
        }
    }
    function updateCursorLocation(robot) {
        let x1 = mouseX / window.innerWidth;
        let y1 = mouseY / window.innerHeight;
        let x2 = x1 * maxScreen.x;
        let y2 = y1 * maxScreen.y;
        let x3 = maxScreen.x / 2;
        let y3 = maxScreen.y / 2;
        let ang = Math.atan2(y2 - y3, x2 - x3);
        let Dist = Math.hypot(y2 - y3, x2 - x3);
        let cursorLocation = {
            x: robot.x + Math.cos(ang) * Dist,
            y: robot.y + Math.sin(ang) * Dist
        };
        robot.cursorLocation = cursorLocation;
    }
    function increaseFireTime(weapon, amount, max, amount2) {
        if (typeof amount != "number") return;
        if (amount > 0) {
            if (!weapon.notActive) {
                weapon.firedTime = Math.min(weapon.firedTime + amount, max);
            } else {
                weapon.firedTime = Math.max(weapon.firedTime - (amount2 || amount), 0);
            }
        } else {
            weapon.firedTime = Math.max((weapon.firedTime + amount), 0);
        }
    }
    function doWeaponStuff(robot, delta, isAlly) {
        let shownCinderEffects = false;
        let doWeaponss = robot.weapons.sort((a, b) => a.slot - b.slot);
        let spacePressed = keysPressed[32];
        let rPressed = keysPressed[82];
        let DateNow = Date.now();
        if (robot.isMe) updateCursorLocation(robot);
        if (robot.name == "Light Gray Heptagon") {
            if (robot.effects.find(e => e.name == "reflector" && e.lastTime <= 9e3)) {
                robot.weapons.find(e => e.name == "Comet Laser").notActive = false;
            } else {
                robot.weapons.find(e => e.name == "Comet Laser").notActive = true;
            }
        }
        for (let i = 0; i < doWeaponss.length; i++) {
            let weapon = doWeaponss[i];
            if (robot.isMe && document.getElementById(`weaponICON${i}`)) {
                let weaponImg = getWeaponIcon(weapon, true);
                weaponImg.style = "width: 100%; height: 100%";
                document.getElementById(`weaponICON${i}`).appendChild(weaponImg);
            }
            if (weapon.continuousReload) {
                if (weapon.lastFire == null) weapon.lastFire = 0;
                if (weapon.name == "Athos" || weapon.name == "Aramis") {
                    doWeaponTargetStuff(weapon, robot, isAlly);
                }
                if (weapon.name == "Discordia" || weapon.name == "Tumultus" || weapon.name == "Kramola" || weapon.name == "Razdor") {
                    if ((robot.isMe ? spacePressed : robot.fireWeapon)) {
                        increaseFireTime(weapon, delta, 2e3);
                    } else {
                        increaseFireTime(weapon, -delta);
                    }
                }
                let fireRateMulti = (weapon.firedTime / 2e3 == 1 ? (weapon.name == "Razdor" || weapon.name == "Kramola" ? .5 : 0.7) : 1);
                if (!weapon.notActive && weapon.ammo > 0 && !robot.isFREEZE && (robot.isMe ? spacePressed : robot.fireWeapon) && DateNow - weapon.lastFire >= (weapon.fireRate * fireRateMulti)) {
                    weapon.lastFire = DateNow;
                    if (weapon.name == "Cinder") {
                        if (hasPlayers()) {
                            for (let t = 0; t < players.length; t++) {
                                let player = players[t].robots[players[t].robotIndex];
                                if (player && players[t].isAlly != isAlly) {
                                    if (Math.hypot(player.y - robot.y, player.x - robot.x) <= weapon.range + player.scale) {
                                        changeHealth(player, {
                                            amount: -weapon.dmg,
                                            motherShipCharge: weapon.motherShipCharge
                                        }, player.isMe, robot);
                                    }
                                }
                            }
                        } else {
                            enemies.filter(e => Math.hypot(e.y - robot.y, e.x - robot.x) <= weapon.range + e.scale).sort((a, b) => Math.hypot(a.y - robot.y, a.x - robot.x) - Math.hypot(b.y - robot.y, b.x - robot.x)).forEach(enemy => {
                                changeHealth(enemy, {
                                    amount: -weapon.dmg,
                                    motherShipCharge: weapon.motherShipCharge
                                }, false, robot);
                            });
                        }
                        if (!shownCinderEffects) {
                            shownCinderEffects = true;
                            bombeffect.push({
                                location: robot,
                                doFaster: true,
                                scale: 0,
                                maxScale: weapon.range
                            });
                        }
                    } else if (weapon.name == "Athos" || weapon.name == "Aramis" || weapon.name == "Comet Laser" || weapon.name == "Pantagruel" || weapon.name == "Gangantua") {
                        doLaserStuff(robot, weapon, isAlly);
                    } else {
                        fireWeapon(weapon, robot, isAlly);
                    }
                    weapon.ammo--;
                }
                if (weapon.ammo < weapon.maxammo) {
                    if ((robot.isMe ? rPressed : false) && !robot.isFREEZE) {
                        robot.reloadMoveMulti = .5;
                    } else {
                        robot.reloadMoveMulti = 1;
                    }
                    if (weapon.lastChange == null) weapon.lastChange = 0;
                    if (robot.isMe) {
                        let reloadTime = ((weapon.reload * robot.reloadMoveMulti) - (Date.now() - weapon.lastChange)) / 1e3;
                        if (reloadTime <= 0) reloadTime = 0;
                        let string = reloadTime.toString();
                        document.getElementById(`weaponReloadNumber${i}`).innerHTML = `
                        ${string.includes(".") ? string.slice(0, string.indexOf(".") + 2) : string}s
                        `;
                    }
                    if (Date.now() - weapon.lastChange >= (weapon.reload * robot.reloadMoveMulti)) {
                        weapon.lastChange = Date.now();
                        if (weapon.ammoEachReloadTick) {
                            weapon.ammo = Math.min(weapon.ammo + weapon.ammoEachReloadTick, weapon.maxammo);
                        } else {
                            weapon.ammo = Math.min(weapon.ammo + 1, weapon.maxammo);
                        }
                    }
                }
            } else {
                if (weapon.canFire == null) weapon.canFire = true;
                if (!weapon.notActive) {
                    if (weapon.name == "Atomizer" || weapon.name == "Nucleon") {
                        if ((robot.isMe ? spacePressed : robot.fireWeapon)) {
                            increaseFireTime(weapon, delta, weapon.overheatTime, -(delta * 2));
                        } else {
                            increaseFireTime(weapon, -(delta * 2));
                        }
                    } else if (weapon.name == "Inferno" || weapon.name == "Pyro" || weapon.name == "Discharger" || weapon.name == "Igniter") {
                        if ((robot.isMe ? spacePressed : robot.fireWeapon) && !weapon.disabled) {
                            increaseFireTime(weapon, delta, weapon.overheatTime, -(delta * 4));
                        } else {
                            increaseFireTime(weapon, -(delta * (weapon.disabled ? ((weapon.name == "Discharger" || weapon.name == "Igniter") ? 2 : .75) : 4)));
                        }
                        if (weapon.firedTime >= weapon.overheatTime) {
                            weapon.disabled = true;
                        } else if (weapon.disabled && weapon.firedTime == 0) {
                            if (robot.name == "Sharanga" && robot.effects.find(e => e.name == "phase shift")) {
                            } else {
                                weapon.disabled = false;
                            }
                        }
                    } else if (weapon.name == "Evora" || weapon.name == "Disintegrator" || weapon.name == "Havoc" || weapon.name == "Veyron" || weapon.name == "Ultimate Punisher" || weapon.name == "Ultimate Destroyer") {
                        if ((robot.isMe ? spacePressed : robot.fireWeapon)) {
                            increaseFireTime(weapon, delta, 2e3);
                        } else {
                            increaseFireTime(weapon, -delta);
                        }
                    } else if (weapon.name == "Sorrow" || weapon.name == "Grief") {
                        if ((robot.isMe ? spacePressed : robot.fireWeapon)) {
                            increaseFireTime(weapon, delta, 2e3);
                        } else {
                            increaseFireTime(weapon, -delta);
                        }
                    }
                }
                if (weapon.name == "Calamity" || weapon.name == "Spark" || weapon.name == "Striker" || weapon.name == "Skyward" || weapon.name == "Fulgur" || weapon.name == "Tonans") {
                    doWeaponTargetStuff(weapon, robot, isAlly);
                }
                if (weapon.canFire && !weapon.notActive && !weapon.disabled) {
                    if (!weapon.chargingMechanic) weapon.ammo = Math.floor(weapon.ammo);
                    if (weapon.lastFire == null) weapon.lastFire = 0;
                    robot.reloadMoveMulti = 1;
                    let fireRateMulti = 1;
                    if (weapon.name == "Evora" || weapon.name == "Veyron" || weapon.name == "Disintegrator" || weapon.name == "Havoc") {
                        fireRateMulti = (weapon.firedTime / 2e3) == 1 ? 0.25 : 1;
                    } else if (weapon.name == "Sorrow" || weapon.name == "Grief") {
                        fireRateMulti = (weapon.firedTime / 2e3) == 1 ? .25 : 1;
                    } else if (weapon.name == "Ultimate Punisher" || weapon.name == "Ultimate Destroyer") {
                        fireRateMulti = (weapon.firedTime / 2e3) == 1 ? 0.34 : 1;
                    }
                    if (weapon.ammo > 0 && ((robot.isMe ? spacePressed : robot.fireWeapon) || weapon.continueToFire) && !robot.isFREEZE) {
                        if (typeof weapon.fireRate == "object") {
                            if (DateNow - weapon.lastFire >= weapon.fireRate[weapon.ammoFired % weapon.fireRate.length]) {
                                if (weapon.ammoFired % weapon.fireRate.length == 0) {
                                    weapon.continueToFire = true;
                                }
                                weapon.lastFire = DateNow;
                                if (weapon.name == "Leiming" || weapon.name == "Fengbao") {
                                    doLaserStuff(robot, weapon, isAlly);
                                } else {
                                    fireWeapon(weapon, robot, isAlly);
                                }
                                if (weapon.ammoFired % weapon.fireRate.length == weapon.fireRate.length - 1) {
                                    weapon.continueToFire = false;
                                }
                                weapon.ammoFired++;
                                weapon.ammo--;
                            }
                        } else if (DateNow - weapon.lastFire >= weapon.fireRate * fireRateMulti) {
                            if (weapon.name == "Fulgur" || weapon.name == "Tonans") {
                                weapon.continueToFire = true;
                            }
                            weapon.lastFire = DateNow;
                            if (weapon.name == "Striker" || weapon.name == "Hawk" || weapon.name == "Eagle") {
                                let nearestEnemies = [];
                                if (hasPlayers()) {
                                    for (let t = 0; t < players.length; t++) {
                                        let player = players[t].robots[players[t].robotIndex];
                                        if (player && players[t].isAlly != isAlly) {
                                            if (!player.invis && Math.hypot(player.y - robot.y, player.x - robot.x) <= weapon.range + player.scale) {
                                                nearestEnemies.push(player);
                                            }
                                        }
                                    }
                                    nearestEnemies = nearestEnemies.sort((a, b) => Math.hypot(a.y - (weapon.target || robot).y, a.x - (weapon.target || robot).x) - Math.hypot(b.y - (weapon.target || robot).y, b.x - (weapon.target || robot).x));
                                } else {
                                    nearestEnemies = enemies.filter(e => Math.hypot(e.y - (weapon.target || robot).y, e.x - (weapon.target || robot).x) <= weapon.range + e.scale).sort((a, b) => Math.hypot(a.y - (weapon.target || robot).y, a.x - (weapon.target || robot).x) - Math.hypot(b.y - (weapon.target || robot).y, b.x - (weapon.target || robot).x));
                                }
                                for (let ttt = 0; ttt < 3; ttt++) {
                                    let enemy = nearestEnemies[ttt];
                                    if (enemy) {
                                        doLaserDamage(robot, weapon, enemy);
                                    }
                                }
                                if (nearestEnemies.length) {
                                    weapon.ammo--;
                                }
                            } else if (weapon.name == "Calamity" || weapon.name == "Spark" || weapon.name == "Skyward" || weapon.name == "Fulgur" || weapon.name == "Tonans") {
                                doLaserStuff(robot, weapon, isAlly);
                                weapon.ammo--;
                            } else {
                                fireWeapon(weapon, robot, isAlly);
                                weapon.ammo--;
                            }
                            if (weapon.chargingMechanic) {
                                weapon.chargingPower = false;
                                weapon.ammo = 0;
                            }
                        }
                    }
                    if (weapon.ammo <= 0 && !weapon.chargingPower) {
                        weapon.canFire = false;
                    } else if (weapon.chargingPower) {
                        weapon.ammo += ((weapon.maxammo / weapon.reload) * delta) * (robot.isMe && keysPressed[82] ? 2 : 1);
                        weapon.ammo = Math.min(weapon.ammo, weapon.maxammo);
                        if (weapon.ammo < weapon.maxammo) {
                            let reloadTimeString = (((weapon.maxammo - weapon.ammo) / weapon.maxammo) * weapon.reload) / 1e3;
                            let string = reloadTimeString.toString();
                            document.getElementById(`weaponReloadNumber${i}`).style.color = "#00ffff";
                            document.getElementById(`weaponReloadNumber${i}`).innerHTML = `
                            ${string.includes(".") ? string.slice(0, string.indexOf(".") + 2) : string}s
                            `;
                        }
                    }
                } else if (!weapon.disabled) {
                    if ((robot.isMe ? rPressed : false) && !robot.isFREEZE) {
                        robot.reloadMoveMulti = .5;
                    } else {
                        robot.reloadMoveMulti = 1;
                    }
                    if (weapon.name == "Fulgur" || weapon.name == "Tonans") {
                        weapon.continueToFire = false;
                    }
                    let reloadTime = weapon.chargingMechanic ? weapon.chargingPower ? weapon.reload : weapon.chargingDelay : weapon.reload;
                    if (!weapon.overheatTime && robot.isMe) {
                        let reloadTimeString = (((weapon.maxammo - weapon.ammo) / weapon.maxammo) * reloadTime) / 1e3;
                        let string = reloadTimeString.toString();
                        document.getElementById(`weaponReloadNumber${i}`).style.color = "#ffff00";
                        document.getElementById(`weaponReloadNumber${i}`).innerHTML = `
                        ${string.includes(".") ? string.slice(0, string.indexOf(".") + 2) : string}s
                        `;
                    }
                    weapon.ammo += ((weapon.maxammo / reloadTime) * delta) * (robot.isMe && keysPressed[82] ? 2 : 1);
                    if (weapon.ammo >= weapon.maxammo) {
                        weapon.ammo = weapon.maxammo;
                        weapon.canFire = true;
                        if (weapon.chargingMechanic) {
                            weapon.ammo = 0;
                            weapon.chargingPower = true;
                        }
                    }
                }
            }
        }
        if (robot.name == "Dark Brown Pentagon" && !robot.effects.find(e => e.abilityEffect == robot.abilities[0].name)) {
            if (robot.remoteAssaultLast == null) robot.remoteAssaultLast = 0;
            if (Date.now() - robot.remoteAssaultLast >= 150) {
                robot.remoteAssaultLast = Date.now();
                projectiles.push({
                    x: robot.x,
                    y: robot.y,
                    oldX: robot.x,
                    oldY: robot.y,
                    projType: "rocket",
                    velx: 0,
                    vely: 0,
                    scale: 20,
                    speed: 0.15,
                    aoeRange: 120,
                    dmg: robot.abilities[0].dmg,
                    range: 2300,
                    dir: robot.dir,
                    isAlly: isAlly,
                    color: "./images/bullets/rocket.png",
                    owner: robot,
                    weaponOwner: {
                        name: robot.abilities[0].name,
                        level: robot.level
                    }
                });
            }
        }

        if (robot.name == "Orange Triangle") {
            if (robot.remoteAssaultLast == null) robot.remoteAssaultLast = 0;

            if (Date.now() - robot.remoteAssaultLast >= 75) {
                robot.remoteAssaultLast = Date.now();

                projectiles.push({
                    x: robot.x,
                    y: robot.y,
                    oldX: robot.x,
                    oldY: robot.y,
                    projType: "rocket",
                    velx: 0,
                    vely: 0,
                    scale: 35,
                    speed: 0.35,
                    aoeRange: 120,
                    dmg: 1111 + ((robot.level - 1) * 666),
                    dotEffect: {
                        name: "dot",
                        owner: robot,
                        dmg: 444 + ((robot.level - 1) * 111),
                        last: 7e3
                    },
                    slowEffect: {
                        name: "slowdown",
                        last: 7e3,
                        power: 0.05
                    },
                    range: 2300,
                    dir: robot.dir,
                    autoTargetData: {
                        type: "nearest",
                        range: 600,
                        better: true
                    },
                    changeDirSpeed: 0.03,
                    isAlly: isAlly,
                    color: "./images/bullets/rocket.png",
                    owner: robot,
                    weaponOwner: {
                        name: "Triangle's Aura",
                        level: robot.level
                    }
                });
            }
        }
    }
    function collideWithBuildings(robot, delta, isAlly) {
        for (let i = 0; i < ACTUALBUILDINGSTOTOUCH.length; i++) {
            let obj = ACTUALBUILDINGSTOTOUCH[i];
            if (obj) {
                if (robot.avoidBuildings && !obj.antiAvoid) continue;
                if (obj.name == "beacon") {
                    if (!robot.isFREEZE && Math.hypot(obj.y - robot.y, obj.x - robot.x) <= 400) {
                        obj.isHAVEON = true;
                        if (isAlly) {
                            if (obj.ENEMYPOINTS) {
                                obj.ENEMYPOINTS -= delta;
                                if (obj.ENEMYPOINTS < 0) {
                                    obj.ENEMYPOINTS = 0;
                                }
                            } else {
                                obj.ALLYPOINTS += delta;
                                if (obj.ALLYPOINTS > 5e3) {
                                    obj.ALLYPOINTS = 5e3;
                                }
                            }
                        } else {
                            if (obj.ALLYPOINTS) {
                                obj.ALLYPOINTS -= delta;
                                if (obj.ALLYPOINTS < 0) {
                                    obj.ALLYPOINTS = 0;
                                }
                            } else {
                                obj.ENEMYPOINTS += delta;
                                if (obj.ENEMYPOINTS > 5e3) {
                                    obj.ENEMYPOINTS = 5e3;
                                }
                            }
                        }
                    }
                } else if (obj.name == "wall rect" || obj.name == "border rect") {
                    if (circleSquareCollision(robot, obj, true)) {
                        let Px = Math.max(obj.x, Math.min(robot.x, obj.x + obj.width));
                        let Py = Math.max(obj.y, Math.min(robot.y, obj.y + obj.height));
                        if (obj.name == "wall rect" && Math.hypot(robot.y - Py, robot.x - Px) <= 0) {
                            robot.avoidBuildings = true;
                        } else {
                            robot.velx *= 0.75;
                            robot.vely *= 0.75;
                            robot.velx += Math.cos(Math.atan2(robot.y - Py, robot.x - Px)) * (.75 + robot.speed);
                            robot.vely += Math.sin(Math.atan2(robot.y - Py, robot.x - Px)) * (.75 + robot.speed);
                        }
                    }
                } else if (obj.name == "water") {
                    let Px = Math.max(obj.x, Math.min(robot.x, obj.x + obj.width));
                    let Py = Math.max(obj.y, Math.min(robot.y, obj.y + obj.height));
                    let distance = Math.hypot(robot.x - Px, robot.y - Py);
                    if (distance <= robot.scale / 2) {
                        let map = mapInfoData.find(e => e.id == player.mapID);
                        let half = {
                            x: map.x / 2,
                            y: map.y / 2
                        };
                        let ang = Math.atan2(half.y - robot.y, half.x - robot.x);
                        robot.velx += Math.cos(ang) * 0.01;
                        robot.vely += Math.sin(ang) * 0.01;
                    }
                }
            }
        }
    }
    function doWonderworkerSkill(robot, ability) {
        if (robot.onAbilityUseFix) {
            changeHealth(robot, {
                amount: robot.maxhealth * robot.onAbilityUseFix
            }, false, robot);
        }
        if (robot.onAbilityUseDefense) {
            robot.effects.push({
                name: "defense points",
                amount: robot.onAbilityUseDefense,
                endAfterAbilityIsEnd: true,
                lastForever: !ability.lastingTime ? false : ["Blink Support"].includes(ability.name) ? false : true,
                lastTime: !ability.lastingTime ? 5e3 : ["Blink Support"].includes(ability.name) ? 5e3 : 1
            });
        }
        if (robot.onAbilityUseStealth) {
            robot.effects.push({
                name: "stealth",
                lastTime: robot.onAbilityUseStealth
            });
        }
        if (robot.onAbilityUseAttack) {
            robot.effects.push({
                name: "attack",
                power: robot.onAbilityUseAttack,
                endAfterAbilityIsEnd: true,
                lastForever: !ability.lastingTime ? false : ["Blink Support"].includes(ability.name) ? false : true,
                lastTime: !ability.lastingTime ? 5e3 : ["Blink Support"].includes(ability.name) ? 5e3 : 1
            });
        }
        if (robot.onAbilityUseSpeed) {
            robot.effects.unshift({
                name: "speed",
                power: robot.onAbilityUseSpeed,
                endAfterAbilityIsEnd: true,
                lastForever: !ability.lastingTime ? false : true,
                lastTime: !ability.lastingTime ? 5e3 : 1
            });
        }
    }
    var transitionProgress = 0;
    function doShapeShiftStuff(robot, isAlly) {
        for (let i = 0; i < robot.abilities.length; i++) {
            let ability = robot.abilities[i];
            if (robot.name == "Brown Pentagon" || robot.name == "Ultimate Brown Pentagon") {
                if (robot.isMe) transitionProgress = 0;
                let shield = robot.shields.find(e => e.baseShield == "built in");
                if (ability.mode == 0) {
                    robot.flightVisualData = {
                        scale: robot.oldScale,
                        fov: {
                            x: 1980 * robot.fieldOfViewMulti * (robot.name == "Ultimate Brown Pentagon" ? .7 : .6),
                            y: 1080 * robot.fieldOfViewMulti * (robot.name == "Ultimate Brown Pentagon" ? .7 : .6)
                        }
                    };
                    if (shield) {
                        shield.notActive = true;
                    }
                    robot.weapons.forEach(e => {
                        if (e.type == "Heavy") {
                            e.notActive = false;
                        }
                    });
                    ability.mode = 1;
                } else {
                    robot.flightVisualData = .15;
                    if (shield) {
                        shield.notActive = false;
                    }
                    robot.weapons.forEach(e => {
                        if (e.type == "Heavy") {
                            e.notActive = true;
                        }
                    });
                    ability.mode = 0;
                }
            } else {
                let indexx = 0;
                if (robot.isMe) transitionProgress = 0;
                if (ability.mode == 0) {
                    robot.flightVisualData = {
                        scale: robot.oldScale * (robot.name == "Pinkish-Red Heptagon" ? 1.4 : 1.3),
                        fov: {
                            x: 1980 * robot.fieldOfViewMulti * (robot.name == "Pinkish-Red Heptagon" ? 1.8 : 1.2),
                            y: 1080 * robot.fieldOfViewMulti * (robot.name == "Pinkish-Red Heptagon" ? 1.8 : 1.2)
                        }
                    };
                    let doStuff = robot.weapons.filter(e => e.type == (robot.name == "Pinkish-Red Heptagon" ? "Light" : "Heavy")).sort((a, b) => a.slot - b.slot);
                    for (let i = 0; i < doStuff.length; i++) {
                        let e = doStuff[i];
                        if (e) {
                            e.notActive = (robot.name == "Pinkish-Red Heptagon" ? false : true);
                            indexx++;
                            if (indexx >= 2) {
                                break;
                            }
                        }
                    }
                    if (robot.name != "Pinkish-Red Heptagon") {
                        ability.weaponMulti = 1;
                        robot.shields.push({
                            type: "purple",
                            health: 0,
                            lastTime: 5e3
                        });
                    }
                    ability.mode = 1;
                } else {
                    robot.flightVisualData = .15;
                    let doStuff = robot.weapons.filter(e => e.type == (robot.name == "Pinkish-Red Heptagon" ? "Light" : "Heavy")).sort((a, b) => a.slot - b.slot);
                    for (let i = 0; i < doStuff.length; i++) {
                        let e = doStuff[i];
                        if (e) {
                            e.notActive = (robot.name == "Pinkish-Red Heptagon" ? true : false);
                            indexx++;
                            if (indexx >= 2) {
                                break;
                            }
                        }
                    }
                    ability.mode = 0;
                }
            }
        }
    }
    function doBlinkAbility(robot, x, y) {
        let distance = dist(robot, { x, y });
        if (distance <= 2e3) {
            robot.x = x;
            robot.y = y;
        } else {
            let angle = Math.atan2(y - robot.y, x - robot.x);
            let tmp = {
                x: robot.x + Math.cos(angle) * 2e3,
                y: robot.y + Math.sin(angle) * 2e3
            };
            robot.x = tmp.x;
            robot.y = tmp.y;
        }
    }
    function useAbility(robot, isAlly, delta, ability) {
        if (ability.abilityLast == null) ability.abilityLast = 0;
        if (ability.abilityReload == null) ability.abilityReload = 0;
        if (ability.name == "Shapeshift") {
            if (ability.abilityReload == 0) {
                doShapeShiftStuff(robot, isAlly);
                doWonderworkerSkill(robot, ability);
                ability.abilityReload = ability.reload;
            }
        } else if (ability.name == "Castling") {
            if (ability.abilityReload == 0 && ability.abilityLast == 0) {
                ability.abilityLast = ability.lastingTime;
                doWonderworkerSkill(robot, ability);
                let amount = 0;
                for (let i = 0; i < robot.shields.length; i++) {
                    let shield = robot.shields[i];
                    if (shield.type == "normal") {
                        bombeffect.push({
                            x: robot.x + Math.cos(shield.dir + robot.dir) * (robot.scale + 20),
                            y: robot.y + Math.sin(shield.dir + robot.dir) * (robot.scale + 20),
                            speed: 0.1,
                            maxScale: 30,
                            scale: 0,
                            Color: "rgb(255, 255, 255, 0.5)",
                            Color2: "rgb(255, 255, 255, 0.65)",
                        });
                        amount += 0.1;
                        shield.kill = true;
                    }
                }
                let h = robot.maxhealth * amount;
                robot.grayDamage = Math.max(0, robot.grayDamage - (h * .15));
                changeHealth(robot, {
                    amount: h
                }, false, robot);
                robot.effects.push({
                    name: "Castling",
                    dmg: ability.dmg,
                    abilityEffect: ability.name,
                    amount: ability.abilityDefensePoints,
                    lastTime: ability.lastingTime,
                    touchLast: Date.now()
                });
                if (robot.isMe) transitionProgress = 0;
                robot.flightVisualData = {
                    scale: robot.oldScale * 1.2,
                    fov: {
                        x: 1980 * robot.fieldOfViewMulti * 1.2,
                        y: 1080 * robot.fieldOfViewMulti * 1.2
                    }
                };
            } else if (robot.effects.find(e => e.name == ability.name)) {
                let effect = robot.effects.find(e => e.name == ability.name);
                if (Date.now() - effect.touchLast >= 250) {
                    if (effect.stage == 1) {
                        effect.stage = 2;
                        effect.touchLast = Date.now();
                        effect.dir = robot.dir;
                    } else if (effect.stage == 2) {
                        effect.stage++;
                        effect.touchLast = Date.now();
                        effect.stage = 3;
                        if (robot.isMe) transitionProgress = 0;
                        robot.flightVisualData = .15;
                    }
                }
            }
        } else if (ability.name == "Ultimate Reflecting Dash") {
            if (ability.abilityReload == 0 && ability.abilityLast == 0) {
                ability.abilityLast = ability.lastingTime;
                doWonderworkerSkill(robot, ability);
                let moveDir = doMoveStuff(robot, isAlly);
                robot.effects.push({
                    name: "Ultimate Reflecting Dash",
                    abilityEffect: ability.name,
                    lastTime: ability.lastingTime,
                    dir: (robot.isMe ? robot.dir : moveDir),
                    touchLast: Date.now()
                });
                robot.effects.push({
                    name: "reflector",
                    block: (1 - defensePointsToResistance(ability.abilityDefensePoints)),
                    return: .75,
                    lastTime: ability.lastingTime
                });
            } else if (robot.effects.find(e => e.name == ability.name)) {
                let effect = robot.effects.find(e => e.name == ability.name);
                if (Date.now() - effect.touchLast >= 150 && !effect.pressed) {
                    effect.pressed = true;
                    robot.velx = 0;
                    robot.vely = 0;
                }
            }
        } else if (robot.effects.find(e => e.name == "Cannonier") && robot.name != "Eiffel") {
            let effect = robot.effects.find(e => e.name == "Cannonier");
            if (effect.stage == null) effect.stage = 0;
            if (effect.lastChange == null) effect.lastChange = 0;
            if (Date.now() - effect.lastChange >= 250) {
                effect.lastChange = Date.now();
                effect.dir = robot.dir;
                if (effect.stage == 0) {
                    effect.stage++;
                } else if (effect.stage == 1) {
                    effect.stage++;
                    effect.dashLast = null;
                } else {
                    effect.lastTime = 1;
                    ability.abilityLast = 1;
                }
            }
        } else if (ability.name == "Annihilation Mode" || ability.name == "Mastermind" || ability.name == "Dark Light" || ability.name == "Blink" || ability.name == "Debut" || ability.name == "Absorber" || ability.name == "Defense Breach" || ability.name == "Overpower" || ability.name == "Ultimate Reflector" || ability.name == "Blast Wave" || ability.name == "Phalanx Mode" || ability.name == "Stove" || ability.name == "Track" || ability.name == "Absorption" || ability.name == "Skyward" || ability.name == "Ferocity" || ability.name == "Barrier Field" || ability.name == "Blink Assault" || (ability.name == "Clain Blink" && !ability.maxcharge) || ability.name == "Remote Assault" || ability.name == "Cannonier" || ability.name == "Long Shot" || ability.name == "Support" || ability.name == "Matrix" || ability.name == "Reflector" || ability.name == "Clear Sky" || ability.name == "Reinforce Hull" || ability.name == "Ultimate Mending" || ability.name == "Divine Judgement" || ability.name == "Grand Fortitude" || ability.name == "Paladin" || ability.name == "Overload" || (ability.name == "Stampede" && !ability.maxcharge) || ability.name == "Stealth" || ability.name == "Retribution" || ability.name == "Ultimate Defense" || ability.name == "Self Heal" || ability.name == "Dragon Flight" || ability.name == "Shield Regeneration" || ability.name == "Full Action") {
            if (ability.abilityReload == 0 && ability.abilityLast == 0) {
                ability.abilityLast = ability.lastingTime;
                doWonderworkerSkill(robot, ability);
                if (ability.name == "Divine Judgement") {
                    robot.effects.push({
                        name: "slowdown",
                        power: .8,
                        abilityEffect: "Divine Judgement",
                        lastTime: ability.lastingTime
                    });
                    robot.effects.push({
                        name: "defense points",
                        amount: 9e3,
                        abilityEffect: "Divine Judgement",
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Dragon Flight") {
                    if (robot.isMe) transitionProgress = 0;
                    if (robot.name.includes("Ultimate")) {
                        robot.effects.push({
                            name: "forcefield",
                            data: {
                                resistance: .99,
                                min: .9,
                                maxhealth: robot.maxhealth * 2,
                                health: robot.maxhealth * 2
                            },
                            abilityEffect: ability.name,
                            rechargeTime: ability.lastingTime,
                            lastTime: ability.lastingTime
                        });
                    }
                    robot.flightVisualData = {
                        scale: robot.oldScale * (robot.name.includes("Ultimate") ? 1.35 : 1.75),
                        speed: 0.1,
                        fov: {
                            x: 1980 * robot.fieldOfViewMulti * 1.5,
                            y: 1080 * robot.fieldOfViewMulti * 1.5
                        }
                    };
                } else if (ability.name == "Stampede") {
                    robot.effects.push({
                        name: "stampede",
                        abilityEffect: ability.name,
                        dmg: ability.dmg,
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Overload" || ability.name == "Blast Wave") {
                    robot.effects.push({
                        name: "overload",
                        abilityEffect: ability.name,
                        dmg: ability.dmg,
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Paladin") {
                    let increase = 1;
                    let fortifier = robot.modules.filter(e => e.shieldHealth);
                    fortifier.forEach(e => {
                        increase += e.shieldHealth;
                    });
                    robot.shields.push({
                        type: "yellow",
                        maxhealth: ability.shieldHp * increase,
                        health: ability.shieldHp * increase
                    });
                } else if (ability.name == "Grand Fortitude") {
                    let moveDir = doMoveStuff(robot, isAlly);
                    changeHealth(robot, {
                        amount: robot.maxhealth * 0.1
                    }, false, robot);
                    ability.abilityReload = ability.reload;
                    robot.effects.push({
                        name: "reflector",
                        block: 0.333,
                        return: .15,
                        lastTime: 16e3
                    });
                    robot.effects.push({
                        name: "dash",
                        lastTime: 350,
                        dmg: ability.dmg,
                        dotDamage: ability.dotDamage,
                        POWER: 2,
                        dir: !robot.isMe ? moveDir : robot.dir
                    });
                } else if (ability.name == "Ultimate Mending") {
                    robot.effects.push({
                        name: "Ultimate Mending",
                        abilityEffect: "Ultimate Mending",
                        lastTime: ability.lastingTime,
                    });
                } else if (ability.name == "Reinforce Hull") {
                    let healthIncreased = robot.normalMaxHealth * (ability.abilityHealthMulti - 1);
                    robot.oldGrayDamage = robot.grayDamage;
                    let grayIncreased = robot.oldGrayDamage * (ability.abilityHealthMulti - 1);
                    robot.maxhealth += healthIncreased;
                    robot.health += healthIncreased;
                    robot.grayDamage += grayIncreased;
                    robot.effects.push({
                        name: "defense points",
                        abilityEffect: ability.name,
                        amount: ability.abilityDefensePoints,
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Reflector") {
                    if (robot.name == "Ultimate Teal Circle") {
                        let amount = robot.maxhealth * .25;
                        robot.grayDamage = Math.max(0, robot.grayDamage - (amount * .25));
                        changeHealth(robot, {
                            amount: amount
                        }, false, robot);
                        if (robot.fixedDurabilityIncreaseWithAbility____JustToMakeSure == null) {
                            robot.fixedDurabilityIncreaseWithAbility____JustToMakeSure = robot.maxhealth * .05;
                        }
                        robot.normalMaxHealth += robot.fixedDurabilityIncreaseWithAbility____JustToMakeSure;
                        robot.maxhealth += robot.fixedDurabilityIncreaseWithAbility____JustToMakeSure;
                    }
                    robot.effects.push({
                        name: "reflector",
                        return: robot.name == "Ultimate Teal Circle" ? .75 : .5,
                        block: 1 - defensePointsToResistance(ability.abilityDefensePoints),
                        abilityEffect: "Reflector",
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Clear Sky") {
                    if (robot.isMe) transitionProgress = 0;
                    robot.flightVisualData = {
                        scale: robot.oldScale * 1.3,
                        speed: 0.1,
                        fov: {
                            x: 1980 * robot.fieldOfViewMulti * 1.2,
                            y: 1080 * robot.fieldOfViewMulti * 1.2
                        }
                    };
                } else if (ability.name == "Matrix") {
                    robot.effects.push({
                        name: "Matrix",
                        abilityEffect: "Matrix",
                        dmg: ability.dmg,
                        lastTime: ability.lastingTime,
                    });
                } else if (ability.name == "Support") {
                    robot.effects.push({
                        name: "Support",
                        abilityEffect: "Support",
                        lastTime: ability.lastingTime,
                    });
                    if (robot.name.includes("Ultimate")) {
                        robot.effects.push({
                            name: "anti defense mig",
                            lastTime: ability.lastingTime,
                        });
                    }
                } else if (ability.name == "Long Shot") {
                    projectiles.push({
                        projType: "normal",
                        x: robot.x,
                        y: robot.y,
                        oldX: robot.x,
                        avoidBuildings: true,
                        oldY: robot.y,
                        velx: 0,
                        vely: 0,
                        dmg: 100,
                        dmgPercentage: .1 + (robot.dmgPercentage || 0),
                        scale: 40,
                        speed: .35,
                        range: 3800,
                        dir: robot.dir,
                        isAlly: isAlly,
                        color: "./images/bullets/bullet.png",
                        owner: robot,
                        bypassReflector: true,
                        defensePointsBypass: 0,
                        weaponOwner: {
                            name: "Long Shot",
                            level: robot.level
                        }
                    });
                } else if (ability.name == "Cannonier") {
                    if (robot.isMe) transitionProgress = 0;
                    robot.flightVisualData = {
                        scale: robot.oldScale * 1.5,
                        speed: (robot.name == "Eiffel" ? .2 : .1),
                        fov: {
                            x: 1980 * robot.fieldOfViewMulti * (robot.name == "Eiffel" ? 1.55 : 1.75),
                            y: 1080 * robot.fieldOfViewMulti * (robot.name == "Eiffel" ? 1.55 : 1.75)
                        }
                    };
                    robot.health += ability.additionalHealth;
                    robot.maxhealth += ability.additionalHealth;
                    robot.effects.push({
                        name: "Cannonier",
                        abilityEffect: "Cannonier",
                        health: ability.additionalHealth,
                        maxhealth: ability.additionalHealth,
                        lastTime: ability.lastingTime,
                        lastChange: Date.now() + 500
                    });
                    for (let i = 0; i < robot.weapons.length; i++) {
                        let weapon = robot.weapons[i];
                        if (weapon.targetedWeaponsToUse) {
                            weapon.notActive = false;
                        }
                    }
                } else if (ability.name == "Remote Assault") {
                    robot.effects.push({
                        name: "speed",
                        power: 1,
                        abilityEffect: "Remote Assault",
                        lastTime: ability.lastingTime
                    });
                    buildings.push({
                        dmg: ability.dmg,
                        range: 2300,
                        rate: 100,
                        scale: 40,
                        name: "Remote Assault",
                        x: (robot.cursorLocation ? robot.cursorLocation.x : robot.target ? robot.target.x : robot.x),
                        y: (robot.cursorLocation ? robot.cursorLocation.y : robot.target ? robot.target.y : robot.y),
                        owner: robot,
                        duration: ability.lastingTime,
                        isAlly: isAlly
                    });
                } else if (ability.name == "Clain Blink") {
                    robot.effects.push({
                        name: "Clain Blink",
                        abilityEffect: "Clain Blink",
                        lastTime: ability.lastingTime,
                        lastPressed: Date.now(),
                        translocator: {
                            x: robot.x,
                            y: robot.y
                        },
                    });
                    let shield = robot.shields.find(e => e.clainBlink);
                    if (shield) {
                        shield.maxhealth += ability.shieldHp;
                        shield.health += ability.shieldHp;
                    } else {
                        robot.shields.push({
                            type: "yellow",
                            clainBlink: true,
                            maxhealth: ability.shieldHp,
                            health: ability.shieldHp,
                            regen: 0
                        });
                    }
                    ability.maxcharge = 3;
                    ability.charges = 3;
                    let tmpx = robot.isMe ? robot.cursorLocation.x : robot.movementTarget.x;
                    let tmpy = robot.isMe ? robot.cursorLocation.y : robot.movementTarget.y
                    doBlinkAbility(robot, tmpx, tmpy);
                } else if (ability.name == "Blink Assault") {
                    robot.maxhealth += robot.normalMaxHealth * 2.5;
                    robot.health += robot.normalMaxHealth * 2.5;
                    robot.color = "#cc8400";
                    robot.effects.push({
                        name: "extra health",
                        abilityEffect: "Blink Assault",
                        health: robot.normalMaxHealth * 2.5,
                        maxhealth: robot.normalMaxHealth * 2.5,
                        lastTime: ability.lastingTime
                    });
                    for (let i = 0; i < 4; i++) buildings.push({
                        dmg: ability.dmg * 3,
                        range: 2e3,
                        rate: 100,
                        name: "Blink Assault",
                        scale: 40,
                        y: robot.y + Math.sin((robot.target ? Math.atan2(robot.target.y - robot.y, robot.target.x - robot.x) : robot.dir) + (Math.PI / 2 * i)) * (robot.scale * 3),
                        x: robot.x + Math.cos((robot.target ? Math.atan2(robot.target.y - robot.y, robot.target.x - robot.x) : robot.dir) + (Math.PI / 2 * i)) * (robot.scale * 3),
                        owner: robot,
                        duration: ability.lastingTime,
                        isAlly: isAlly
                    });
                } else if (ability.name == "Barrier Field") {
                    robot.shields.push({
                        health: 0,
                        baseShield: "built in",
                        dir: 0,
                        angleDist: Math.PI * 1.2,
                        barrierField: true,
                        owner: robot,
                        type: "purple normal",
                        limit: ability.durabilityLimit,
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Skyward") {
                    if (robot.isMe) transitionProgress = 0;
                    robot.flightVisualData = {
                        scale: robot.oldScale * 1.2,
                        speed: 0.1,
                        fov: {
                            x: 1980 * robot.fieldOfViewMulti * 1.4,
                            y: 1080 * robot.fieldOfViewMulti * 1.4
                        }
                    };
                    robot.effects.push({
                        name: "forcefield",
                        data: {
                            resistance: .9,
                            min: .8,
                            maxhealth: 250e3 * (1 + (robot.skywardV2 || 0)),
                            health: 250e3 * (1 + (robot.skywardV2 || 0))
                        },
                        abilityEffect: ability.name,
                        rechargeTime: ability.lastingTime,
                        lastTime: ability.lastingTime
                    });
                    let builtInWeapon = robot.weapons.find(e => e.name == "Skyward");
                    builtInWeapon.notActive = false;
                    builtInWeapon.ammo = builtInWeapon.maxammo;
                } else if (ability.name == "Absorption") {
                    robot.shields.push({
                        type: "purple",
                        absorption: true,
                        lastTime: ability.lastingTime,
                        health: 0
                    });
                    robot.effects.push({
                        name: "absorption",
                        abilityEffect: ability.name,
                        dmg: ability.dmg,
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Track") {
                    let enemies = getNearest(robot, 4e3, isAlly);
                    let target;
                    if (enemies.length && robot.isMe) {
                        enemies = enemies.filter(e => !e.invis);
                        let enemy = enemies.sort((a, b) => dist(robot.cursorLocation, a) - dist(robot.cursorLocation, b))[0];
                        if (enemy) {
                            target = enemy;
                        }
                    } else if (robot.target) {
                        target = robot.target;
                    }
                    if (target) {
                        target.effects.push({
                            name: "lockdown",
                            lastTime: 8e3,
                            neg: true
                        });
                        target.effects.push({
                            name: "track",
                            lastTime: 8e3,
                            defensePoints: ability.abilityDefensePoints,
                            deathmark: ability.deathmark,
                            neg: true
                        });
                    }
                } else if (ability.name == "Full Action" && robot.name == "Kid") {
                    for (let i = 0; i < robot.weapons.length; i++) {
                        let weapon = robot.weapons[i];
                        weapon.notActive = false;
                    }
                    robot.effects.push({
                        name: "defense points",
                        amount: ability.abilityDefensePoints,
                        abilityEffect: ability.name,
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Stove") {
                    robot.effects.push({
                        name: "stove",
                        abilityEffect: ability.name,
                        dmg: ability.dmg,
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Phalanx Mode") {
                    for (let i = 0; i < robot.shields.length; i++) {
                        let shield = robot.shields[i];
                        if (shield.baseShield) {
                            if (shield.dir == Math.PI / 2.5) {
                                shield.dir = 0.523598775;
                            } else if (shield.dir == -Math.PI / 2.5) {
                                shield.dir = -0.523598775;
                            } else if (shield.dir == 0.523598775) {
                                shield.dir = Math.PI / 2.5;
                            } else if (shield.dir == -0.523598775) {
                                shield.dir = -Math.PI / 2.5;
                            }
                        }
                    }
                } else if (ability.name == "Ultimate Reflector") {
                    robot.effects.push({
                        name: "reflector",
                        return: .25,
                        block: 1 - defensePointsToResistance(ability.abilityDefensePoints),
                        abilityEffect: "Ultimate Reflector",
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Overpower") {
                    robot.effects.push({
                        name: "shield break",
                        lastTime: ability.lastingTime
                    });
                    robot.effects.push({
                        name: "attack",
                        abilityEffect: ability.name,
                        power: ability.damageIncrease,
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Defense Breach") {
                    if (robot.shieldBreakOnDefenseBreach) {
                        robot.effects.push({
                            name: "shield break",
                            lastTime: ability.lastingTime
                        });
                    }
                    robot.effects.push({
                        name: "defense breach",
                        abilityEffect: "Defense Breach",
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Debut") {
                    let moveDir = doMoveStuff(robot, isAlly);
                    robot.effects.push({
                        name: "dash",
                        lastTime: 250,
                        abilityEffect: "Debut",
                        dir: (robot.isMe ? robot.dir : moveDir)
                    });
                    robot.effects.unshift({
                        name: "speed",
                        power: 1,
                        abilityEffect: "Debut",
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Blink") {
                    robot.effects.push({
                        name: "Blink",
                        abilityEffect: "Blink",
                        lastTime: ability.lastingTime,
                        lastPressed: Date.now(),
                        translocator: {
                            x: robot.x,
                            y: robot.y
                        },
                    });
                } else if (ability.name == "Dark Light") {
                    robot.effects.push({
                        name: "dark light",
                        deathmark: ability.deathmark,
                        lastTime: ability.lastingTime
                    })
                } else if (ability.name == "Mastermind") {
                    robot.effects.push({
                        name: "speed",
                        power: 2.6,
                        abilityEffect: "Mastermind",
                        lastTime: ability.lastingTime
                    });

                    if (robot.mastermindV2) {
                        robot.effects.push({
                            name: "stealth",
                            abilityEffect: "Mastermind",
                            lastTime: ability.lastingTime / 2
                        });
                    }

                    robot.effects.push({
                        name: "attack",
                        power: .4,
                        abilityEffect: "Mastermind",
                        lastTime: ability.lastingTime
                    });

                    robot.effects.push({
                        name: "defense mit",
                        abilityEffect: "Mastermind",
                        lastTime: ability.lastingTime
                    });

                    robot.effects.push({
                        name: "healing",
                        grayDamage: 1,
                        type: "percent",
                        power: .14,
                        abilityEffect: "Mastermind",
                        rate: 1e3,
                        lastTime: ability.lastingTime
                    });

                    robot.shields.push({
                        type: "yellow",
                        maxhealth: 1700e3 * (robot.mastermindV2 * 1.2),
                        health: 1700e3 * (robot.mastermindV2 * 1.2),
                        lastTime: ability.lastingTime,
                        regen: 0
                    });

                    for (let i = 0; i < robot.drones.length; i++) {
                        let drone = robot.drones[i];

                        if (drone.name.includes("Dux")) {
                            drone.effects.push({
                                name: "speed",
                                amount: 6,
                                lastTime: ability.lastingTime
                            })
                        }
                    }
                } else if (ability.name == "Annihilation Mode") {
                    robot.effects.push({
                        name: "attack",
                        power: 1.6,
                        abilityEffect: "Annihilation Mode",
                        lastTime: ability.lastingTime
                    });

                    for (let i = 0; i < 5; i++) robot.effects.unshift({
                        name: "counter suppression",
                        lastTime: 15e3,
                        power: .999999,
                        durationOfSuppression: 6e3
                    });

                    robot.grayDamage = Math.max(0, robot.grayDamage - ability.healingPower);

                    changeHealth(robot, {
                        amount: ability.healingPower
                    });

                    robot.effects.push({
                        name: "speed",
                        power: 3.6,
                        abilityEffect: "Annihilation Mode",
                        lastTime: ability.lastingTime
                    });

                    robot.effects.push({
                        name: "shield break",
                        lastTime: ability.lastingTime * 3
                    });
                }
            } else if (robot.effects.find(e => e.name == "Blink" && Date.now() - e.lastPressed >= 2e3)) {
                let effect = robot.effects.find(e => e.name == "Blink" && Date.now() - e.lastPressed >= 2e3);
                effect.lastTime = 0;
                robot.x = effect.translocator.x;
                robot.y = effect.translocator.y;
            }
        } else if (ability.name == "Cold Pulse" || ability.name == "Mute Blast") {
            if (ability.abilityReload == 0 && !robot.effects.find(e => e.deathGamble)) {
                doWonderworkerSkill(robot, ability);
                if (ability.name == "Mute Blast") {
                    domains.push({
                        name: "mutefield",
                        x: robot.isMe ? robot.cursorLocation.x : robot.motherTarget.x,
                        y: robot.isMe ? robot.cursorLocation.y : robot.motherTarget.y,
                        scale: 300,
                        duration: ability.abilityEffectDuration,
                        lastingTime: 1e3,
                        oldLast: 1e3,
                        isAlly: isAlly,
                        owner: robot
                    });
                } else {
                    bombeffect.push({
                        x: robot.x,
                        y: robot.y,
                        scale: 0,
                        maxScale: 1200,
                        color: "white"
                    });
                    let near = [];
                    if (hasPlayers()) {
                        for (let t = 0; t < players.length; t++) {
                            let player = players[t].robots[players[t].robotIndex];
                            if (player && players[t].isAlly != isAlly) {
                                if (Math.hypot(player.y - robot.y, player.x - robot.x) <= 1200 + player.scale) {
                                    near.push(player);
                                }
                            }
                        }
                    } else {
                        near = enemies.filter(e => Math.hypot(e.y - robot.y, e.x - robot.x) <= 1200 + e.scale);
                    }
                    for (let i = 0; i < near.length; i++) {
                        let enemy = near[i];
                        if (enemy) {
                            if (enemy.effects == null) enemy.effects = [];
                            changeHealth(enemy, {
                                amount: -ability.dmg
                            }, robot.isMe, robot);
                            enemy.effects.push({
                                name: "freeze",
                                neg: true,
                                lastTime: 3e3
                            });
                        }
                    }
                    if (near.length) {
                        changeHealth(robot, {
                            amount: (5000 * near.length)
                        }, robot.isMe, robot);
                    }
                }
                ability.abilityReload = ability.reload;
            }
        } else if (ability.name == "Blocking Matrix") {
            if (ability.abilityReload == 0) {
                doWonderworkerSkill(robot, ability);
                for (let i = 0; i < ability.effectAccumulation; i++) {
                    robot.effects.push({
                        name: "block",
                        lastTime: 1,
                        lastForever: true
                    });
                }
                ability.abilityReload = ability.reload;
            }
        } else if (ability.maxcharge) {
            if (ability.abilityLast == 0 && ability.charges > 0 && !robot.effects.find(e => e.name == "reflector" && e.abilityEffect == "Ultimate Reflector")) {
                doWonderworkerSkill(robot, ability);
                ability.charges--;
                if (ability.name != "Blink Support") ability.abilityLast = ability.lastingTime;
                let moveDir = doMoveStuff(robot, isAlly);
                if (ability.name == "Stealth Dash") {
                    robot.effects.push({
                        name: "stealth dash",
                        lastTime: 2500 + (robot.name.includes("Ultimate") ? -1e3 : 0),
                        dir: (robot.isMe ? robot.dir : moveDir)
                    });

                    if (robot.name.includes("Ultimate")) {
                        for (let i = 0; i < 10; i++) robot.effects.push({
                            name: "block",
                            lastTime: 30e3
                        });

                        robot.effects.filter(e => ["lockdown", "slowdown", "frag", "emp", "blind", "rust", "suppression"].includes(e.name)).forEach(e => {
                            e.lastTime = 0;
                        });

                        robot.effects.unshift({
                            name: "counter suppression",
                            lastTime: 15e3,
                            power: .999,
                            durationOfSuppression: 3e3
                        });

                        robot.effects.push({
                            name: "attack",
                            power: .02,
                            lastTime: 5e3
                        });

                        let gHealing = robot.maxhealth * .05;
                        let healing = robot.maxhealth * .1;
                        robot.grayDamage = Math.max(robot.grayDamage - gHealing, 0);
                        changeHealth(robot, {
                            amount: healing
                        }, false, robot);

                        robot.effects.push({
                            name: "shield break",
                            lastTime: 2e3
                        });

                        for (let i = 0; i < 2; i++) robot.effects.unshift({
                            name: "cleanse",
                            lastTime: 1,
                            lastForever: true
                        });

                        robot.shields.push({
                            type: "purple",
                            health: 0,
                            lastTime: 2e3
                        });

                        robot.shields.push({
                            type: "yellow",
                            maxhealth: 75e3,
                            health: 75e3,
                            regen: 0
                        });
                    }
                } else if (ability.name == "Phase Shift") {
                    robot.effects.push({
                        name: "phase shift",
                        abilityEffect: "Phase Shift",
                        speed: robot.name == "Indra" ? .5 : robot.name == "Magenta Hexagon" ? .8 : undefined,
                        lastTime: ability.lastingTime
                    });
                    if (robot.name == "Magenta Hexagon") {
                        let target = robot.target;
                        if (robot.isMe) {
                            let enemies = getNearest(robot, 1500, isAlly);
                            if (enemies.length) {
                                enemies = enemies.filter(e => !e.invis);
                                target = enemies.sort((a, b) => dist(robot.cursorLocation, a) - dist(robot.cursorLocation, b))[0];
                            }
                        }
                        if (target && dist(target, robot) <= 1500 + target.scale) {
                            if (robot.bonds == null) robot.bonds = [];
                            target.effects.push({
                                name: "slowdown",
                                neg: true,
                                power: .2,
                                lastTime: 6e3
                            });
                            robot.bonds.push({
                                target: target,
                                name: "Lasso",
                                duration: 6e3,
                                isAlly: isAlly,
                                owner: robot
                            });
                        }
                    } else if (robot.name == "Sharanga") {
                        for (let i = 0; i < robot.weapons.length; i++) {
                            let weapon = robot.weapons[i];
                            weapon.disabled = true;
                        }
                    }
                } else if (ability.name == "Dash") {
                    robot.effects.push({
                        name: "dash",
                        lastTime: 350,
                        dir: (robot.isMe ? robot.dir : moveDir)
                    });
                } else if (ability.name == "Fortify") {
                    let increase = 1;
                    let fortifier = robot.modules.filter(e => e.shieldHealth);
                    fortifier.forEach(e => {
                        increase += e.shieldHealth;
                    });
                    robot.shields.push({
                        type: robot.level >= 13 ? "yellow" : "energy",
                        maxhealth: ability.shieldHp * increase,
                        health: ability.shieldHp * increase
                    });
                } else if (ability.name == "Roulette Strike") {
                    robot.effects.push({
                        name: "defense points",
                        amount: 25,
                        lastTime: 15e3
                    });
                    robot.effects.filter(e => e.name == "rust").forEach(e => {
                        e.lastTime *= .25;
                    });
                    changeHealth(robot, {
                        amount: robot.maxhealth * .1
                    }, false, robot);
                    projectiles.push({
                        projType: "energy",
                        x: robot.x,
                        y: robot.y,
                        oldX: robot.x,
                        oldY: robot.y,
                        velx: 0,
                        vely: 0,
                        scale: 30,
                        avoidBuildings: robot.avoidBuildings,
                        speed: 0.25,
                        dmg: ability.dmg,
                        dotEffect: {
                            name: "dot",
                            dmg: ability.dotDamage,
                            last: 5e3,
                            owner: robot
                        },
                        onKillDomain: {
                            name: "Roulette Strike",
                            dmg: Math.round(ability.dotDamage / 10),
                            isAlly: isAlly,
                            increaseSpeedOfPinkishRedAbility: (robot.increaseSpeedOfPinkishRedAbility == undefined ? 0 : robot.increaseSpeedOfPinkishRedAbility),
                            last: 10e3
                        },
                        range: 1400,
                        dir: robot.target ? Math.atan2(robot.target.y - robot.y, robot.target.x - robot.x) : robot.dir,
                        isAlly: isAlly,
                        color: `rgb(128, 0, 128)`,
                        owner: robot,
                        weaponOwner: {
                            name: "Roulette Strike",
                            level: robot.level
                        }
                    });
                } else if (ability.name == "Blink Support") {
                    ability.abilityLast = 2e3;
                    let healthIncreased = robot.normalMaxHealth * (ability.abilityHealthMulti - 1);
                    let thingy = robot.grayDamage / robot.maxhealth;
                    let thing2 = robot.health / robot.maxhealth;
                    robot.maxhealth += healthIncreased;
                    robot.health = thing2 * robot.maxhealth;
                    robot.grayDamage = thingy * robot.maxhealth;
                    robot.effects.push({
                        name: "Blink Support",
                        healthIncreased: healthIncreased,
                        amount: ability.abilityDefensePoints,
                        lastTime: ability.lastingTime
                    });
                    let scale = 40;
                    let duration = ability.lastingTime * 2 * (robot.___________increaseTurretDuration || 1);
                    let range = 2e3;
                    let rate = 75;
                    buildings.push({
                        dmg: ability.dmg,
                        range: range,
                        rate: rate,
                        name: "Blink Turret T1",
                        scale: scale,
                        x: robot.x + Math.cos((robot.target ? Math.atan2(robot.target.y - robot.y, robot.target.x - robot.x) : robot.dir) + (Math.PI / 4)) * (robot.scale * 2),
                        y: robot.y + Math.sin((robot.target ? Math.atan2(robot.target.y - robot.y, robot.target.x - robot.x) : robot.dir) + (Math.PI / 4)) * (robot.scale * 2),
                        owner: robot,
                        duration: duration,
                        isAlly: isAlly
                    });
                    buildings.push({
                        dmg: ability.dmg / 10,
                        range: range,
                        rate: rate * 3,
                        scale: scale,
                        name: "Blink Turret T2",
                        x: robot.x + Math.cos((robot.target ? Math.atan2(robot.target.y - robot.y, robot.target.x - robot.x) : robot.dir) - (Math.PI / 4)) * (robot.scale * 2),
                        y: robot.y + Math.sin((robot.target ? Math.atan2(robot.target.y - robot.y, robot.target.x - robot.x) : robot.dir) - (Math.PI / 4)) * (robot.scale * 2),
                        owner: robot,
                        duration: duration,
                        isAlly: isAlly
                    });
                } else if (ability.name == "Remote Repair") {
                    buildings.push({
                        healing: ability.healingPower,
                        range: 600,
                        rate: 250,
                        scale: 50,
                        name: "Remote Repair",
                        x: (robot.cursorLocation ? robot.cursorLocation.x : robot.target ? robot.target.x : robot.x),
                        y: (robot.cursorLocation ? robot.cursorLocation.y : robot.target ? robot.target.y : robot.y),
                        owner: robot,
                        duration: 20e3,
                        isAlly: isAlly
                    });
                } else if (ability.name == "Active Support") {
                    let tmpx = (robot.cursorLocation ? robot.cursorLocation.x : robot.target ? robot.target.x : robot.x);
                    let tmpy = (robot.cursorLocation ? robot.cursorLocation.y : robot.target ? robot.target.y : robot.y);
                    let near = getNearest(robot, 2e3, isAlly, true);
                    let nearest = near.sort((a, b) => dist(a, {
                        x: tmpx,
                        y: tmpy
                    }) - dist(b, {
                        x: tmpx,
                        y: tmpy
                    }))[0];
                    if (nearest) {
                        robot.bonds.push({
                            target: nearest,
                            name: "Active Support",
                            duration: 12e3,
                            owner: robot
                        });
                        robot.effects.push({
                            name: "defense points",
                            amount: ability.defensePointsIncrease,
                            lastTime: 30e3
                        });
                        nearest.effects.push({
                            name: "healing",
                            type: "percent",
                            grayDamage: .25,
                            power: ability.healingPercent,
                            owner: robot,
                            rate: 500,
                            lastTime: 12e3
                        });
                        nearest.effects.push({
                            name: "defense points",
                            amount: ability.defensePointsIncrease,
                            lastTime: 12e3
                        });
                        nearest.effects.push({
                            name: "speed",
                            power: 1,
                            lastTime: 12e3
                        });
                    }
                    robot.effects.push({
                        name: "healing",
                        type: "percent",
                        grayDamage: .25,
                        power: ability.healingPercent,
                        rate: 500,
                        lastTime: 12e3
                    });
                } else if (ability.name == "Frog Splash") {
                    let amount = robot.maxhealth * .1;
                    // robot.grayDamage = Math.max(0, robot.grayDamage - (amount * .15));
                    changeHealth(robot, {
                        amount: amount
                    }, false, robot);
                    robot.effects.push({
                        name: "reflector",
                        block: .4,
                        return: .1,
                        abilityEffect: "Frog Splash",
                        lastTime: ability.lastingTime
                    });
                    robot.effects.push({
                        name: "dash",
                        lastTime: ability.lastingTime,
                        dmg: ability.dmg,
                        abilityEffect: "Frog Splash",
                        dir: (robot.isMe ? robot.dir : moveDir)
                    });
                } else if (ability.name == "Comet Splash") {
                    robot.effects.push({
                        name: "dash",
                        lastTime: 3e3,
                        dmg: ability.dmg,
                        abilityEffect: "Comet Splash",
                        dir: (robot.isMe ? robot.dir : moveDir)
                    });
                    robot.effects.push({
                        name: "reflector",
                        block: .7,
                        return: .2,
                        abilityEffect: "Comet Splash",
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Nuclear Rocket Shot") {
                    if (robot.moreDamageOnNuclearRocketShot) {
                        robot.effects.push({
                            name: "attack",
                            power: robot.moreDamageOnNuclearRocketShot,
                            lastTime: 7e3
                        });
                    }

                    projectiles.push({
                        projType: "rocket",
                        x: robot.x,
                        y: robot.y,
                        oldX: robot.x,
                        oldY: robot.y,
                        velx: 0,
                        vely: 0,
                        scale: 30,
                        avoidBuildings: true,
                        speed: 0.3,
                        dmg: ability.dmg,
                        aoeRange: 60,
                        range: 4e3,
                        dir: robot.target ? Math.atan2(robot.target.y - robot.y, robot.target.x - robot.x) : robot.dir,
                        isAlly: isAlly,
                        color: "./images/bullets/rocket.png",
                        owner: robot,
                        defensePointsBypass: 0,
                        weaponOwner: {
                            name: "Nuclear Rocket Shot",
                            level: robot.level
                        }
                    });
                } else if (ability.name == "Stampede") {
                    robot.effects.push({
                        name: "stampede",
                        abilityEffect: ability.name,
                        dmg: ability.dmg,
                        lastTime: ability.lastingTime
                    });
                    robot.effects.push({
                        name: "anti defense mig",
                        lastTime: ability.lastingTime
                    });
                } else if (ability.name == "Hook") {
                    robot.effects.push({
                        name: "stampede",
                        a: true,
                        lastTime: 8e3
                    });

                    robot.effects.push({
                        name: "dash",
                        lastTime: 550,
                        abilityEffect: "Frog Splash",
                        dir: (robot.isMe ? robot.dir : moveDir)
                    });
                }
            } else if (ability.name == "Clain Blink") {
                let effect = robot.effects.find(e => e.name == "Clain Blink");
                if (effect && ability.charges <= 0 && Date.now() - effect.lastPressed >= 3e3) {
                    doAbilityEndFunction(robot, 0, effect, ability);
                } else if (effect && Date.now() - effect.lastPressed >= 3e3) {
                    doWonderworkerSkill(robot, ability);
                    ability.charges--;
                    effect.lastPressed = Date.now();
                    let tmpx = robot.isMe ? robot.cursorLocation.x : robot.movementTarget.x;
                    let tmpy = robot.isMe ? robot.cursorLocation.y : robot.movementTarget.y
                    doBlinkAbility(robot, tmpx, tmpy);
                    let shield = robot.shields.find(e => e.clainBlink);
                    if (shield) {
                        shield.maxhealth += ability.shieldHp;
                        shield.health += ability.shieldHp;
                    } else {
                        robot.shields.push({
                            type: "yellow",
                            clainBlink: true,
                            maxhealth: ability.shieldHp,
                            health: ability.shieldHp,
                            regen: 0
                        });
                    }
                }
            } else if (ability.name == "Frog Splash" || ability.name == "Comet Splash") {
                if (robot.effects.find(e => e.name == "dash" && e.abilityEffect == ability.name && (ability.name == "Comet Splash" ? e.lastTime < 2750 : e.lastTime < 800))) {
                    robot.effects.find(e => e.name == "dash" && e.abilityEffect == ability.name && (ability.name == "Comet Splash" ? e.lastTime < 2750 : e.lastTime < 800)).lastTime = 0;
                    robot.velx = 0;
                    robot.vely = 0;
                    if (ability.name == "Comet Splash") {
                        robot.effects.find(e => e.name == "reflector" && e.abilityEffect == ability.name).lastTime = 5e3;
                        ability.abilityLast = 5e3;
                    }
                }
            }
        } else if (ability.name == "Nuclear Strike" || ability.name == "Domain Expansion: Infinite Void" || ability.name == "Dismantle") {
            if (ability.abilityReload == 0) {
                doWonderworkerSkill(robot, ability);
                if (ability.name == "Nuclear Strike") {
                    domains.push({
                        x: robot.cursorLocation ? robot.cursorLocation.x : robot.target.x,
                        y: robot.cursorLocation ? robot.cursorLocation.y : robot.target.y,
                        scale: 600,
                        isAlly: isAlly,
                        owner: robot,
                        name: "Nuclear Strike",
                        lastingTime: 4e3
                    });
                } else if (ability.name == "Dismantle") {
                    domains.push({
                        x: robot.x,
                        y: robot.y,
                        scale: 600 * (robot.domainRangeIncrease ? (1 + robot.domainRangeIncrease) : 1),
                        isAlly: isAlly,
                        owner: robot,
                        ownerName: robot.name,
                        name: "Dismantle",
                        lastingTime: ability.lastingTime
                    });
                } else {
                    domains.push({
                        x: robot.x,
                        y: robot.y,
                        scale: 500,
                        isAlly: isAlly,
                        owner: robot,
                        ownerName: robot.name,
                        name: "Infinite Void",
                        lastingTime: ability.lastingTime
                    });
                }
                ability.abilityReload = ability.reload;
            }
        }
    }
    function doAbilityFunction(robot, delta, isAlly, ability) {
        if (ability.name == "Divine Judgement") {
            (!robot.isMe ? robot.deltaTimer -= delta : deltaTimer -= delta);
            if ((!robot.isMe ? robot.deltaTimer <= 0 : deltaTimer <= 0)) {
                (!robot.isMe ? robot.deltaTimer -= delta : deltaTimer -= delta);
                projectiles.push({
                    defensePointsBypass: 0,
                    x: robot.x,
                    y: robot.y,
                    oldX: robot.x,
                    oldY: robot.y,
                    velx: 0,
                    vely: 0,
                    scale: 25,
                    speed: 0.3,
                    projType: "energy",
                    antiTier4_5: true,
                    dmg: ability.dmg,
                    range: 2000,
                    dir: robot.dir,
                    color: "./images/bullets/energy_bullet.png",
                    isAlly: isAlly,
                    owner: robot,
                    weaponOwner: {
                        name: "Divine Judgement",
                        level: robot.level
                    }
                });
            }
        } else if (ability.name == "Self Heal") {
            (!robot.isMe ? robot.deltaTimer -= delta : deltaTimer -= delta);
            if ((!robot.isMe ? robot.deltaTimer <= 0 : deltaTimer <= 0)) {
                let amount = robot.maxhealth * (robot.name == "Pink Circle" ? 0.1 : .025);
                changeHealth(robot, {
                    amount: Math.floor(amount)
                }, robot.isMe ? true : false, robot);
                (!robot.isMe ? robot.deltaTimer = 5e2 : deltaTimer = 5e2);
            }
        } else if (ability.name == "Stealth") {
            robot.invis = true;
            robot.abilitySpeedMulti = 2;
        } else if (ability.name == "Retribution") {
            if (robot.name == "Ultimate Tan Pentagon") {
                robot.abilitySpeedMulti = 1.25;
            }
            if (robot.shields.length == 0) {
                robot.shields.push({
                    type: "purple",
                    health: 0
                });
            }
            if (ability.abilityLast <= (robot.name == "Ultimate Tan Pentagon" ? 8e3 : 4e3)) {
                let shield = robot.shields.find(e => e.type == "purple" && !e.droneShield);
                (!robot.isMe ? robot.deltaTimer -= delta : deltaTimer -= delta);
                if ((!robot.isMe ? robot.deltaTimer <= 0 : deltaTimer <= 0)) {
                    let amount = robot.name == "Ultimate Tan Pentagon" ? 25 : 100;
                    (!robot.isMe ? robot.deltaTimer = amount : deltaTimer = amount);
                    let dmgMulti = 1 + (Math.floor((shield ? shield.health : 0) / 5e3) * 0.075);
                    dmgMulti = Math.min(dmgMulti, 2);
                    let dir = 0;
                    if (robot.weaponSlotThingyAbility == null) robot.weaponSlotThingyAbility = 0;
                    if (robot.weaponSlotThingyAbility % 4 == 0) {
                        x = robot.x + Math.cos(robot.dir + 1.57) * (robot.scale - 7.5);
                        y = robot.y + Math.sin(robot.dir + 1.57) * (robot.scale - 7.5);
                    } else if (robot.weaponSlotThingyAbility % 4 == 1) {
                        x = robot.x + Math.cos(robot.dir + 0.39) * (robot.scale - 7.5);
                        y = robot.y + Math.sin(robot.dir + 0.39) * (robot.scale - 7.5);
                    } else if (robot.weaponSlotThingyAbility % 4 == 2) {
                        x = robot.x + Math.cos(robot.dir - 0.39) * (robot.scale - 7.5);
                        y = robot.y + Math.sin(robot.dir - 0.39) * (robot.scale - 7.5);
                    } else {
                        x = robot.x + Math.cos(robot.dir - 1.57) * (robot.scale - 7.5);
                        y = robot.y + Math.sin(robot.dir - 1.57) * (robot.scale - 7.5);
                    }
                    robot.weaponSlotThingyAbility++;
                    if (robot.isMe) {
                        let offsetX = x - offset.x;
                        let offsetY = y - offset.y;
                        let mosX = (mouseX / window.innerWidth) * maxScreen.x;
                        let mosY = (mouseY / window.innerHeight) * maxScreen.y;
                        dir = Math.atan2(mosY - offsetY, mosX - offsetX);
                    } else if (robot.target) {
                        dir = Math.atan2(robot.target.y - y, robot.target.x - x);
                    }
                    projectiles.push({
                        x: x,
                        y: y,
                        oldX: x,
                        oldY: y,
                        velx: 0,
                        vely: 0,
                        scale: 25,
                        speed: 0.2,
                        projType: "energy",
                        dmg: ability.dmg * dmgMulti,
                        range: robot.name == "Ultimate Tan Pentagon" ? 1600 : 800,
                        dir: dir,
                        bypassReflector: (robot.name == "Ultimate Tan Pentagon" ? true : false),
                        defensePointsBypass: robot.name == "Ultimate Tan Pentagon" ? 0 : undefined,
                        color: "./images/bullets/energy_bullet.png",
                        isAlly: isAlly,
                        owner: robot,
                        weaponOwner: {
                            name: "Retribution",
                            level: robot.level
                        }
                    });
                }
            }
        } else if (ability.name == "Ultimate Defense") {
            robot.turnDmgIntoDOT = true;
            (!robot.isMe ? robot.deltaTimer -= delta : deltaTimer -= delta);
            if ((!robot.isMe ? robot.deltaTimer <= 0 : deltaTimer <= 0)) {
                let amount = robot.maxhealth * 0.025;
                changeHealth(robot, {
                    amount: Math.floor(amount)
                }, true);
                (!robot.isMe ? robot.deltaTimer = 500 : deltaTimer = 500);
            }
        } else if (ability.name == "Dragon Flight") {
            robot.avoidBuildings = true;
            if (!robot.name.includes("Ultimate")) robot.builtInDefensePoints = 9000;
            robot.abilitySpeedMulti = 3;
            (!robot.isMe ? robot.deltaTimer -= delta : deltaTimer -= delta);
            if ((!robot.isMe ? robot.deltaTimer <= 0 : deltaTimer <= 0)) {
                (!robot.isMe ? robot.deltaTimer = 50 : deltaTimer = 50);
                for (let asdasd = 0; asdasd < (robot.name.includes("Ultimate") ? 3 : 2); asdasd++) projectiles.push({
                    x: robot.x,
                    y: robot.y,
                    oldX: robot.x,
                    oldY: robot.y,
                    velx: 0,
                    vely: 0,
                    scale: 25,
                    speed: robot.name.includes("Ultimate") ? 0.25 : 0.15,
                    avoidBuildings: true,
                    dmg: ability.dmg,
                    range: 1200,
                    projType: "normal",
                    dir: robot.dir + getRandomOffset(5),
                    color: robot.name.includes("Ultimate") ? `rgb(0, ${Math.random() > .5 ? 0 : 255}, 255)` : "#ff0000",
                    isAlly: isAlly,
                    dotEffect: {
                        name: "dot",
                        last: robot.name.includes("Ultimate") ? 10e3 : 3e3,
                        dmg: ability.dotDamage,
                        owner: robot
                    },
                    blastEffect: ability.effectIncrease ? {
                        name: "blast",
                        last: 7e3,
                        power: ability.effectIncrease
                    } : undefined,
                    aoeRange: 50,
                    defensePointsBypass: .25,
                    owner: robot,
                    weaponOwner: {
                        name: `${robot.name.includes("Ultimate") ? "<span style='color: #ffff00;'>ULTIMATE</span> " : ""}Dragon Breathe`,
                        level: robot.level
                    }
                });
            }
        } else if (ability.name == "Full Action" && robot.name != "Kid") {
            robot.builtInDefensePoints = robot.name == "Teal Circle" ? 200 : 60;
        } else if (ability.name == "Shield Regeneration") {
            robot.shieldRegen = robot.name == "Cyan Pentagon" ? 0.075 : .1;
            if (robot.name == "Cyan Pentagon") {
                robot.abilitySpeedMulti = 1.5;
            }
        } else if (ability.name == "Clear Sky") {
            robot.avoidBuildings = true;
            if (robot.shields.length == 0) {
                robot.shields.push({
                    type: "purple",
                    health: 0
                });
            }
            (!robot.isMe ? robot.deltaTimer -= delta : deltaTimer -= delta);
            robot.abilitySpeedMulti = 3;
            if ((!robot.isMe ? robot.deltaTimer <= 0 : deltaTimer <= 0)) {
                let shieldDmg = robot.shields.find(e => e.type == "purple" && !e.droneShield);
                if (shieldDmg) {
                    shieldDmg = shieldDmg.health;
                } else {
                    shieldDmg = 0;
                }
                if (ability.projId == null) ability.projId = 0;
                let x, y, dir, scale = 20;
                if (ability.projId % 4 == 0) {
                    x = robot.x + Math.cos(robot.dir + 1.57) * (robot.scale - 7.5);
                    y = robot.y + Math.sin(robot.dir + 1.57) * (robot.scale - 7.5);
                } else if (ability.projId % 4 == 1) {
                    x = robot.x + Math.cos(robot.dir + 0.39) * (robot.scale - 7.5);
                    y = robot.y + Math.sin(robot.dir + 0.39) * (robot.scale - 7.5);
                } else if (ability.projId % 4 == 2) {
                    x = robot.x + Math.cos(robot.dir - 0.39) * (robot.scale - 7.5);
                    y = robot.y + Math.sin(robot.dir - 0.39) * (robot.scale - 7.5);
                } else {
                    x = robot.x + Math.cos(robot.dir - 1.57) * (robot.scale - 7.5);
                    y = robot.y + Math.sin(robot.dir - 1.57) * (robot.scale - 7.5);
                }
                if (robot.isMe) {
                    let offsetX = x - offset.x;
                    let offsetY = y - offset.y;
                    let mosX = (mouseX / window.innerWidth) * maxScreen.x;
                    let mosY = (mouseY / window.innerHeight) * maxScreen.y;
                    dir = Math.atan2(mosY - offsetY, mosX - offsetX);
                } else if (robot.target) {
                    dir = Math.atan2(robot.target.y - y, robot.target.x - x);
                }
                ability.projId++;
                projectiles.push({
                    x: x,
                    y: y,
                    oldX: x,
                    oldY: y,
                    velx: 0,
                    projType: "energy",
                    vely: 0,
                    scale: scale,
                    speed: 0.25,
                    dmg: ability.dmg * (1 + (Math.floor(shieldDmg / 7e3) * .05)),
                    range: 1600,
                    dir: dir,
                    isAlly: isAlly,
                    color: "./images/bullets/red_bullet.png",
                    avoidBuildings: true,
                    bypassReflector: true,
                    blastEffect: {
                        name: "blast",
                        last: 7e3,
                        power: ability.effectIncrease * Math.min(1 + (Math.floor(shieldDmg / 3e3) * .04), 10)
                    },
                    aoeRange: 45,
                    owner: robot,
                    weaponOwner: {
                        name: "Clear Sky",
                        level: robot.level
                    }
                });
                (!robot.isMe ? robot.deltaTimer = ability.fireRate : deltaTimer = ability.fireRate);
            }
        } else if (ability.name == "Ferocity") {
            robot.invis = true;
            robot.abilitySpeedMulti = 1.5;
            (!robot.isMe ? robot.deltaTimer -= delta : deltaTimer -= delta);
            if ((!robot.isMe ? robot.deltaTimer <= 0 : deltaTimer <= 0)) {
                projectiles.push({
                    x: robot.x,
                    y: robot.y,
                    oldX: robot.x,
                    oldY: robot.y,
                    velx: 0,
                    projType: "energy",
                    vely: 0,
                    scale: 25,
                    speed: 0.25,
                    dmg: ability.dmg,
                    range: 1600,
                    dir: robot.dir,
                    isAlly: isAlly,
                    color: "./images/bullets/energy_bullet.png",
                    owner: robot,
                    execute: ability.executionThreshold,
                    weaponOwner: {
                        name: "Execute Gun",
                        level: robot.level
                    }
                });
                (!robot.isMe ? robot.deltaTimer = 500 : deltaTimer = 500);
            }
        }
    }
    function doAbilityEndStuff(robot, delta, effect, ability) {
        if (!ability.maxcharge) {
            ability.abilityReload = ability.reload;
        }
        if (ability.name == "Clear Sky" || ability.name == "Retribution" || ability.name == "Paladin") {
            if (ability.name == "Paladin") {
                if (robot.shields[0] && robot.shields[0].health > 0) {
                    let increase = Math.min(robot.shields[0].health / 25, 100e3);
                    if (robot.normalMaxHealth) {
                        robot.normalMaxHealth += increase;
                    }
                    robot.maxhealth += increase;
                    changeHealth(robot, {
                        amount: increase * 5
                    }, robot.isMe ? true : false, robot);
                }
            }
            if (ability.name == "Clear Sky") {
                let shield = robot.shields.find(e => e.type == "purple");
                if (shield) {
                    let h = shield.health;
                    robot.effects.push({
                        amount: 100 + Math.floor(h / 15e3),
                        name: "defense points",
                        lastTime: 7e3
                    });
                    changeHealth(robot, {
                        amount: h / 10,
                    }, false, robot);
                }
                if (robot.isMe) transitionProgress = 0;
                robot.flightVisualData = .0001;
            }
            robot.shields.forEach(e => {
                if (!e.baseShield) {
                    e.kill = true;
                }
            });
        }
        if (robot.name == "Sharanga") {
            for (let i = 0; i < robot.weapons.length; i++) {
                let weapon = robot.weapons[i];
                weapon.disabled = false;
            }
        }
        if (ability.name == "Full Action" && robot.name == "Kid") {
            for (let i = 0; i < robot.weapons.length; i++) {
                let weapon = robot.weapons[i];
                if (weapon.type == "Heavy") {
                    weapon.notActive = true;
                    weapon.ammo = 0;
                }
            }
        }
        if (ability.name == "Dragon Flight" || ability.name == "Skyward") {
            if (robot.isMe) {
                transitionProgress = 0;
            }
            robot.flightVisualData = ability.name == "Skyward" ? 0.0005 : 0.0001;
        }
        if (ability.name == "Reinforce Hull") {
            let healthIncreased = robot.normalMaxHealth * (ability.abilityHealthMulti - 1);
            let grayIncreased = robot.oldGrayDamage * (ability.abilityHealthMulti - 1);
            robot.grayDamage -= grayIncreased;
            robot.grayDamage /= 4;
            let multi = robot.health / robot.maxhealth;
            robot.maxhealth -= healthIncreased;
            robot.health = multi * robot.maxhealth;
        }
        if (ability.name == "Clain Blink" && effect) {
            robot.x = effect.translocator.x;
            robot.y = effect.translocator.y;
            effect.lastTime = 0;
            ability.abilityLast = 0;
            ability.abilityReload = ability.reload;
            ability.charges = undefined;
            ability.maxcharge = undefined;
        }
        if (ability.name == "Barrier Field") {
            let shield = robot.shields.find(e => e.type == "purple shield");
            if (shield) {
                shield.kill = true;
            }
        }
        if (robot.onAbilityEndFix) {
            let amount = (robot.maxhealth - robot.health) - robot.grayDamage;
            changeHealth(robot, {
                amount: amount * robot.onAbilityEndFix
            }, false, robot);
        }
        robot.effects.forEach(e => {
            if (e.endAfterAbilityIsEnd) {
                e.lastForever = false;
            }
        });
    }
    function doAbilityEndFunction(robot, delta, effect, ability) {
        if (!ability) {
            for (let i = 0; i < robot.abilities.length; i++) {
                robot.abilities[i].abilityLast = 0;
                doAbilityEndStuff(robot, delta, effect, robot.abilities[i]);
            }
        } else {
            ability.abilityLast = 0;
            doAbilityEndStuff(robot, delta, effect, ability);
        }
    }
    function doReviveFunction(robot) {
        if (robot.name == "Cyan Pentagon") {
            let baseShield = robot.shields.find(e => e.baseShield);
            baseShield.health = baseShield.maxhealth;
        } else if (robot.name == "Ultimate Green Circle") {
            robot.maxhealth *= 1.5;
        }
        robot.killed = false;
        robot.grayDamage *= (1 - robot.revive);
        robot.abilityReload = 0;
        robot.health += robot.maxhealth * robot.revive;
        robot.revive = 0;
    }
    function doOnDamageTakeStuff(robot) {
        if (robot.lastHealth == null) robot.lastHealth = robot.maxhealth;
        if (robot.lastHealth - robot.health > 0) { }
        robot.lastHealth = robot.health;
    }
    function doPassiveAuraHealing(robot, isAlly, delta) {
        if (!robot.healingAura) return;
        if (robot.healingAuraLast == null) robot.healingAuraLast = 0;
        robot.healingAuraLast -= delta;
        if (robot.healingAuraLast <= 0) {
            robot.healingAuraLast = (robot.effects.find(e => e.name == "Ultimate Mending") ? 250 : 1e3);
            for (let i = 0; i < players.length; i++) {
                let player = players[i].robots[players[i].robotIndex];
                if (player && players[i].isAlly == isAlly) {
                    if (Math.hypot(player.y - robot.y, player.x - robot.x) <= 600 + player.scale) {
                        let amount = robot.healingAura * (robot.effects.find(e => e.name == "Ultimate Mending") ? 5 : 1);
                        if (player != robot && robot.effects.find(e => e.name == "Ultimate Mending")) {
                            player.grayDamage = Math.max(0, player.grayDamage - (amount * .3));
                        }
                        changeHealth(player, {
                            amount: amount
                        }, false, robot);
                    }
                }
            }
        }
    }
    function dist(a, b) {
        return Math.hypot(b.y - a.y, b.x - a.x);
    }
    function checkIfCanReachTarget(robot, dir, range) {
        let times = range / 20;
        for (let i = 0; i < times; i++) {
            let tmp = {
                x: robot.x + Math.cos(dir) * (i * 20),
                y: robot.y + Math.sin(dir) * (i * 20)
            };
            for (let t = 0; t < ACTUALBUILDINGSTOTOUCH.length; t++) {
                let building = ACTUALBUILDINGSTOTOUCH[t];
                if (building.name == "wall rect") {
                    let Px = Math.max(building.x, Math.min(tmp.x, building.x + building.width));
                    let Py = Math.max(building.y, Math.min(tmp.y, building.y + building.height));
                    if (dist(tmp, { x: Px, y: Py }) <= 30) {
                        return false;
                    }
                }
            };
        }
        return true;
    }
    function doOtherBotStuff(robot, isAlly, delta) {
        let possibleTargets = [];
        let posT = [];
        for (let i = 0; i < players.length; i++) {
            let player = players[i].robots[players[i].robotIndex];
            if (player && players[i].isAlly != isAlly) {
                posT.push(player);
                if (robot.isBluebell) {
                    if (player.shields.find(e => e.type == "purple") && !robot.effects.find(e => e.name == "shield break" && e.lastTime > 0)) {
                    } else {
                        if (player.invis || robot.blind) {
                            if (dist(player, robot) <= 200 + robot.scale + player.scale) {
                                possibleTargets.push(player);
                            }
                        } else {
                            possibleTargets.push(player);
                        }
                    }
                } else {
                    if (!player.invis && !robot.blind) {
                        possibleTargets.push(player);
                    }
                }
            }
        }
        robot.target = null;
        robot.fireWeapon = false;
        robot.useAbility = false;
        robot.useAbility2 = false;
        if (possibleTargets.length) {
            let closest = null;
            let hello = possibleTargets.find(e => e.effects.find(e => e.name == "track") && !e.shields.find(e => e.type == "purple"));
            if (hello) {
                closest = hello;
            } else {
                if (robot.isBluebell) {
                    possibleTargets = possibleTargets.filter(e => !e.effects.find(e => ["phase shift", "last stand", robot.isBluebell ? "stampede" : "lalalal love lalallala"].includes(e.name)));
                }
                closest = possibleTargets.sort((a, b) => dist(a, robot) - dist(b, robot))[0];
                if (robot.isBluebell && robot.name == "Purple Heptagon") {
                    let threat = possibleTargets.filter(e => dist(e, robot) <= 3800 && e.weapons.find(e => ["Tonans", "Fulgur"].includes(e.name))).sort((a, b) => dist(a, robot) - dist(b, robot))[0];
                    if (threat && dist(closest, robot) >= 600) closest = threat;
                }
            }
            if (closest) {
                robot.target = closest;
                robot.dir = Math.atan2(closest.y - robot.y, closest.x - robot.x);
                let lowestRange = robot.weapons.sort((a, b) => a.range - b.range)[0];
                if (checkIfCanReachTarget(robot, Math.hypot(closest.y - robot.y, closest.x - robot.x), Math.min(dist(closest, robot), lowestRange.range)) && Math.hypot(robot.y - closest.y, robot.x - closest.x) <= lowestRange.range) {
                    if (robot.isBluebell && (closest.effects.find(e => e.name == "Ultimate Reflecting Dash") || closest.shields.find(e => e.type == "purple"))) {
                        let glame = robot.weapons.find(e => e.name == "Discharger" || e.name == "Igniter" || e.name == "Inferno" || e.name == "Pyro");
                        if (glame) {
                            if (glame.firedTime == 0 && robot.rechargeGlgamehahahhahah________saoidjsoijdj) {
                                robot.rechargeGlgamehahahhahah________saoidjsoijdj = false;
                            }
                            if (glame.firedTime + (delta * 2) >= glame.overheatTime) {
                                robot.fireWeapon = false;
                                robot.rechargeGlgamehahahhahah________saoidjsoijdj = true;
                            } else if (robot.rechargeGlgamehahahhahah________saoidjsoijdj) {
                                robot.fireWeapon = false;
                            } else {
                                robot.fireWeapon = true;
                            }
                        } else {
                            robot.fireWeapon = true;
                        }
                    } else {
                        robot.fireWeapon = true;
                    }
                }
            }
        }
        robot.useActiveModule = false;
        if (Date.now() - robot.damagedTime <= 50) {
            robot.useActiveModule = true;
        } else if (robot.isBluebell && robot.drones.length && robot.drones[0].name == "Hiruko") {
            robot.useActiveModule = true;
        }
        if (robot.abilities.length) {
            for (let i = 0; i < robot.abilities.length; i++) {
                let ability = robot.abilities[i];
                let abilityName = ability.name;
                let indx = i + 1;
                if (abilityName == "Phalanx Mode" && !ability.botHaveUsedLolLololol) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                    ability.botHaveUsedLolLololol = true;
                }
                if (["Mastermind", "Hook", "Stove", "Ultimate Reflector", "Absorption", "Skyward", "Barrier Field", "Clain Blink", "Dismantle", "Blink Assault", "Support", "Ultimate Defense", "Matrix", "Blink Support", "Reflector", "Stampede", "Clear Sky", "Reinforce Hull", "Cold Pulse", "Divine Judgement", "Full Action", "Stealth", "Domain Expansion: Infinite Void", "Paladin", "Dragon Flight", "Phase Shift", "Ultimate Mending", "Self Heal", "Retribution"].includes(abilityName) && Date.now() - robot.damagedTime <= 50) {
                    if (abilityName == "Hook" && !robot.effects.find(e => e.name == "stampede")) {
                        robot["useAbility" + (i == 0 ? "" : indx)] = true;
                    } else if (abilityName == "Clain Blink" && robot.movementTarget) {
                        robot["useAbility" + (i == 0 ? "" : indx)] = true;
                    } else if (abilityName != "Clain Blink") {
                        robot["useAbility" + (i == 0 ? "" : indx)] = true;
                    }
                } else if (abilityName == "Remote Assault" && robot.target && dist(robot.target, robot) <= 1800) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (abilityName == "Dark Light" && robot.target && dist(robot.target, robot) <= 1200) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (abilityName == "Track" && robot.target) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (abilityName == "Castling") {
                    let effect = robot.effects.find(e => e.name == "Castling");
                    if (!effect) {
                        if (Date.now() - robot.damagedTime <= 50) {
                            robot["useAbility" + (i == 0 ? "" : indx)] = true;
                        }
                    } else {
                        if (robot.target && dist(robot.target, robot) <= 300) {
                            robot["useAbility" + (i == 0 ? "" : indx)] = true;
                        }
                    }
                } else if (abilityName == "Comet Splash" || abilityName == "Frog Splash" || abilityName == "Ultimate Reflecting Dash") {
                    if (robot.isBluebell) {
                        let effect = robot.effects.find(e => e.name == "Ultimate Reflecting Dash" || e.name == "dash");
                        if (!effect) {
                            if (Date.now() - robot.damagedTime <= 50) {
                                robot["useAbility" + (i == 0 ? "" : indx)] = true;
                            }
                        } else {
                            if (!effect.pressed && robot.target && dist(robot.target, robot) > 300) {
                                robot["useAbility" + (i == 0 ? "" : indx)] = true;
                            }
                        }
                    } else {
                        if (Date.now() - robot.damagedTime <= 50) {
                            robot["useAbility" + (i == 0 ? "" : indx)] = true;
                        }
                    }
                } else if (["Blast Wave", "Overpower", "Nuclear Rocket Shot", "Defense Breach", "Overload", "Dash", "Fortify", "Blocking Matrix"].includes(abilityName)) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (abilityName == "Long Shot" && robot.target && dist(robot.target, robot) <= 3800) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (!robot.isBluebell && abilityName == "Cannonier" && !robot.effects.find(e => e.name == "Cannonier")) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (abilityName == "Cannonier" && robot.isBluebell) {
                    let effect = robot.effects.find(e => e.name == "Cannonier");
                    if (effect) {
                        if (robot.target && dist(robot.target, robot) > 300 && effect.stage != 2) {
                            robot["useAbility" + (i == 0 ? "" : indx)] = true;
                        }
                    } else {
                        if (Date.now() - robot.damagedTime <= 50) {
                            robot["useAbility" + (i == 0 ? "" : indx)] = true;
                        }
                    }
                } else if (robot.target && dist(robot.target, robot) > 300 && abilityName == "Debut") {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (abilityName == "Mute Blast" && robot.target) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (["Stealth Dash"].includes(abilityName)) {
                    if (ability.charges > 1) {
                        robot["useAbility" + (i == 0 ? "" : indx)] = true;
                    } else if (Date.now() - robot.damagedTime <= 50) {
                        robot["useAbility" + (i == 0 ? "" : indx)] = true;
                    }
                } else if (["Stampede"].includes(abilityName) && robot.target && dist(robot.target, robot) <= 350) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (["Shield Regeneration"].includes(abilityName) && robot.shields.find(e => e.regen && e.maxhealth && e.health != e.maxhealth)) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (["Grand Fortitude"].includes(abilityName)) {
                    robot["useAbility" + (i == 0 ? "" : indx)] = true;
                } else if (["Roulette Strike"].includes(abilityName)) {
                    if (robot.target && dist(robot.target, robot) <= 1400) {
                        robot["useAbility" + (i == 0 ? "" : indx)] = true;
                    } else {
                        robot["useAbility" + (i == 0 ? "" : indx)] = false;
                    }
                } else if (["Shapeshift"].includes(abilityName)) {
                    if (robot.name == "Ultimate Brown Pentagon" || robot.name == "Brown Pentagon" || robot.name == "Gray Heptagon") {
                        if (Date.now() - robot.damagedTime <= 50 && ability.mode == 0) {
                            robot["useAbility" + (i == 0 ? "" : indx)] = true;
                        } else if (Date.now() - robot.damagedTime >= 1e3 && ability.mode == 1) {
                            robot["useAbility" + (i == 0 ? "" : indx)] = true;
                        } else {
                            robot["useAbility" + (i == 0 ? "" : indx)] = false;
                        }
                    }
                }
            }
        }
        robot.useMothership = false;
        let Player = players[robot.playersIndexSid];
        if (Player && Player.mothership && Player.mothership.data) {
            if (Player.mothership.current >= 1 && robot.target) {
                robot.motherTarget = robot.target;
                let L = player.gameMode == 4 ? undefined : posT.find(e => e.isMe && dist(e, robot) <= 1500);
                if (L && Math.random() <= .25) {
                    robot.motherTarget = L;
                }
                if (Player.mothership.data.name == "Purple Rectangle") {
                    if (!robot.motherTarget.effects.find(e => ["anti blind", "anti emp"].includes(e.name))) {
                        robot.useMothership = true;
                    }
                } else {
                    robot.useMothership = true;
                }
            }
        }
    }
    function doShapeStuffPassiveEffects(robot, delta, isAlly) {
        if (robot.abilities.length && robot.abilities.find(e => e.name == "Shapeshift")) {
            if (robot.name == "Brown Pentagon" || robot.name == "Ultimate Brown Pentagon") {
                for (let i = 0; i < robot.abilities.length; i++) {
                    let ability = robot.abilities[i];
                    if (ability.mode == 1) {
                        robot.builtInDefensePoints += ability.abilityDefensePoints;
                    }
                }
            } else {
                for (let i = 0; i < robot.abilities.length; i++) {
                    let ability = robot.abilities[i];
                    if (ability.mode == 0) {
                        robot.builtInDefensePoints += (robot.name == "Pinkish-Red Heptagon" ? 200 : 100);
                    } else {
                        robot.avoidBuildings = true;
                        robot.abilitySpeedMulti = (robot.name == "Pinkish-Red Heptagon" ? 1.5 : 3);
                        if (robot.name != "Pinkish-Red Heptagon") {
                            let shield = robot.shields.find(e => e.type == "purple");
                            if (shield) {
                                ability.weaponMulti = 1 + (Math.floor(shield.health / 5e3) * .05);
                            }
                            (!robot.isMe ? robot.deltaTimer -= delta : deltaTimer -= delta);
                            if ((!robot.isMe ? robot.deltaTimer <= 0 : deltaTimer <= 0)) {
                                (!robot.isMe ? robot.deltaTimer = 75 : deltaTimer = 75);
                                let dmg = ability.dmg * ability.weaponMulti;
                                projectiles.push({
                                    x: robot.x,
                                    y: robot.y,
                                    oldX: robot.x,
                                    oldY: robot.y,
                                    velx: 0,
                                    vely: 0,
                                    scale: 60,
                                    speed: 0.3,
                                    avoidBuildings: true,
                                    dmg: dmg,
                                    range: 1200,
                                    defensePointsBypass: 0,
                                    projType: "energy",
                                    dir: robot.dir,
                                    color: "./images/bullets/energy_bullet.png",
                                    isAlly: isAlly,
                                    owner: robot,
                                    weaponOwner: {
                                        name: "Dragon's Wrath",
                                        level: robot.level
                                    }
                                });
                            }
                        }
                    }
                }
            }
        }
    }
    function doShapeFlightVisualStuff(robot, delta) {
        if (typeof robot.flightVisualData == "object") {
            robot.scale = Math.min(robot.scale + ((robot.flightVisualData.speed || 0.15) * delta), robot.flightVisualData.scale);
        } else {
            robot.scale = Math.max(robot.scale - ((robot.flightVisualData || 0.15) * delta), robot.oldScale);
        }
    }
    function useActiveModule(robot, module, isAlly, noCost) {
        if (!robot.titan && (robot.isMe ? player.workshopPoints - module.cost >= 0 : true)) {
            if (robot.activeModuleReload == 0) {
                if (robot.isMe && !noCost) updateMoneyDisplay("workshopPoints", -module.cost);
                if (robot.drones.length && !noCost) {
                    for (let i = 0; i < robot.drones.length; i++) {
                        let yay = robot.drones[i].abilities.find(e => e.name == "On Module Use: More Durability With DOT");
                        let yay1 = robot.drones[i].abilities.find(e => e.name == "On Module Use: Block");
                        let yay3 = robot.drones[i].abilities.find(e => e.name == "On Module Use: Resist");
                        let yay4 = robot.drones[i].abilities.find(e => e.name == "On Module Use: Damage");
                        if (yay3) {
                            robot.drones[0].effects.push({
                                name: "speed",
                                amount: 2,
                                lastTime: 7e3
                            });
                            robot.effects.push({
                                name: "defense points",
                                amount: yay3.defenseIncrease,
                                lastTime: 10e3
                            });
                        }
                        if (yay4) {
                            robot.drones[0].effects.push({
                                name: "speed",
                                amount: 2,
                                lastTime: 7e3
                            });
                            robot.effects.push({
                                name: "attack",
                                power: yay4.onActiveModuleUseDamage,
                                lastTime: 10e3
                            });
                        }
                        if (yay) {
                            robot.drones[0].effects.push({
                                name: "speed",
                                amount: 2,
                                lastTime: 7e3
                            });
                            robot.normalMaxHealth += 45e3;
                            robot.maxhealth += 45e3;
                            changeHealth(robot, {
                                amount: 45e3
                            }, false, robot);
                            for (let i = 0; i < 28; i++) robot.effects.push({
                                name: "dot",
                                noGrayDamage: true,
                                noAmp: true,
                                owner: robot,
                                dmg: 45e3 / 56,
                                lastTime: 7e3
                            });
                        }
                        if (yay1) {
                            robot.drones[0].effects.push({
                                name: "speed",
                                amount: 2,
                                lastTime: 7e3
                            });
                            for (let i = 0; i < yay1.dmg; i++) {
                                robot.effects.push({
                                    name: "block",
                                    lastTime: 1,
                                    lastForever: true
                                });
                            }
                        }
                    }
                }
                if (module.name == "Repair Unit" || module.name == "Advanced Repair Unit" || module.name == "Repairing Conduit") {
                    if (module.name == "Repairing Conduit") {
                        let healing = robot.maxhealth * module.instantFixPercent;
                        changeHealth(robot, {
                            amount: healing
                        }, false, robot);
                    }
                    robot.effects.push({
                        name: "healing",
                        isActiveModuleEffect: true,
                        grayDamage: module.name == "Repairing Conduit" ? .17 : undefined,
                        type: module.repairUnitPower.type,
                        power: module.repairUnitPower.power,
                        rate: module.repairUnitPower.rate,
                        lastTime: module.lastTime
                    });
                } else if (module.name == "Phase Shift") {
                    robot.effects.push({
                        name: "phase shift",
                        isActiveModuleEffect: true,
                        lastTime: module.lastTime
                    });
                } else if (module.name == "Unstable Conduit") {
                    robot.effects.push({
                        name: "healing",
                        grayDamage: 1,
                        type: "percent",
                        power: .07,
                        rate: 500,
                        lastTime: 4e3
                    });
                    robot.effects.push({
                        name: "healing",
                        grayDamage: .25,
                        type: "percent",
                        power: .007,
                        rate: 2e3,
                        lastTime: 30e3
                    });
                    robot.effects.push({
                        name: "attack",
                        power: .02,
                        lastForever: true,
                        lastTime: 1
                    });
                    robot.effects.push({
                        name: "shield break",
                        lastTime: 4e3
                    });
                    robot.effects.push({
                        name: "defense points",
                        amount: 5,
                        lastTime: 30e3
                    });
                } else if (module.name == "Nuclear Intensifier" || module.name == "Nuclear Conduit") {
                    if (module.name == "Nuclear Conduit") {
                        robot.effects.push({
                            name: "defense breach",
                            isActiveModuleEffect: true,
                            lastTime: module.lastTime
                        });
                    }
                    robot.effects.push({
                        name: "attack",
                        power: module.dmgIncrease,
                        isActiveModuleEffect: true,
                        lastTime: module.lastTime
                    });
                } else if (module.name == "Shield Breaker") {
                    robot.effects.push({
                        name: "shield break",
                        isActiveModuleEffect: true,
                        lastTime: module.lastTime
                    });
                }
                robot.activeModuleReload = module.reload;
            }
        }
    }
    function doActiveModuleStuff(robot, weapons, MATH1HA___, isAlly, delta) {
        let module = activeModuleData[robot.activeModuleIndex];
        if (robot.activeModuleReload == null) robot.activeModuleReload = 0;
        if (robot.isMe) {
            document.getElementById("useActiveModule").style.display = robot.titan ? "none" : player.workshopPoints - module.cost >= 0 ? "block" : "none";
            if (robot.abilities.length && (robot.abilities.find(e => e.name == "Phase Shift") ? true : !robot.isFREEZE)) {
                document.getElementById("useActiveModule").style.bottom = weapons > 4 ? `${MATH1HA___ + 20}px` : "170px";
                document.getElementById("useActiveModule").style.left = weapons > 4 ? robot.effects.length ? `285px` : "140px" : "380px";
            } else {
                document.getElementById("useActiveModule").style.left = weapons > 4 ? robot.effects.length ? `165px` : "20px" : "350px";
                document.getElementById("useActiveModule").style.bottom = weapons > 4 ? `${MATH1HA___ + 20}px` : "40px";
            }
        }
        if (!robot.titan && (robot.isMe ? keysPressed[81] : robot.useActiveModule)) {
            useActiveModule(robot, module, isAlly);
        }
        if (robot.isMe) {
            if (robot.activeModuleReload == 0) {
                document.getElementById("useActiveModule").style.backgroundImage = `url('${module.imageSource}')`;
                document.getElementById("cooldownTextActive").innerHTML = "";
            } else if (robot.activeModuleReload > 0) {
                document.getElementById("useActiveModule").style.backgroundImage = "";
            } else {
                document.getElementById("useActiveModule").style.backgroundImage = `url('${module.imageSource}')`;
            }
            let effect = robot.effects.find(e => e.isActiveModuleEffect);
            if (effect) {
                document.getElementById("cooldownTextActive").innerHTML = `${(effect.lastTime / 1000).toFixed(1)}`;
                document.getElementById("useActiveModule").style.backgroundImage = `url('${module.imageSource}')`;
            } else if (robot.activeModuleReload > 0) {
                robot.activeModuleReload -= delta;
                document.getElementById("cooldownTextActive").innerHTML = `${(robot.activeModuleReload / 1000).toFixed(1)}`;
                if (robot.activeModuleReload <= 0) {
                    robot.activeModuleReload = 0;
                }
            }
        }
    }
    function fireProjectileDrone(weapon, isAlly, robot, drone, target) {
        let scale = 20;
        let r = (robot.scale + drone.visualData.scale + 40);
        let dx = robot.x + Math.cos(drone.visualData.dir) * r;
        let dy = robot.y + Math.sin(drone.visualData.dir) * r;
        let dir;

        dir = Math.atan2(target.y - dy, target.x - dx);
        drone.visualData.dir2 = dir;

        if (weapon.name == "Imitating Frag Shotgun" || weapon.name == "Deathmark Affector") {
            if (weapon.name == "Deathmark Affector") {
                projectiles.push({
                    x: dx,
                    y: dy,
                    oldX: dx,
                    oldY: dy,
                    projType: "energy",
                    velx: 0,
                    vely: 0,
                    scale: scale,
                    speed: 0.25,
                    dmg: weapon.dmg,
                    range: weapon.range,
                    dir: dir,
                    isAlly: isAlly,
                    deathmarkEffect: {
                        name: "deathmark",
                        last: 6e3,
                        power: weapon.deathmark
                    },
                    color: "./images/bullets/red_bullet.png",
                    avoidBuildings: robot.avoidBuildings,
                    owner: robot,
                    weaponOwner: {
                        name: "Deathmark Affector",
                        level: 1
                    }
                });
                return;
            }
            projectiles.push({
                x: dx,
                y: dy,
                oldX: dx,
                oldY: dy,
                projType: "normal",
                velx: 0,
                vely: 0,
                scale: scale,
                speed: 0.25,
                dmg: weapon.dmg,
                range: weapon.range,
                dir: dir,
                isAlly: isAlly,
                splitData: {
                    range: 550,
                    amount: 15,
                    spread: weapon.spread
                },
                slowEffect: {
                    name: "slowdown",
                    last: 7e3,
                    power: 0.025
                },
                color: "./images/bullets/bullet.png",
                avoidBuildings: robot.avoidBuildings,
                owner: robot,
                weaponOwner: {
                    name: "Imitating Frag Shotgun",
                    level: 1
                }
            });
        } else if (weapon.name == "Dux Drone") {
            projectiles.push({
                x: dx + Math.cos(dir + Math.PI / 4) * 35,
                y: dy + Math.sin(dir + Math.PI / 4) * 35,
                oldX: dx + Math.cos(dir + Math.PI / 4) * 35,
                oldY: dy + Math.sin(dir + Math.PI / 4) * 35,
                projType: "normal",
                velx: 0,
                vely: 0,
                scale: scale,
                speed: 0.25,
                dmg: weapon.dmg / 2,
                range: weapon.range,
                dir: dir + getRandomOffset(7),
                isAlly: isAlly,
                color: "./images/bullets/bullet.png",
                avoidBuildings: robot.avoidBuildings,
                owner: robot,
                weaponOwner: {
                    name: weapon.name,
                    level: weapon.level
                }
            });

            projectiles.push({
                x: dx + Math.cos(dir - Math.PI / 4) * 35,
                y: dy + Math.sin(dir - Math.PI / 4) * 35,
                oldX: dx + Math.cos(dir - Math.PI / 4) * 35,
                oldY: dy + Math.sin(dir - Math.PI / 4) * 35,
                projType: "normal",
                velx: 0,
                vely: 0,
                scale: scale,
                speed: 0.25,
                dmg: weapon.dmg / 2,
                range: weapon.range,
                dir: dir + getRandomOffset(7),
                isAlly: isAlly,
                color: "./images/bullets/bullet.png",
                avoidBuildings: robot.avoidBuildings,
                owner: robot,
                weaponOwner: {
                    name: weapon.name,
                    level: weapon.level
                }
            });
        } else if (weapon.name == "Dux Drone #3") {
            projectiles.push({
                x: dx + Math.cos(dir + Math.PI / 4) * 35,
                y: dy + Math.sin(dir + Math.PI / 4) * 35,
                oldX: dx + Math.cos(dir + Math.PI / 4) * 35,
                oldY: dy + Math.sin(dir + Math.PI / 4) * 35,
                projType: "normal",
                velx: 0,
                vely: 0,
                scale: scale,
                speed: 0.25,
                dmg: weapon.dmg / 2,
                range: weapon.range,
                dir: dir,
                isAlly: isAlly,
                color: "./images/bullets/bullet.png",
                avoidBuildings: robot.avoidBuildings,
                owner: robot,
                weaponOwner: {
                    name: weapon.name,
                    level: weapon.level
                }
            });

            projectiles.push({
                x: dx,
                y: dy,
                oldX: dx,
                oldY: dy,
                projType: "normal",
                velx: 0,
                vely: 0,
                scale: scale,
                speed: 0.25,
                dmg: weapon.dmg,
                range: weapon.range,
                dir: dir + getRandomOffset(3),
                isAlly: isAlly,
                color: "./images/bullets/bullet.png",
                avoidBuildings: robot.avoidBuildings,
                owner: robot,
                weaponOwner: {
                    name: weapon.name,
                    level: weapon.level
                }
            });

            projectiles.push({
                x: dx + Math.cos(dir - Math.PI / 4) * 35,
                y: dy + Math.sin(dir - Math.PI / 4) * 35,
                oldX: dx + Math.cos(dir - Math.PI / 4) * 35,
                oldY: dy + Math.sin(dir - Math.PI / 4) * 35,
                projType: "normal",
                velx: 0,
                vely: 0,
                scale: scale,
                speed: 0.25,
                dmg: weapon.dmg / 2,
                range: weapon.range,
                dir: dir,
                isAlly: isAlly,
                color: "./images/bullets/bullet.png",
                avoidBuildings: robot.avoidBuildings,
                owner: robot,
                weaponOwner: {
                    name: weapon.name,
                    level: weapon.level
                }
            });
        }
    }
    function doDroneWeaponStuff(robot, isAlly) {
        if (robot.blind) return;
        if ((robot.name == "Grayish Blue Triangle" || robot.name == "Polygon") && !(robot.isMe ? keysPressed[32] : robot.fireWeapon)) return;

        for (let i = 0; i < robot.drones.length; i++) {
            let abilities = robot.drones[i].abilities;

            for (let j = 0; j < abilities.length; j++) {
                let weapon = abilities[j];

                if (weapon.weapon) {
                    let near = getNearest(robot, weapon.range, isAlly);

                    if (near.length) {
                        let nearest = near.filter(e => !e.invis).sort((a, b) => dist(a, robot) - dist(b, robot))[0];

                        if (weapon.lastFire == null) weapon.lastFire = 0;

                        if (nearest && Date.now() - weapon.lastFire >= weapon.reload) {
                            weapon.lastFire = Date.now();

                            if (weapon.name == "Imitating Comet Laser") {
                                weapon.healBackOnDamage = 1;
                                weapon.target = nearest;
                                weapon.droneIsFiring = true;
                                doLaserDamage(robot, weapon, nearest);
                            } else {
                                fireProjectileDrone(weapon, isAlly, robot, robot.drones[i], nearest);
                            }
                        }
                    } else {
                        weapon.droneIsFiring = false;
                    }
                }
            }
        }
        if (robot.drones.length && robot.drones[0].abilities.find(e => e.weapon)) {
            let weapon = robot.drones[0].abilities.find(e => e.weapon);
            let near = getNearest(robot, weapon.range, isAlly);
            if (near.length) {
                let nearest = near.filter(e => !e.invis).sort((a, b) => dist(a, robot) - dist(b, robot))[0];
                if (weapon.lastFire == null) weapon.lastFire = 0;
                if (nearest && Date.now() - weapon.lastFire >= weapon.reload) {
                    weapon.lastFire = Date.now();
                    if (weapon.name == "Imitating Comet Laser") {
                        weapon.healBackOnDamage = 1;
                        weapon.target = nearest;
                        weapon.droneIsFiring = true;
                        doLaserDamage(robot, weapon, nearest);
                    } else {
                        fireProjectileDrone(weapon, isAlly, robot, robot.drones[0], nearest);
                    }
                }
            } else {
                weapon.droneIsFiring = false;
            }
        }
    }

    /**
     * @param {shape} robot 
     * @param {MOOOOOOOTHERSHIP} mothership 
     * @param {boolean | string} isAlly 
     */

    function useMothership(robot, mothership, isAlly) {
        let Player = players[robot.playersIndexSid];
        Player.mothership.current = 0;
        if (mothership.name == "Gray Rectangle" || mothership.name == "Black Rectangle") {
            domains.push({
                name: "dmgfield",
                x: robot.isMe ? robot.cursorLocation.x : robot.motherTarget.x,
                y: robot.isMe ? robot.cursorLocation.y : robot.motherTarget.y,
                dmg: mothership.dmg,
                scale: 500,
                lastingTime: 1e3,
                oldLast: 1e3,
                isAlly: isAlly,
                owner: robot
            });
        } else if (mothership.name == "Green Oval") {
            domains.push({
                name: "healfield",
                x: robot.x,
                y: robot.y,
                repair: mothership.repair,
                yellowShield: mothership.yellowShield,
                scale: 300,
                lastingTime: 2e3,
                oldLast: 2e3,
                isAlly: isAlly,
                owner: robot
            });
        } else if (mothership.name == "Gray Oval" || mothership.name == "Yellow Oval") {
            if (robot.shields.find(e => e.turretShield == "Enchanced Shield Self System")) {
                let shield = robot.shields.find(e => e.turretShield == "Enchanced Shield Self System");
                shield.health += mothership.yellowShield;
                shield.maxhealth += mothership.yellowShield;
            } else {
                robot.shields.push({
                    type: "yellow",
                    grayOvalShield: mothership.name == "Gray Oval",
                    health: mothership.yellowShield,
                    maxhealth: mothership.yellowShield,
                    repair: mothership.repair,
                    turretShield: mothership.name == "Yellow Oval" ? "Enchanced Shield Self System" : undefined,
                    regen: 0,
                    lastTime: mothership.name == "Gray Oval" ? 10e3 : undefined
                });
            }
        } else if (mothership.name == "Purple Rectangle") {
            domains.push({
                name: "mutefield",
                x: robot.isMe ? robot.cursorLocation.x : robot.motherTarget.x,
                y: robot.isMe ? robot.cursorLocation.y : robot.motherTarget.y,
                scale: 600,
                duration: mothership.effectDuration,
                lastingTime: 1e3,
                oldLast: 1e3,
                isAlly: isAlly,
                owner: robot
            });
        } else if (mothership.name == "Black Oval") {
            robot.effects.filter(e => ["lockdown", "slowdown", "emp", "blind", "rust", "suppression"].includes(e.name)).forEach(e => {
                e.lastTime = 0;
            });
            let amount = robot.effects.filter(e => e.name == "cleanse").length;
            if (amount + 3 >= 7) {
                for (let i = 0; i < (7 - amount); i++) {
                    robot.effects.unshift({
                        name: "cleanse",
                        lastTime: 1,
                        lastForever: true
                    });
                }
            } else {
                for (let i = 0; i < 3; i++) {
                    robot.effects.unshift({
                        name: "cleanse",
                        lastTime: 1,
                        lastForever: true
                    });
                }
            }
            let gHealing = robot.maxhealth * mothership.grayHealing;
            let healing = robot.maxhealth * mothership.healingPercent;
            robot.grayDamage = Math.max(robot.grayDamage - gHealing, 0);
            changeHealth(robot, {
                amount: healing
            }, false, robot);
        } else if (mothership.name == "Yellow Rectangle") {
            for (let i = 0; i < 14; i++) {
                robot.effects.push({
                    name: "attack",
                    power: mothership.effectPower,
                    lastTime: 3e3 + (i * 1e3)
                });

                robot.effects.push({
                    name: "speed",
                    power: mothership.effectPower,
                    lastTime: 3e3 + (i * 1e3)
                });
            }
        }

        for (let i = 0; i < mothership.turrets.length; i++) {
            let turret = mothership.turrets[i];
            if (turret.name == "Nuclear Attack Cannon") {
                let x = robot.isMe ? robot.cursorLocation.x : robot.motherTarget.x;
                let y = robot.isMe ? robot.cursorLocation.y : robot.motherTarget.y;
                let enemies = getNearest({
                    x: x,
                    y: y
                }, turret.scale, isAlly);
                enemies.forEach(e => {
                    changeHealth(e, {
                        amount: -(turret.dmg * (e.tier == 4 ? 2 : e.tier == 3 ? 1.5 : 1)),
                        defensePointsBypass: .5,
                        graydmg: 0
                    }, false, robot);
                    e.effects.push({
                        name: "dot",
                        neg: true,
                        dmg: turret.dmg / 5,
                        owner: robot,
                        lastTime: 5e3
                    });
                });
                domains.push({
                    name: "dmgfield",
                    x: robot.isMe ? robot.cursorLocation.x : robot.motherTarget.x,
                    y: robot.isMe ? robot.cursorLocation.y : robot.motherTarget.y,
                    dmg: 0,
                    scale: turret.scale,
                    lastingTime: 100,
                    oldLast: 100,
                    isAlly: isAlly,
                    owner: robot
                });
            } else if (turret.name == "Laser Blast Cannon" || turret.name == "Target Ray Cannon") {
                domains.push({
                    name: "dmgfield",
                    x: robot.isMe ? robot.cursorLocation.x : robot.motherTarget.x,
                    y: robot.isMe ? robot.cursorLocation.y : robot.motherTarget.y,
                    dmg: turret.dmg,
                    scale: turret.scale,
                    lastingTime: 1e3,
                    oldLast: 1e3,
                    isAlly: isAlly,
                    owner: robot
                });
            } else if (turret.name == "Periodic Fix Station") {
                domains.push({
                    name: "healfield",
                    x: robot.x,
                    y: robot.y,
                    repair: turret.healingData,
                    scale: 300,
                    lastingTime: 2e3,
                    oldLast: 2e3,
                    isAlly: isAlly,
                    owner: robot
                });
            } else if (turret.name == "Yellow Shield Self System") {
                domains.push({
                    name: "healfield",
                    x: robot.x,
                    y: robot.y,
                    yellowShield: turret.shieldHp,
                    scale: 300,
                    lastingTime: 2e3,
                    oldLast: 2e3,
                    isAlly: isAlly,
                    owner: robot
                });
            } else if (turret.name == "Enchanced Shield Self System") {
                if (robot.shields.find(e => e.turretShield == "Enchanced Shield Self System")) {
                    let shield = robot.shields.find(e => e.turretShield == "Enchanced Shield Self System");
                    shield.health += turret.shieldHp;
                    shield.maxhealth += turret.shieldHp;
                } else {
                    robot.shields.push({
                        type: "yellow",
                        turretShield: "Enchanced Shield Self System",
                        health: turret.shieldHp,
                        maxhealth: turret.shieldHp,
                        regen: 0
                    });
                }
            } else if (turret.name == "Life Saver") {
                setTimeout(() => {
                    robot.effects.push({
                        name: "stealth",
                        lastTime: turret.stealthTime
                    });
                    robot.effects.push({
                        name: "anti defense mig",
                        lastTime: turret.antiDefenseMig
                    });
                }, turret.strikeDelay);
            } else if (turret.name == "Durability Extender") {
                setTimeout(() => {
                    robot.normalMaxHealth += turret.durabilityIncrease;
                    robot.maxhealth += turret.durabilityIncrease;
                    robot.health += turret.durabilityIncrease;
                }, turret.strikeDelay);
            } else if (turret.name == "Anti-Jamming Support") {
                setTimeout(() => {
                    let duration = 60e3;

                    robot.effects.push({
                        name: "anti blind",
                        lastTime: duration
                    });
                    robot.effects.push({
                        name: "anti emp",
                        lastTime: duration
                    });
                    robot.effects.push({
                        name: "anti suppression",
                        lastTime: duration
                    });
                }, turret.strikeDelay);
            }
        }
    }
    function updateRobot(robot, isAlly, delta, index) {
        if (robot.deltaTimer == null) robot.deltaTimer = 0;
        robot.shieldRegen = 1;
        robot.reloadMoveMulti = 1;
        robot.abilitySpeedMulti = 1;
        robot.avoidBuildings = robot.name == "Polygon";
        if (robot.oldFOV == null) robot.oldFOV = robot.fieldOfViewMulti;
        robot.invis = false;
        robot.isFREEZE = robot.freeze ? true : false;
        robot.freeze = false;
        if (robot.name == "Cyan Heptagon") {
            if ((Math.round(robot.lastX) != Math.round(robot.x)) || (Math.round(robot.lastY) != Math.round(robot.y))) {
                let effect = robot.effects.find(e => e.name == "cooldown_timer" && e.autoStealthHA__);
                if (effect) {
                    effect.lastTime = 2000;
                } else {
                    robot.effects.push({
                        name: "cooldown_timer",
                        autoStealthHA__: true,
                        lastTime: 2000
                    });
                }
            } else {
                let effect = robot.effects.find(e => e.name == "cooldown_timer" && e.autoStealthHA__);
                if ((effect && effect.lastTime - delta <= 0) || !effect) {
                    robot.invis = true;
                    if (robot.cyanHeptagonAutoHeal == null) robot.cyanHeptagonAutoHeal = 0;
                    robot.cyanHeptagonAutoHeal -= delta;
                    if (robot.cyanHeptagonAutoHeal <= 0) {
                        robot.cyanHeptagonAutoHeal = 500;
                        let heal = robot.maxhealth * .05;
                        robot.grayDamage = Math.max(robot.grayDamage - (heal * .15), 0);
                        changeHealth(robot, {
                            amount: heal
                        }, false, robot);
                    }
                }
            }
        }
        if (robot.name == "Teal Heptagon" || robot.name == "Orange Triangle") {
            if (robot.lastAddCounterSuppression == null) robot.lastAddCounterSuppression = 0;
            if (Date.now() - robot.lastAddCounterSuppression >= (robot.name == "Orange Triangle" ? 5e3 : 7e3)) {
                robot.lastAddCounterSuppression = Date.now();
                robot.effects.unshift({
                    name: "counter suppression",
                    lastTime: 1,
                    power: (robot.name == "Orange Triangle" ? .9 : .4),
                    durationOfSuppression: (robot.name == "Orange Triangle" ? 12e3 : .4e3),
                    lastForever: true
                });
            }
        }
        robot.lastX = robot.x;
        robot.lastY = robot.y;
        robot.builtInDefensePoints = robot.normalDefensePoints;
        if (robot.isMe) {
            document.getElementById("weaponThing").style.display = "block";
            document.getElementById("healthBar").style.display = "block";
            document.getElementById("weaponThing").innerHTML = "";
        }
        let MATH1HA___ = 320 * (Math.min(4, robot.weapons.length) / 4);
        if (robot.abilities.length && robot.isMe) {
            let weapons = robot.weapons.length;
            document.getElementById("abilityCharges").innerHTML = "";
            document.getElementById("useAbility").style.left = weapons > 4 ? robot.effects.length ? `165px` : "20px" : "350px";
            document.getElementById("useAbility").style.bottom = weapons > 4 ? `${MATH1HA___ + 20}px` : "40px";
            document.getElementById("abilityCharges").style.left = weapons > 4 ? robot.effects.length ? `165px` : "20px" : "480px";
            document.getElementById("abilityCharges").style.bottom = weapons > 4 ? `${MATH1HA___ + 150}px` : "40px";
            if (robot.abilities.length > 1) {
                document.getElementById("useAbility2").style.left = weapons > 4 ? robot.effects.length ? `165px` : "20px" : "350px";
                document.getElementById("useAbility2").style.bottom = weapons > 4 ? `${MATH1HA___ + 160}px` : "180px";
                document.getElementById("abilityCharges2").style.left = weapons > 4 ? robot.effects.length ? `165px` : "20px" : "480px";
                document.getElementById("abilityCharges2").style.bottom = weapons > 4 ? `${MATH1HA___ + 290}px` : "180px";
            } else {
                document.getElementById("abilityCharges2").innerHTML = "";
                document.getElementById("useAbility2").style.display = "none";
            }
        }
        convertDamageToDOT(robot);
        if (robot.name != "Pink Circle") {
            robot.turnDmgIntoDOT = false;
        }
        let { effectNames, lastStand, slowdownMulti, speedMulti } = doEffectStuff(robot, delta, isAlly);
        if (!robot.isMe) doOtherBotStuff(robot, isAlly, delta);
        doActiveModuleStuff(robot, robot.weapons.length, MATH1HA___, isAlly, delta);
        if (robot.isMe) {
            document.getElementById("abilityCharges").innerHTML = "";
            document.getElementById("abilityCharges2").innerHTML = "";
        }
        if (robot.abilities.length && !robot.emp && (robot.abilities.find(e => e.name == "Phase Shift") ? true : !robot.isFREEZE)) {
            for (let i = 0; i < robot.abilities.length; i++) {
                let ability = robot.abilities[i];
                let indx = i == 0 ? "" : i + 1;
                if (robot.isMe) {
                    let color = "#000";
                    let color2 = "#000";
                    if (player.mapID == 1) {
                        if (robot.activeModuleReload && !robot.effects.find(e => e.isActiveModuleEffect)) {
                            color2 = "#fff";
                        }
                        if (robot.abilityReload && !robot.abilityLast) {
                            color = "#fff";
                        }
                    }
                    document.getElementById("cooldownTextActive").style.color = color2;
                    if (i == 1) {
                        document.getElementById("useAbility2").style.display = "block";
                        document.getElementById("cooldownText2").style.color = color;
                    } else {
                        document.getElementById("cooldownText").style.color = color;
                        document.getElementById("useAbility").style.display = "block";
                    }
                }
                if (ability.charges >= ability.maxcharge && ability.name != "Clain Blink") {
                    ability.charges = ability.maxcharge;
                    ability.abilityReload = ability.reload;
                }
                if (ability.maxcharge && robot.isMe) {
                    let amountHave = ability.charges;
                    let amountDont = ability.maxcharge - ability.charges;
                    for (let i = 0; i < amountHave; i++) {
                        document.getElementById("abilityCharges" + indx).innerHTML += `
                        <div style="position: absolute; bottom: ${20 * i}px; width: 15px; height: 15px; border-radius: 100%; background-color: rgb(255, 255, 255, 0.8);">
                        </div>
                        `;
                    }
                    for (let i = 0; i < amountDont; i++) {
                        document.getElementById("abilityCharges" + indx).innerHTML += `
                        <div style="position: absolute; bottom: ${20 * (i + amountHave)}px; width: 15px; height: 15px; border-radius: 100%; background-color: rgb(0, 0, 0, 0.2);">
                        </div>
                        `;
                    }
                }
                if ((i == 0 ? (robot.isMe ? keysPressed[69] : robot.useAbility) : (robot.isMe ? keysPressed[81] : robot.useAbility2))) {
                    useAbility(robot, isAlly, delta, ability);
                }
                if (robot.isMe && ability.abilityReload == null && ability.abilityLast == null) {
                    document.getElementById("cooldownText" + indx).innerHTML = "";
                }
                if (ability.abilityReload == 0 && ability.abilityLast == 0) {
                    if (robot.isMe) {
                        document.getElementById("useAbility" + indx).style.backgroundImage = `url('${ability.iconSource}')`;
                        document.getElementById("cooldownText" + indx).innerHTML = "";
                    }
                } else if (ability.abilityReload > 0 && robot.isMe) {
                    document.getElementById("useAbility" + indx).style.backgroundImage = "";
                } else if (robot.isMe) {
                    document.getElementById("useAbility" + indx).style.backgroundImage = `url('${ability.iconSource}')`;
                }
                if (ability.abilityLast && ability.abilityLast > 0) {
                    ability.abilityLast -= delta;
                    if (ability.maxcharge && robot.isMe) {
                        document.getElementById("useAbility" + indx).style.backgroundImage = `url('${ability.iconSource}')`;
                    }
                    if (robot.isMe) {
                        document.getElementById("cooldownText" + indx).innerHTML = `${(ability.abilityLast / 1000).toFixed(1)}`;
                        document.getElementById("cooldownText" + indx).style.left = `${60 - (document.getElementById("cooldownText" + indx).clientWidth / 2)}px`;
                    }
                    doAbilityFunction(robot, delta, isAlly, ability);
                    if (ability.abilityLast <= 0) {
                        doAbilityEndFunction(robot, delta, undefined, ability);
                        ability.abilityLast = 0;
                    }
                } else if (ability.charges && robot.isMe) {
                    document.getElementById("useAbility" + indx).style.backgroundImage = `url('${ability.iconSource}')`;
                    document.getElementById("cooldownText" + indx).innerHTML = "";
                }
                if (ability.abilityReload && ability.abilityReload > 0) {
                    robot.scale = Math.max(robot.scale - (0.08 * delta), robot.oldScale);
                    if (!ability.maxcharge && robot.isMe) {
                        document.getElementById("cooldownText" + indx).innerHTML = `${(ability.abilityReload / 1000).toFixed(1)}`;
                        document.getElementById("cooldownText" + indx).style.left = `${60 - (document.getElementById("cooldownText" + indx).clientWidth / 2)}px`;
                    } else if (ability.maxcharge && !ability.charges && !ability.abilityLast && robot.isMe) {
                        document.getElementById("useAbility" + indx).style.backgroundImage = null;
                        document.getElementById("cooldownText" + indx).innerHTML = `${(ability.abilityReload / 1000).toFixed(1)}`;
                        document.getElementById("cooldownText" + indx).style.left = `${60 - (document.getElementById("cooldownText" + indx).clientWidth / 2)}px`;
                    }
                    ability.abilityReload -= delta;
                    if (ability.abilityReload <= 0) {
                        ability.abilityReload = 0;
                        if (ability.abilityLast < 0) ability.abilityLast = 0;
                        if (ability.maxcharge) {
                            ability.charges++;
                            ability.abilityReload = ability.reload;
                        }
                    }
                }
            }
        } else {
            if (robot.isMe) {
                document.getElementById("useAbility").style.display = "none";
                document.getElementById("useAbility2").style.display = "none";
            }
        }
        doShapeFlightVisualStuff(robot, delta);
        doShapeStuffPassiveEffects(robot, delta, isAlly);
        doPassiveAuraHealing(robot, isAlly, delta);
        if (robot.isMe) {
            document.getElementById("LMAOLMAOLMAOLMAO").innerHTML = "";
            drawEffects(MATH1HA___, effectNames);
        }
        let { shieldRegenMulti } = doModulesStuff(robot, delta);
        doShieldsStuff(robot, delta, {
            shieldRegenMulti: shieldRegenMulti,
            isAlly: isAlly
        });
        if (robot.isMe) drawShieldBars(robot);
        checkIfHitByProj(robot, isAlly);
        if (robot.health > (robot.maxhealth - robot.grayDamage)) {
            robot.health = (robot.maxhealth - robot.grayDamage);
        }
        let force = robot.effects.find(e => e.name == "forcefield");
        if (force && Date.now() - force.data.lastHit >= force.rechargeTime) {
            force.data.health = force.data.maxhealth;
        }
        if (robot.canGetAbilityBackAtHalfHealth && robot.abilities.length) {
            let half = robot.maxhealth * .5;
            if (robot.abLastHealthAB__) {
                if (robot.abLastHealthAB__ > half && robot.health <= half) {
                    robot.canGetAbilityBackAtHalfHealth = false;
                    for (let i = 0; i < robot.abilities.length; i++) {
                        let ability = robot.abilities[i];
                        if (ability.maxcharge) {
                            ability.charges++;
                        } else {
                            if (ability.abilityReload > 0) {
                                ability.abilityLast = 0;
                            }
                            ability.abilityReload = 0;
                        }
                    }
                }
            }
            robot.abLastHealthAB__ = robot.health;
        }
        doOnDamageTakeStuff(robot);
        let Player = players[robot.playersIndexSid];
        if (Player && Player.mothership && Player.mothership.data) {
            if (Player.mothership.current >= 1) {
                if (robot.isMe ? keysPressed[70] : robot.useMothership) {
                    useMothership(robot, Player.mothership.data, isAlly);
                }
            }
        }
        if (robot.health > robot.maxhealth) {
            robot.health = robot.maxhealth;
        }
        if (robot.isMe) {
            document.getElementById("healthBar").innerHTML = `
            <div style="position: absolute; color: ${player.mapID == 0 ? "#fff" : "#000"}; top: -20px; left: 5px; font-size: 12px;">
            WSP/WKSP: ${abbreviateNumber(player.workshopPoints)}
            </div>
            <div style="position: absolute; top: 0px; right: 0px; width: ${100 * (robot.grayDamage / robot.maxhealth)}%; height: 100%; background-color: #808080;">
            </div>
            <div style="position: absolute; top: 0px; left: 0px; width: ${100 * (robot.health > robot.maxhealth - robot.grayDamage ? ((robot.maxhealth - robot.grayDamage) / robot.maxhealth) : (robot.health / robot.maxhealth))}%; height: 100%; background-color: #45ff45;">
            </div>
            <div style="position: absolute; top: 0px; right: ${100 - (100 * (robot.health / robot.maxhealth))}%; width: ${robot.effects.find(e => e.name == "phase shift") ? 0 : (100 * (Math.min(robot.dotDamage, robot.health) / robot.maxhealth))}%; height: 100%; background-color: #ffff00;">
            </div>
            <div id="lastStand" style="display: true; position: absolute; top: 0px; left: 0px; width: ${100 * ((robot.lastStandThreshold * robot.maxhealth) / robot.maxhealth)}%; height: 100%; background-color: rgb(0, 0, 0, .3);">
            </div>
            <div style="position: absolute; top: 0px; left: 5px; font-size: 30px; color: ${player.league <= 300 && player.gameMode == 2 ? "#00f" : "#000"};">
            ${removeDecimals(robot.health)}
            </div>
            `;
            let mothershipData = players[robot.playersIndexSid];
            if (mothershipData && mothershipData.mothership) {
                mothershipData = mothershipData.mothership;
                document.getElementById("mothershipBar").innerHTML = `
                <div style="position: absolute; top: 0px; right: 0px; height: ${100 * mothershipData.current}%; width: 100%; background-color: #ffff00;">
                </div>
                <div style="position: absolute; display: flex; justify-content: center; align-items: center; top: 0px; right: 0px; height: 100%; width: 100%; font-size: 16px;">
                ${Math.floor(mothershipData.current * 100)}%
                </div>
                `;
            } else {
                document.getElementById("mothershipBar").style.display = "none";
            }
        }
        if (robot.name.includes("Ultimate")) {
            robot.tracers.push({
                x: robot.x,
                y: robot.y
            });
            if (robot.tracers.length > 50) {
                if (robot.tracers.length > 51) {
                    robot.tracers = [];
                } else {
                    robot.tracers.shift();
                }
            }
        }
        if (robot.isMe) drawWeaponUI(robot, delta);
        if (buildings.find(e => e.name == "hill" && dist(e, robot) <= e.scale)) {
            robot.avoidBuildings = true;
        }
        collideWithBuildings(robot, delta, isAlly);
        doWeaponStuff(robot, delta, isAlly);
        doDroneWeaponStuff(robot, isAlly);
        if (robot.isMe && robot.usedLastStand) {
            document.getElementById("lastStand").style.display = (lastStand || "none");
        }
        if (robot.superMechanic) {
            let percent = robot.superMechanic * robot.maxhealth;
            if (robot.superMechanicLast______ == null) robot.superMechanicLast______ = 0;
            robot.superMechanicLast______ -= delta;
            if (robot.superMechanicLast______ <= 0) {
                robot.superMechanicLast______ = 1e3;
                robot.grayDamage = Math.max(0, robot.grayDamage - percent)
                changeHealth(robot, {
                    amount: percent
                }, true);
            }
        }
        if (robot.mechanicHeal) {
            let percent = robot.mechanicHeal * robot.maxhealth;
            if (robot.mechanicHealLast______ == null) robot.mechanicHealLast______ = 0;
            robot.mechanicHealLast______ -= delta;
            if (robot.mechanicHealLast______ <= 0) {
                robot.mechanicHealLast______ = 1e3;
                changeHealth(robot, { amount: percent }, true);
            }
        }
        doPlayerMovement(robot, delta, {
            hasStampede: robot.effects.find(e => e.name == "stampede" && !e.a),
            slowdownMulti: slowdownMulti,
            speedMulti: speedMulti,
            isAlly: isAlly
        });
        doBorderCollision(robot, delta);
        decelerateRobot(robot, delta);
        if (robot.health <= 0 || robot.kill || robot.killed) {
            if (robot.revive && !robot.kill) {
                doReviveFunction(robot);
            } else {
                if (robot.isMe) {
                    robot.dead = true;
                    players[0].robotIndex = -1;
                    document.getElementById("shields").innerHTML = "";
                    document.getElementById("abilityCharges").innerHTML = "";
                    document.getElementById("abilityCharges2").innerHTML = "";
                    document.getElementById("useAbility").style.display = "none";
                    document.getElementById("useAbility2").style.display = "none";
                    document.getElementById("useActiveModule").style.display = "none";
                    document.getElementById("weaponThing").style.display = "none";
                    document.getElementById("healthBar").style.display = "none";//
                    document.getElementById("mothershipBar").style.display = "none";
                    document.getElementById("titanChargeBar").style.display = "none";
                    let hasRobots = players[0].robots.find(e => e && !e.USED);
                    document.getElementById("chooseSlot").style.bottom = `0px`;
                    if (document.getElementById("useSlot8")) {
                        document.getElementById("useSlot8").style.display = "block";
                    }
                    document.getElementById("mapName").style.display = "block";
                    if (!hasRobots) {
                        document.getElementById("chooseSlot").style.bottom = `-200px`;
                        document.getElementById("mapName").style.display = "none";
                        endGame([...players], false);
                    }
                    updateChooseSlots();
                } else {
                    players[index].robots[players[index].robotIndex].USED = true;
                    players[index].robotIndex++;
                    if (!players[index].robots[players[index].robotIndex]) {
                        players[index].robotIndex = -1;
                        let haveEnemyes = true;
                        for (let asdasd = 0; asdasd < players.length; asdasd++) {
                            let ROBOBTS = players[asdasd].robots;
                            if (players[asdasd].isAlly != true && ROBOBTS.some(e => e && !e.USED)) {
                                haveEnemyes = false;
                                break;
                            }
                        }
                        if (haveEnemyes) {
                            document.getElementById("useAbility").style.display = "none";
                            document.getElementById("useAbility2").style.display = "none";
                            document.getElementById("useActiveModule").style.display = "none";
                            document.getElementById("weaponThing").style.display = "none";
                            document.getElementById("healthBar").style.display = "none";
                            document.getElementById("chooseSlot").style.bottom = "-200px";
                            document.getElementById("mothershipBar").style.display = "none";
                            document.getElementById("titanChargeBar").style.display = "none";
                            endGame([...players], true);
                        }
                    }
                }
            }
        }
    }
    function updatePlayer(delta) {
        let Player = players[0];
        if (Player.robotIndex >= 0) {
            let robot = Player.robots[Player.robotIndex];
            if (Player.mothership.data) {
                document.getElementById("mothershipBar").style.display = "block";
            }
            if (document.getElementById("useSlot8")) {
                document.getElementById("titanChargeBar").style.display = "block";
                Player.titanCharge = Math.min(1, Player.titanCharge);
                document.getElementById("titanChargeBar").innerHTML = `
                <div style="position: absolute; top: 0px; right: 0px; height: ${100 * Player.titanCharge}%; width: 100%; background-color: #00ff00;">
                </div>
                <div style="position: absolute; display: flex; justify-content: center; align-items: center; top: 0px; right: 0px; height: 100%; width: 100%; font-size: 16px;">
                ${Math.floor(Player.titanCharge * 100)}%
                </div>
                `;
            } else {
                document.getElementById("titanChargeBar").style.display = "none";
            }
            updateRobot(robot, true, delta);
        }
    }
    var lastUpdate = Date.now();
    function findPlayerBySid(sid) {
        for (let i = 0; i < players.length; i++) {
            for (let t = 0; t < players[i].robots.length; t++) {
                let robot = players[i].robots[t];
                if (robot && robot.inGameSid == sid) {
                    return players[i];
                }
            }
        }
    }
    function findEnemyBySid(sid) {
        return enemies.find(e => e.inGameSid == sid);
    }
    function manageImmuneAmp(robot, amount) {
        if (!robot.immuneAmp) return;
        amount = Math.abs(amount);
        if (robot.immuneAmp.thing == null) robot.immuneAmp.thing = 0;
        robot.immuneAmp.thing += amount;
        if (robot.immuneAmp.thing >= 30e3) {
            robot.immuneAmp.thing = 0;
            let asd = robot.effects.filter(e => e.name == robot.immuneAmp.name);
            if (asd.length >= 60) return;
            let last = asd.length;
            if (asd.length + robot.immuneAmp.amount >= 60) {
                let amount = 60 - asd.length;
                for (let i = 0; i < amount; i++) {
                    robot.effects.push({
                        name: robot.immuneAmp.name,
                        lastForever: true,
                        lastTime: 1
                    });
                }
                robot.normalMaxHealth += robot.immuneAmp.healthIncrease * amount;
                robot.maxhealth += robot.immuneAmp.healthIncrease * amount;
                robot.grayDamage *= .5;
            } else {
                for (let i = 0; i < robot.immuneAmp.amount; i++) {
                    robot.effects.push({
                        name: robot.immuneAmp.name,
                        lastForever: true,
                        lastTime: 1
                    });
                }
                robot.normalMaxHealth += robot.immuneAmp.healthIncrease * robot.immuneAmp.amount;
                robot.maxhealth += robot.immuneAmp.healthIncrease * robot.immuneAmp.amount;
            }
            let nsew = robot.effects.filter(e => e.name == robot.immuneAmp.name).length;
            if (last < 20 && nsew >= 20) {
                robot.effects.push({
                    name: "freeze immune",
                    lastTime: 1,
                    lastForever: true
                });
            } else if (last < 40 && nsew >= 40) {
                robot.effects.push({
                    name: "slowdown immune",
                    lastTime: 1,
                    lastForever: true
                });
            } else if (last < 60 && nsew >= 60) {
                robot.effects.push({
                    name: "rust immune",
                    lastTime: 1,
                    lastForever: true
                });
            }
        }
    }
    function doDroneDamageStuff(robot, amount) {
        if (!robot.drones || !robot.drones.length) return;
        amount = Math.abs(amount);
        let health = robot.health - amount;
        for (let j = 0; j < robot.drones.length; j++) {
            for (let i = 0; i < robot.drones[j].abilities.length; i++) {
                let data = robot.drones[j].abilities[i];
                if (data) {
                    if (data.name == "On Threshold: Resist" || data.name == "On Threshold: Fix%") {
                        let thresholds = [robot.maxhealth * .7, robot.maxhealth * .5, robot.maxhealth * .3];
                        for (let i = 0; i < thresholds.length; i++) {
                            let threshold = thresholds[i];
                            if (!robot.effects.find(e => e.name == "cooldown_timer" && e.threshold == (i + 1) && e.reason == data.name)) {
                                if (robot.health > threshold && health <= threshold) {
                                    robot.effects.push({
                                        name: "cooldown_timer",
                                        reason: data.name,
                                        threshold: i + 1,
                                        lastTime: data.reload
                                    });
                                    if (data.name == "On Threshold: Fix%") {
                                        let amount = robot.maxhealth * data.healPower;
                                        robot.grayDamage = Math.max(0, robot.grayDamage - (amount * data.grayDamageHeal_p));
                                        changeHealth(robot, {
                                            amount: amount
                                        }, false, robot);
                                    } else {
                                        robot.effects.push({
                                            name: "defense points",
                                            amount: data.defenseIncrease,
                                            lastTime: 5e3
                                        });
                                    }
                                }
                            }
                        }
                    } else if (data.name == "On First Hit: Stealth") {
                        if (!data.used) {
                            data.used = true;
                            robot.effects.push({
                                name: "stealth",
                                lastTime: data.stealthTime
                            })
                            robot.drones[0].effects.push({
                                name: "speed",
                                amount: 3,
                                lastTime: 5e3
                            });
                        }
                    } else if (data.name == "On Low Durability: [Y_Shield]") {
                        if (health > robot.maxhealth * .3) continue;
                        if (data.oneTimeUse) {
                            if (!data.used) {
                                data.used = true;
                                robot.drones[0].effects.push({
                                    name: "speed",
                                    amount: 1,
                                    lastTime: 5e3
                                });
                                robot.shields.push({
                                    type: data.type,
                                    health: data.shielding,
                                    maxhealth: data.shielding
                                });
                            }
                        }
                    } else if (data.name == "On High Damage: Stealth" || data.name == "On Mild Damage: [B_Shield]" || data.name == "On Mild Damage: [P_Shield]" || data.name == "On High Damage: [P_Shield]" || data.name == "On Mild Damage: Fix" || data.name == "On High Damage: Fix") {
                        if (data.damageTook == null) data.damageTook = 0;
                        if (data.damageTook2 == null) data.damageTook2 = [];
                        if (data.damageTook < 0) data.damageTook = 0;
                        if (!robot.effects.find(e => e.name == "cooldown_timer" && e.reason == data.name)) {
                            data.damageTook += amount;
                            data.damageTook2.push(setTimeout(() => {
                                data.damageTook -= amount;
                            }, data.in));
                            if (data.damageTook >= data.required) {
                                robot.effects.push({
                                    name: "cooldown_timer",
                                    reason: data.name,
                                    lastTime: data.reload
                                });
                                if (data.name == "On Mild Damage: [P_Shield]") {
                                    robot.grayDamage *= .85;
                                }
                                if (data.name == "On High Damage: Stealth") {
                                    robot.effects.push({
                                        name: "stealth",
                                        lastTime: data.stealthTime
                                    });
                                } else if (data.name == "On Mild Damage: Fix" || data.name == "On High Damage: Fix") {
                                    changeHealth(robot, {
                                        amount: data.healing
                                    }, false, robot);
                                } else {
                                    robot.shields.unshift({
                                        type: data.type,
                                        lastTime: data.duration,
                                        droneShield: true,
                                        health: data.shielding,
                                        maxhealth: data.shielding
                                    });
                                }
                                robot.drones[0].effects.push({
                                    name: "speed",
                                    amount: 3,
                                    lastTime: 5e3
                                });
                                data.damageTook2.forEach(e => {
                                    clearTimeout(e);
                                });
                            }
                        } else {
                            data.damageTook = 0;
                            data.damageTook2.forEach(e => {
                                if (e) clearTimeout(e);
                            });
                        }
                    }
                }
            }
        }
    }
    function doOnDamageEffects(robot, amount, noAmp) {
        if (amount >= 0) return;
        amount = Math.round(amount);
        if (!noAmp) manageImmuneAmp(robot, amount);
        doDroneDamageStuff(robot, amount);
        if (!robot.effects || robot.dummy) {
            if (robot.dps == null) robot.dps = 0;
            if (robot.dpsh == null) robot.dpsh = 0;
            robot.dps += Math.abs(amount);
            if (robot.dps >= robot.dpsh) {
                robot.dpsh = robot.dps;
            }
            setTimeout(() => {
                robot.dps -= Math.abs(amount);
            }, 1e3);
            if (robot.dpm == null) robot.dpm = 0;
            robot.dpm += Math.abs(amount);
            setTimeout(() => {
                robot.dpm -= Math.abs(amount);
            }, 60e3);
        } else {
            if (robot.damageTokenHAHA == null) robot.damageTokenHAHA = 0;
            robot.damageTokenHAHA += Math.abs(amount);
            let thingy = setTimeout(() => {
                robot.damageTokenHAHA = Math.max(0, robot.damageTokenHAHA - Math.abs(amount));
            }, 7e3);
            if (robot.name == "Ultimate Green Circle") {
                if (!robot.effects.find(e => e.name == "cooldown_timer" && e.onDamageHealShield == robot.name)) {
                    if (robot.damageTokenHAHA >= 90e3) {
                        robot.damageTokenHAHA = 0;
                        clearTimeout(thingy);
                        robot.shields.push({
                            type: "purple",
                            health: 0,
                            lastTime: 3000
                        });
                        robot.effects.push({
                            name: "cooldown_timer",
                            onDamageHealShield: robot.name,
                            lastTime: 18e3
                        });
                    }
                }
            } else if (robot.name == "Gray Pentagon") {
                if (!robot.effects.find(e => e.name == "cooldown_timer" && e.onDamageHealShield == robot.name)) {
                    if (robot.damageTokenHAHA >= 150e3) {
                        clearTimeout(thingy);
                        let amount = robot.maxhealth * .25;
                        robot.damageTokenHAHA = 0;
                        changeHealth(robot, {
                            amount: amount
                        }, false, robot);
                        robot.effects.push({
                            name: "cooldown_timer",
                            onDamageHealShield: robot.name,
                            lastTime: 15e3
                        });
                    }
                }
            }
        }
    }
    var killDisplayTimeout = null;
    var killDisplayText = ["KILL", "DOUBLE KILL", "TRIPLE KILL", "RAMPAGE", "GODLIKE", "BEYOND GODLIKE", "LIVING LEGEND"];
    function doHuntStuff(e, object) {
        let track = object.effects.find(e => e.name == "track");
        if (track) {
            if (e.effects.filter(e => e.huntStacks).length < 5) {
                e.effects.push({
                    name: "speed",
                    power: .15,
                    lastTime: 1,
                    huntStacks: true,
                    lastForever: true
                });
                e.effects.push({
                    name: "defense points",
                    amount: track.defensePoints,
                    lastTime: 1,
                    huntStacks: true,
                    lastForever: true
                });
                e.effects.push({
                    name: "attack",
                    power: .15,
                    lastTime: 1,
                    huntStacks: true,
                    lastForever: true
                });
            }
            let repar = e.maxhealth * .15;
            e.grayDamage = Math.max(0, e.grayDamage - repar);
            changeHealth(e, {
                amount: repar
            }, false);
        }
    }
    function doDoKillStuff(doer, amount, object, noAmp) {
        if (object.thingToKill && !object.revive) {
            if (doer.battleStats.kills == null) doer.battleStats.kills = 0;
            if (doer.battleStats.killCount == null) doer.battleStats.killCount = 0;
            if (doer.battleStats.killCountTimeout == null) doer.battleStats.killCountTimeout = null;
            let assist = false;
            if (object.lastAttackedEnemies) {
                for (let i = 0; i < object.lastAttackedEnemies.length; i++) {
                    let data = object.lastAttackedEnemies[i];
                    if (Date.now() - data.date <= 10e3 && data.inGameSid != doer.inGameSid) {
                        if (data.dmg >= object.maxhealth * .4) {
                            let me = findRobotBySid(data.inGameSid);
                            if (me) {
                                if (me.isMe) {
                                    assist = true;
                                }
                                me.battleStats.kills += .5;
                                doHuntStuff(me, object);
                            }
                        }
                    }
                }
            }
            if ((doer.isMe && players.length > 1) || assist) {
                clearTimeout(killDisplayTimeout);
                if (assist) {
                    document.getElementById("killDisplay").innerHTML = "ASSIST";
                } else {
                    if (object.titan) {
                        document.getElementById("killDisplay").innerHTML = "TITAN SLAYER";
                    } else if (killDisplayText[doer.battleStats.killCount]) {
                        document.getElementById("killDisplay").innerHTML = killDisplayText[doer.battleStats.killCount];
                    } else {
                        document.getElementById("killDisplay").innerHTML = killDisplayText[killDisplayText.length - 1] + " X" + ((doer.battleStats.killCount - killDisplayText.length) + 2);
                    }
                }
                document.getElementById("killDisplay").style.display = "block";
                killDisplayTimeout = setTimeout(() => {
                    document.getElementById("killDisplay").style.display = "none";
                }, 1e3);
            }
            object.killed = true;
            doer.battleStats.kills++;
            doHuntStuff(doer, object);
            if (players.length > 1) {
                clearTimeout(doer.battleStats.killCountTimeout);
                doer.battleStats.killCount++;
                doer.battleStats.killCountTimeout = setTimeout(() => {
                    if (doer && doer.battleStats) {
                        doer.battleStats.killCount = 0;
                    }
                }, 10e3);
            }
            if (doer.onKillDefense) {
                doer.effects.push({
                    name: "defense points",
                    amount: doer.onKillDefense,
                    lastTime: 5e3
                });
            }
            if (doer.onKillHeal) {
                let value = doer.maxhealth * doer.onKillHeal;
                doer.grayDamage = Math.max(0, doer.grayDamage - value);
                changeHealth(doer, {
                    amount: value
                }, false, doer);
            }
            if (doer.onKillSpeed) {
                doer.effects.unshift({
                    name: "speed",
                    power: doer.onKillSpeed,
                    lastTime: 5e3
                });
            }
            let Player = players[doer.playersIndexSid];
            if (Player) Player.titanCharge += (!hasPlayers() ? 0.007 : 0.07);
            if (Player && Player.mothership && Player.mothership.data) {
                Player.mothership.current += (!hasPlayers() ? .0075 : .11) * (1 + Player.mothership.data.chargeSpeed);
                if (Player.mothership.current > 1) Player.mothership.current = 1;
            }
            if (doer.drones.length) {
                for (let j = 0; j < doer.drones.length; j++) {
                    for (let t = 0; t < doer.drones[j].abilities.length; t++) {
                        let data = doer.drones[j].abilities[t];
                        if (data) {
                            if (data.name == "On Kill: Defense") {
                                if (!doer.effects.find(e => e.name == "cooldown_timer" && e.reason == data.name)) {
                                    doer.effects.push({
                                        name: "defense points",
                                        lastForever: true,
                                        amount: data.defenseIncrease,
                                        lastTime: 1
                                    });
                                    doer.effects.push({
                                        name: "cooldown_timer",
                                        reason: data.name,
                                        lastTime: data.reload
                                    });
                                    doer.drones[0].effects.push({
                                        name: "speed",
                                        amount: 1,
                                        lastTime: 5e3
                                    });
                                }
                            } else if (data.name == "On Kill: Damage") {
                                if (!doer.effects.find(e => e.name == "cooldown_timer" && e.reason == data.name)) {
                                    doer.effects.push({
                                        name: "cooldown_timer",
                                        reason: data.name,
                                        lastTime: data.reload
                                    });
                                    doer.effects.push({
                                        name: "attack",
                                        power: data.onKillDamage,
                                        lastTime: 1,
                                        lastForever: true
                                    });
                                }
                            } else if (data.name == "On Kill: Speed") {
                                if (doer.effects.filter(e => e.name == "speed" && e.typeOfHAHAHAHAHAHAHA).length < data.limit && !doer.effects.find(e => e.name == "cooldown_timer" && e.reason == data.name)) {
                                    doer.effects.push({
                                        name: "cooldown_timer",
                                        reason: data.name,
                                        lastTime: data.reload
                                    });
                                    doer.effects.push({
                                        name: "speed",
                                        power: data.onKillSpeed,
                                        typeOfHAHAHAHAHAHAHA: true,
                                        lastTime: 1,
                                        lastForever: true
                                    });
                                }
                            } else if (data.name == "On Kill: Fix") {
                                if (!doer.effects.find(e => e.name == "cooldown_timer" && e.reason == data.name)) {
                                    doer.effects.push({
                                        name: "cooldown_timer",
                                        reason: data.name,
                                        lastTime: data.reload
                                    });
                                    let amount = doer.maxhealth * data.onKillFix;
                                    doer.grayDamage = Math.max(0, doer.grayDamage - (amount * data.grayDamageHeal_p));
                                    changeHealth(doer, {
                                        amount: amount
                                    }, false, doer);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    function doOnKillStuff(doer, amount, object, noAmp) {
        if (doer.battleStats == null) doer.battleStats = {};
        if (doer.battleStats.dmg == null) doer.battleStats.dmg = 0;
        let value = Math.abs(amount);
        if ((amount < 0 ? true : amount >= 0 && object != doer) && object.health > 0) {
            if (amount >= 0) {
                if (object.health + amount >= (object.maxhealth - object.grayDamage)) {
                    amount = (object.maxhealth - object.grayDamage) - object.health;
                }
            }
            if (object.health + amount <= 0) {
                if (object.health > 0) {
                    damageDone = object.health;
                    doer.battleStats.dmg += object.health;
                    doDoKillStuff(doer, amount, object, noAmp);
                }
            } else {
                doer.battleStats.dmg += value;
                damageDone = value;
            }
            if (amount < 0 && !noAmp) {
                let amps = doer.effects.filter(e => e.name == "nuclear amps");
                if (amps.length < 95) {
                    if (doer.dmgDamageDone == null) doer.dmgDamageDone = 0;
                    doer.dmgDamageDone += Math.abs(amount);
                    if (doer.dmgDamageDone - 25e3 >= 0 && doer.modules) {
                        let Amps = doer.modules.filter(e => e.name == "Nuclear Amplifier");
                        if (amps.length + Amps.length >= 95) {
                            let amount = 95 - amps.length;
                            let healAmount = 0;
                            Amps.forEach(e => {
                                healAmount += e.selfFixRepair;
                            });
                            changeHealth(doer, {
                                amount: healAmount
                            }, true, doer);
                            for (let i = 0; i < amount; i++) {
                                doer.effects.push({
                                    name: "nuclear amps",
                                    lastForever: true,
                                    lastTime: 1
                                });
                            }
                        } else {
                            for (let i = 0; i < Amps.length; i++) {
                                doer.effects.push({
                                    name: "nuclear amps",
                                    lastForever: true,
                                    lastTime: 1
                                });
                            }
                        }
                        doer.dmgDamageDone = 0;
                    }
                }
            }
        }
    }
    function changeHealth(object, { amount, graydmg, noAmp, onDamageHealBack, maxhealthDamage, isDotDamage, execute, defensePointsBypass, bypassReflector, damageTypeName, motherShipCharge }, isPlayer, doer, noDefense) {
        try {
            if (doer && doer.name == "Polygon") {
                if (!motherShipCharge || motherShipCharge <= 0) {
                    motherShipCharge = 0.0000125;
                }
            }
            if (doer && doer.effects) {
                if (doer.effects.find(e => e.name == "defense breach")) {
                    noDefense = true;
                    if (doer.name == "Bersagliere") onDamageHealBack = .5;
                }

                if (doer.effects.find(e => e.name == "defense mit")) {
                    defensePointsBypass = 0;
                    bypassReflector = false;
                }
            }
            amount = parseInt(removeDecimals(amount));
            if (object.killed && object.health <= 0) amount = 0;
            if (!object || (object.health <= 0 && object.type != "purple" && object.type != "purple normal")) return;
            let resistance = 0;
            if (amount < 0 && object.effects && object.effects.find(e => e.name == "block" && !e.used)) {
                amount = 0;
                let effect = object.effects.find(e => e.name == "block" && !e.used);
                effect.lastForever = false;
                effect.lastTime = 0;
                effect.used = true;
                if (object.drone) {
                    for (let i = 0; i < object.drones[0].abilities.length; i++) {
                        let data = object.drones[0].abilities[i];
                        if (data.name == "On Block: Fix") {
                            let healing = data.healing;
                            object.grayDamage = Math.max(0, object.grayDamage - (healing * .05));
                            changeHealth(object, {
                                amount: healing
                            }, false, object);
                        } else if (data.name == "On Block: Damage" && object.effects.filter(e => e.name == "attack" && e.onBlockDmg).length < data.limit) {
                            object.effects.push({
                                name: "attack",
                                power: data.onKillDamage,
                                onBlockDmg: true,
                                lastTime: 1,
                                lastForever: true
                            });
                        }
                    }
                }
            }
            if (object.builtInDefensePoints) {
                resistance += object.builtInDefensePoints;
            }
            if (object.baseDP) {
                resistance += object.baseDP;
            }
            if (object.effects && object.effects.find(e => e.name == "last stand")) {
                resistance += 9000;
            }
            let bypassedDefensePoints = false;
            if (defensePointsBypass + 1 >= 1 && resistance > 0) {
                let execute = function () {
                    bypassedDefensePoints = true;
                    resistance *= defensePointsBypass;
                };
                if (object.effects) {
                    if (!object.effects.find(e => e.name == "anti defense mig")) {
                        execute();
                    }
                } else {
                    execute();
                }
            }
            if (noDefense || isDotDamage || damageTypeName == "BLAST EFFECT") {
                bypassedDefensePoints = true;
                resistance = 0;
            }
            if (resistance > 0 && object.effects) {
                let e1 = 1;
                object.effects.filter(e => e.name == "frag").forEach(e => {
                    e1 -= e.power;
                });
                e1 = Math.max(e1, 0);
                resistance *= e1;
            }
            let defense = defensePointsToResistance(resistance);
            let orgnialdmg = 0;
            if (amount < 0) {
                amount *= defense;
                if (doer && doer.effects) {
                    let increase = 1;
                    doer.effects.forEach(e => {
                        if (e.name == "attack") {
                            increase += e.power;
                        } else if (e.name == "Cannonier") {
                            increase += .5;
                        }
                    });
                    amount *= increase;
                }
                let deathmark = 1;
                if (object.effects) {
                    object.effects.forEach(e => {
                        if (e.name == "deathmark") {
                            deathmark += e.power;
                        } else if (e.name == "track") {
                            deathmark += e.deathmark;
                        }
                    });
                    amount *= deathmark;
                }
                if (object.isFREEZE) {
                    amount *= 1.2;
                }
                if (object.effects && object.effects.find(e => e.name == "phase shift")) {
                    return;
                }
                orgnialdmg = amount;
                if (object.effects && !noDefense && !isDotDamage) {
                    let force = object.effects.find(e => e.name == "forcefield");
                    let counterSuppression = object.effects.find(e => e.name == "counter suppression");
                    if (counterSuppression && doer && doer.effects) {
                        if (!doer.effects.find(e => e.name == "suppression" && e.lastTime > 0)) {
                            counterSuppression.lastForever = false;
                            counterSuppression.lastTime = 0;
                            doer.effects.push({
                                name: "suppression",
                                power: 1 - counterSuppression.power,
                                lastTime: counterSuppression.durationOfSuppression
                            });
                        }
                    }
                    if (force) {
                        if (force.data.health > 0) {
                            force.data.lastHit = Date.now();
                            force.data.health = Math.max(force.data.health - Math.abs(amount), 0);
                            if (force.data.min) {
                                let res = force.data.resistance;
                                let p = force.data.health / force.data.maxhealth;
                                let min = (1 - force.data.min) * (1 - p);
                                let nres = res - min;
                                amount *= (1 - nres);
                            } else {
                                let resistance = force.data.resistance;
                                resistance *= force.data.health / force.data.maxhealth;
                                amount *= (1 - resistance);
                            }
                        }
                    }
                }
            }
            if (amount >= 0) {
                if (object.healingMulti) {
                    amount *= object.healingMulti;
                }
                if (object.defenseAmp) {
                    let aaaa = amount;
                    if (object.health + aaaa >= object.maxhealth - object.grayDamage) {
                        aaaa = (object.maxhealth - object.grayDamage) - object.health;
                        if (aaaa <= 0) aaaa = 0;
                    }
                    if (object.defenseAmp.repaired == null) object.defenseAmp.repaired = 0;
                    object.defenseAmp.repaired += aaaa;
                    if (object.defenseAmp.repaired >= 40e3) {
                        let amount1 = Math.floor(object.defenseAmp.repaired / 40e3);
                        let effect = object.effects.find(e => e.name == "defense amp");
                        if (!effect || effect.stacks < 60) {
                            if (effect) {
                                let totalGain = amount1 * object.defenseAmp.amount;
                                if (effect.stacks + totalGain >= 60) {
                                    let gain = 60 - effect.stacks;
                                    object.baseDP += gain * object.defenseAmp.increase;
                                    effect.stacks += gain;
                                    object.effects.push({
                                        name: "anti defense mig",
                                        lastTime: 60e3 * object.defenseAmp.amount
                                    });
                                } else {
                                    object.baseDP += totalGain * object.defenseAmp.increase;
                                    effect.stacks += totalGain;
                                }
                            } else {
                                object.baseDP += (amount1 * object.defenseAmp.amount) * object.defenseAmp.increase;
                                object.effects.push({
                                    name: "defense amp",
                                    stacks: amount1 * object.defenseAmp.amount,
                                    lastTime: 1,
                                    lastForever: true
                                });
                            }
                        }
                        object.defenseAmp.repaired = 0;
                    }
                }
                if (object.type == "purple normal" && object.owner) {
                    if (object.amountOfHealthGained == null) object.amountOfHealthGained = 0;
                    if (object.amountOfHealthGained < object.limit) {
                        if (object.amountOfHealthGained + amount >= object.limit) {
                            let diff = (object.amountOfHealthGained + amount) - object.limit;
                            object.owner.health += diff;
                            object.owner.maxhealth += diff;
                            object.owner.normalMaxHealth += diff;
                            object.amountOfHealthGained += diff;
                            object.health += diff;
                        } else {
                            object.owner.health += amount;
                            object.owner.maxhealth += amount;
                            object.owner.normalMaxHealth += amount;
                            object.amountOfHealthGained += amount;
                            object.health += amount;
                        }
                    }
                }
            }
            if (amount < 0 && onDamageHealBack && doer) {
                changeHealth(doer, {
                    amount: Math.abs(amount * onDamageHealBack)
                }, false, doer);
            }
            if (amount >= 0 && object.effects) {
                let amounts = 1;
                object.effects.forEach(e => {
                    if (e.name == "rust" && e.lastTime > 0) {
                        amounts -= e.power;
                    }
                });
                amounts = Math.max(0, amounts);
                amount *= amounts;
            }
            if (doer && (object.turnDmgIntoDOT ? isDotDamage : true)) {
                doOnKillStuff(doer, amount, object, noAmp);
            }
            if (amount < 0 && isDotDamage && object.dotResistance) {
                amount *= object.dotResistance;
            }
            if (doer && doer.effects && !isDotDamage) {
                let milt = 1;
                doer.effects.forEach(e => {
                    if (e.name == "suppression") {
                        milt *= e.power;
                    }
                });
                amount *= milt;
            }
            if (amount < 0 && !noDefense && object.effects) {
                let normalDmg = orgnialdmg;
                for (let i = 0; i < object.effects.length; i++) {
                    let effect = object.effects[i];
                    if (effect.name == "reflector") {
                        if (doer && !bypassReflector && !isDotDamage) {
                            changeHealth(doer, {
                                amount: normalDmg * effect.return,
                                bypassReflector: true,
                                damageTypeName: "REFLECTOR"
                            }, object.isMe, object);
                        }
                        amount *= (1 - effect.block);
                    }
                }
            }
            if ((object.turnDmgIntoDOT ? isDotDamage : true) && amount < 0 && !object.LASTSTANDISON) {
                addGrayDamage(object, amount, graydmg, isDotDamage, maxhealthDamage);
            }
            if (doer && doer.playersIndexSid != null) {
                let player = players[doer.playersIndexSid];
                if (amount < 0) {
                    player.titanCharge += (Math.abs(amount) / 20e6);
                } else if (doer != object) {
                    if (object.health < object.maxhealth - object.grayDamage) {
                        player.titanCharge += (Math.abs(amount) / 10e6);
                    } else {
                        amount = 0;
                    }
                }
                if (motherShipCharge && player.mothership && player.mothership.data) {
                    player.mothership.current += motherShipCharge * (1 + player.mothership.data.chargeSpeed);
                    if (player.mothership.current > 1) player.mothership.current = 1;
                }
            }
            if (amount != 0) {
                if (doer && amount < 0) {
                    if (object.effects && object.effects.find(e => e.name == "Ultimate Reflecting Dash") && !isDotDamage) {
                        if (doer.effects.filter(e => e.name == "suppression" && e.uhEz == "Ultimate Reflecting Dash").length < 5) {
                            doer.effects.push({
                                name: "suppression",
                                neg: true,
                                uhEz: "Ultimate Reflecting Dash",
                                power: (1 - object.abilities.find(e => e.suppressionPower).suppressionPower),
                                lastTime: 10e3
                            });
                        } else {
                            doer.effects.filter(e => e.name == "suppression" && e.uhEz == "Ultimate Reflecting Dash").forEach(e => {
                                e.lastTime = 10e3;
                            });
                        }
                    }
                }
                if (object.dummy) {
                } else if (!object.isMe) {
                    if (doer && doer.isMe) {
                        if (amount < 0) {
                            if (isDotDamage) {
                                addText(object.x, object.y, amount, 1000, "#ffff00");
                            } else if (object.turnDmgIntoDOT ? isDotDamage : true) {
                                addText(object.x, object.y, amount, 1000, bypassedDefensePoints ? "#ffff00" : "#fff");
                            }
                        } else {
                            addText(object.x, object.y, amount, 1000, "#8ecc51");
                        }
                    }
                } else if (object.isMe) {
                    if (amount > 0) {
                        addText(object.x, object.y, amount, 1000, "#8ecc51");
                    } else if (object.turnDmgIntoDOT ? isDotDamage : true) {
                        addText(object.x, object.y, amount, 1000, "#f00");
                    }
                }
                doOnDamageEffects(object, amount, noAmp);
                if (object.turnDmgIntoDOT && amount < 0 && doer && !noDefense) {
                    let duration = object.name == "Polygon" ? 30 : object.name == "Mauler" ? 12 : object.name == "Pink Circle" ? 10 : 7;
                    if (object.dotConverter == null) object.dotConverter = [];
                    object.dotConverter.push({
                        amount: amount,
                        doer: doer.inGameSid,
                        duration: duration
                    });
                } else {
                    if (amount < 0 && !object.dummy) object.damagedTime = Date.now();
                    if (object.repairAmp && amount < 0 && !noAmp) {
                        let repairamp = object.effects.find(e => e.name == "repair amp");
                        if (!repairamp || repairamp.stacks < 60) {
                            let maountofstaks = repairamp ? repairamp.stacks : 0;
                            if (object.HAHAHAHAMoUntDMGMMGMGGM == null) object.HAHAHAHAMoUntDMGMMGMGGM = 0;
                            object.HAHAHAHAMoUntDMGMMGMGGM += Math.abs(amount);
                            if (object.HAHAHAHAMoUntDMGMMGMGGM >= object.repairAmp.require) {
                                object.HAHAHAHAMoUntDMGMMGMGGM = 0;
                                let amount = object.repairAmp.amount;
                                if (maountofstaks + amount >= 60) {
                                    amount = 60 - maountofstaks;
                                    if (object.repairAmp.titan) {
                                        object.grayDamage = Math.max(0, object.grayDamage - object.repairAmp.graydmg);
                                        changeHealth(object, {
                                            amount: object.repairAmp.normal
                                        }, false, object);
                                        object.effects.push({
                                            name: "anti defense mig",
                                            lastForever: true,
                                            lastTime: 1
                                        });
                                    } else {
                                        let percent = (5 - object.repairAmp.amount) / 5;
                                        object.grayDamage *= percent;
                                        object.effects.push({
                                            name: "defense points",
                                            amount: object.repairAmp.defensePoints,
                                            lastForever: true,
                                            lastTime: 1
                                        });
                                    }
                                }
                                let effect = object.effects.find(e => e.name == "repair amp");
                                if (effect) {
                                    effect.stacks += amount;
                                } else {
                                    object.effects.push({
                                        name: "repair amp",
                                        lastForever: true,
                                        stacks: amount,
                                        lastTime: 1
                                    });
                                }

                            }
                        }
                    }
                    object.health += amount;
                    if (amount < 0) {
                        if (object.lastStandThreshold && !object.usedLastStand && object.health < object.maxhealth * object.lastStandThreshold) {
                            object.health = object.maxhealth * object.lastStandThreshold;
                        }
                        if (object.lastAttackedEnemies == null) object.lastAttackedEnemies = [];
                        if (doer) {
                            let Doer = object.lastAttackedEnemies.find(e => e.inGameSid == doer.inGameSid);
                            if (Doer) {
                                if (Date.now() - Doer.date > 10e3) {
                                    Doer.dmg = 0;
                                }
                                Doer.date = Date.now();
                                Doer.dmg += Math.abs(amount);
                            } else {
                                object.lastAttackedEnemies.push({
                                    inGameSid: doer.inGameSid,
                                    date: Date.now(),
                                    dmg: Math.abs(amount)
                                });
                            }
                        }
                        if (maxhealthDamage) {
                            object.maxhealth += amount * .25;
                            object.normalMaxHealth += amount * .25;
                        }
                    }
                    if (execute && object.health > 0 && object.health / object.maxhealth <= execute && !object.killed) {
                        object.kill = true;
                        let player1 = findPlayerBySid(object.inGameSid);
                        let player2 = findPlayerBySid(doer.inGameSid);
                        addLogger(player2, {
                            name: "Executed",
                            level: 1
                        }, player1);
                        doDoKillStuff(doer, amount, object);
                    }
                    if (amount < 0 && object.effects && object.effects.find(e => ["Cannonier", "extra health"].includes(e.name) && e.health > 0)) {
                        let effect = object.effects.find(e => ["Cannonier", "extra health"].includes(e.name) && e.health > 0);
                        effect.health += amount;
                        if (maxhealthDamage) {
                            effect.maxhealth = Math.max(effect.maxhealth + (amount * .5), 0);
                        }
                        if (effect.health <= 0) {
                            object.maxhealth -= effect.maxhealth;
                            object.grayDamage -= effect.grayDamage;
                            if (object.name == "Dark Tan Circle") {
                                effect.lastTime = 0;
                                object.abilities.forEach(e => {
                                    e.abilityLast = 0;
                                    e.abilityReload = e.reload;
                                });
                            }
                        }
                    }
                    if (object.health < 0) {
                        object.health = 0;
                    }
                }
                if (object.lastStandThreshold && !object.usedLastStand) {
                } else if (object.health <= 0 && !object.revive) {
                    let player1 = findPlayerBySid(object.inGameSid);
                    let player2 = findPlayerBySid(doer.inGameSid);
                    if (player1 && player2) {
                        if (isDotDamage) {
                            addLogger(player2, {
                                name: "DoT Effect",
                                level: 1
                            }, player1);
                        } else if (damageTypeName) {
                            addLogger(player2, {
                                name: damageTypeName,
                                level: damageTypeName == "Blast Effect" ? 1 : doer.level
                            }, player1);
                        }
                    }
                }
            }
        } catch (e) { console.log(e); }
    }
    function checkIfHit(proj, enemy, plus) {
        if (Math.hypot(proj.y - enemy.y, proj.x - enemy.x) <= (proj.scale * (plus == "shield" ? 1.5 : 1)) + enemy.scale + (plus == "shield" ? 20 : 0)) {
            return true;
        }
        let dist = Math.hypot(proj.lastY - enemy.y, proj.lastX - enemy.x);
        let velx = proj.x * 2 - proj.lastX;
        let vely = proj.y * 2 - proj.lastY;
        let d = Math.hypot(proj.y - vely, proj.x - velx);
        d = dist <= d ? dist : d;
        let tmplocation = {
            x: proj.lastX + Math.cos(proj.dir) * d,
            y: proj.lastY + Math.sin(proj.dir) * d
        };
        if (Math.hypot(tmplocation.y - enemy.y, tmplocation.x - enemy.x) <= (proj.scale * (plus == "shield" ? 1.5 : 1.2)) + enemy.scale + (plus == "shield" ? 20 : 0)) {
            return true;
        }
        return false;
    }
    function antiTier4_5(bullet, enemy) {
        let amount = 1;
        if (enemy.tier == 3) {
            amount += .75;
        } else if (enemy.tier == 4) {
            amount += 1.5;
        }
        if (enemy.titan) {
            amount += 1.5;
        }
        if (enemy.maxhealth >= 175e3) {
            let mm = enemy.maxhealth - 175e3;
            amount += Math.min(Math.floor(mm / 5e3) * .1, 2);
        }
        let dmg = bullet.dmg * amount;
        if (dmg > 0 && bullet.weaponOwner.name.includes("Divine") && enemy.effects) {
            if (!enemy.effects.find(e => e.name == "phase shift" || e.name == "last stand")) {
                bullet.owner.maxhealth += dmg * 0.05;
                if (bullet.owner.maxhealth > 1e6) bullet.owner.maxhealth = 1e6;
                changeHealth(bullet.owner, {
                    amount: dmg * 2,
                }, bullet.owner.isMe, bullet.owner);
            }
        }
        return dmg;
    }
    var exterminationEnemies = [{
        name: "Burner Circle",
        health: 5e3,
        range: 400,
        dmg: 240,
        fireRate: 350,
        speed: 0.0012,
        scale: 40
    }, {
        name: "Reaper Circle",
        health: 10e3,
        range: 800,
        dmg: 1400,
        fireRate: 1500,
        speed: 0.001,
        scale: 65
    }, {
        name: "Homing Circle",
        health: 40e3,
        range: 4e3,
        dmg: 5e3,
        fireRate: 10e3,
        speed: 0.0004,
        scale: 105
    }, {
        name: "Bastion",
        health: 2e6,
        range: 4e3,
        dmg: 500,
        speed: 0,
        scale: 305,
        boss: true
    }, {
        name: "DoT Circle",
        health: 4e3,
        range: 800,
        dmg: 180,
        fireRate: 650,
        speed: 0.0014,
        scale: 35
    }, {
        name: "Anti Healing Circle",
        health: 40e3,
        range: 1800,
        dmg: 0,
        fireRate: 1e3,
        speed: 0,
        scale: 105
    }, {
        name: "Attacker Circle",
        health: 95e3,
        range: 800,
        dmg: 650,
        fireRate: 120,
        speed: 0.001,
        scale: 75
    }];
    class enemy {
        constructor(data, { health, speed, defensePoints, dmg }) {
            this.blind = false;
            this.shields = [];
            this.builtInDefensePoints = defensePoints || 0;
            this.x = (data.x || Math.random() * mapInfo.x);
            this.y = (data.y || Math.random() * mapInfo.y);
            this.velx = 0;
            this.vely = 0;
            this.dummy = data.dummy;
            this.thingToKill = true;
            this.name = data.name;
            this.grayDamage = 0;
            this.inGameSid = inGameSids;
            this.effects = [];
            this.layer = 0;
            this.abilities = [];
            inGameSids++;
            this.dmg = data.dmg * (dmg || 1);
            this.range = data.range;
            this.health = this.maxhealth = data.health * (health || 1);
            this.fireRate = data.fireRate;
            this.speed = data.speed * (speed || 1);
            this.scale = data.scale;
            if (data.boss == true) {
                this.builtInDefensePoints += 100;
                this.x = mapInfo.x / 2;
                this.y = mapInfo.y / 2;
            }
        }
    }
    var ENEMEMENENMEMMEMEMEMEY = enemy;
    function updateEnemies(delta) {
        let playerRobot = players[0].robots[players[0].robotIndex];
        let data = player.exterminationData;
        if (data) {
            if (data.spawnData) {
                if (data.lastSent == null) data.lastSent = 0;
                if (Date.now() - data.lastSent > data.spawnData.rate) {
                    data.lastSent = Date.now();
                    let rng = exterminationEnemies.filter(e => data.spawnData.enemies.includes(e.name));
                    let m = data.modifiers || {};
                    for (let i = 0; i < data.spawnData.amount; i++) {
                        let em = rng[Math.floor(Math.random() * rng.length)];
                        enemies.push(new enemy(em, m));
                    }
                }
            }
            if (data.goal) {
                let max = Object.keys(data.goal).length;
                let done = 0;
                let goal = data.goal;
                if (goal.kills) {
                    let kills = players[0].robots.filter(item => item && item.battleStats && item.battleStats.kills).map(item => item.battleStats.kills).reduce((acc, current) => acc + current, 0);
                    if (kills >= goal.kills) {
                        done++;
                    }
                }
                if (goal.beacons) {
                    let beacons = players[0].robots.filter(item => item && item.battleStats && item.battleStats.beacons).map(item => item.battleStats.beacons).reduce((acc, current) => acc + current, 0);
                    if (beacons >= goal.beacons) {
                        done++;
                    }
                }
                if (done >= max) {
                    endGame(players, true);
                    enemies = [];
                    return;
                }
            }
        }
        for (let i = 0; i < enemies.length; i++) {
            let enemy = enemies[i];
            if (enemy && playerRobot) {
                enemy.isFREEZE = enemy.freeze ? true : false;
                enemy.freeze = false;
                let { slowdownMulti } = doEffectStuff(enemy, delta, false);
                let moveSpeed = enemy.speed * (enemy.isFREEZE ? .2 : 1) * slowdownMulti;
                if (!playerRobot.invis && !enemy.blind) {
                    let angle = Math.atan2(playerRobot.y - enemy.y, playerRobot.x - enemy.x);
                    if (enemy.name == "Burner Circle") {
                        if (dist(playerRobot, enemy) <= enemy.range) {
                            if (enemy.lastRate == null) enemy.lastRate = 0;
                            if (Date.now() - enemy.lastRate >= enemy.fireRate) {
                                enemy.lastRate = Date.now();
                                changeHealth(playerRobot, {
                                    amount: -enemy.dmg
                                }, false, enemy);
                            }
                        }
                    } else if (enemy.name == "Reaper Circle") {
                        if (dist(playerRobot, enemy) <= enemy.range) {
                            if (enemy.lastRate == null) enemy.lastRate = 0;
                            if (Date.now() - enemy.lastRate >= enemy.fireRate) {
                                enemy.lastRate = Date.now();
                                projectiles.push({
                                    projType: "normal",
                                    x: enemy.x,
                                    y: enemy.y,
                                    oldX: enemy.x,
                                    oldY: enemy.y,
                                    velx: 0,
                                    vely: 0,
                                    scale: 25,
                                    speed: .4,
                                    dmg: enemy.dmg,
                                    range: enemy.range,
                                    dir: angle,
                                    isAlly: false,
                                    color: "./images/bullets/bullet.png",
                                    owner: enemy,
                                    bypassReflector: true,
                                    defensePointsBypass: 0
                                });
                            }
                        }
                        if (dist(playerRobot, enemy) <= 600) {
                            angle += Math.PI;
                        }
                    } else if (enemy.name == "Homing Circle") {
                        if (dist(playerRobot, enemy) <= enemy.range && !playerRobot.shields.find(e => e.type == "purple")) {
                            if (enemy.lastRate == null) enemy.lastRate = 0;
                            if (Date.now() - enemy.lastRate >= enemy.fireRate) {
                                enemy.lastRate = Date.now();
                                for (let i = 0; i < 7; i++) projectiles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    oldX: enemy.x,
                                    oldY: enemy.y,
                                    projType: "rocket",
                                    velx: 0,
                                    vely: 0,
                                    scale: 25,
                                    speed: 0.1,
                                    dmg: enemy.dmg / 7,
                                    range: enemy.range,
                                    dir: angle + getRandomOffset(7),
                                    isAlly: false,
                                    color: `./images/bullets/rocket.png`,
                                    avoidBuildings: true,
                                    owner: enemy,
                                    defensePointsBypass: .5,
                                    aoeRange: 120,
                                    autoTargetData: {
                                        type: "nearest",
                                        range: 1e3,
                                        better: true
                                    },
                                    changeDirSpeed: 0.045
                                });
                            }
                        }
                        if (dist(playerRobot, enemy) <= 2e3) {
                            angle += Math.PI;
                        }
                    } else if (enemy.name == "Bastion") {
                        if (dist(playerRobot, enemy) <= playerRobot.scale + enemy.scale) {
                            changeHealth(playerRobot, {
                                amount: -enemy.dmg * 200,
                                graydmg: 1
                            }, false, enemy, true);
                            playerRobot.velx += Math.cos(angle) * 7.5;
                            playerRobot.vely += Math.sin(angle) * 7.5;
                            playerRobot.effects.push({
                                name: "suppression",
                                neg: true,
                                power: .8,
                                lastTime: 20e3
                            });
                            playerRobot.effects.push({
                                name: "frag",
                                neg: true,
                                power: 0.05,
                                lastForever: true,
                                lastTime: 1
                            });
                        }
                        if (enemy.lastGiveFrag == null) enemy.lastGiveFrag = Date.now();
                        if (Date.now() - enemy.lastGiveFrag >= 1e3 && dist(playerRobot, enemy) <= 1e3 + playerRobot.scale) {
                            enemy.lastGiveFrag = Date.now();
                            playerRobot.effects.push({
                                name: "frag",
                                neg: true,
                                power: 0.005,
                                lastForever: true,
                                lastTime: 1
                            });
                        }
                        if (enemy.lastHealingTime == null) enemy.lastHealingTime = Date.now();
                        if (Date.now() - enemy.lastHealingTime >= 3e3) {
                            enemy.lastHealingTime = Date.now();
                            changeHealth(enemy, {
                                amount: enemy.maxhealth * .025
                            }, false, enemy);
                        }
                        if (enemy.lastFire == null) enemy.lastFire = 0;
                        if (Date.now() - enemy.lastFire >= 50) {
                            enemy.lastFire = Date.now();
                            let dmg = enemy.dmg;
                            if (enemy.name == "Level 10 Boss") {
                                dmg *= (1 + ((1 - (enemy.health / enemy.maxhealth)) * 2));
                            }
                            projectiles.push({
                                projType: "normal",
                                x: enemy.x,
                                y: enemy.y,
                                oldX: enemy.x,
                                oldY: enemy.y,
                                velx: 0,
                                vely: 0,
                                scale: 20,
                                speed: 0.3,
                                dmg: dmg,
                                aoeRange: (enemy.health / enemy.maxhealth) < .5 ? 120 : 0,
                                range: 3200 + enemy.scale,
                                dir: angle + getRandomOffset(5),
                                color: "./images/bullets/bullet.png",
                                owner: enemy,
                                isAlly: false
                            });
                            let x = 0;
                            let y = 0;
                            for (let i = 0; i < 4; i++) {
                                if (i == 0) {
                                    x = enemy.x + Math.cos(angle + 1.57) * (enemy.scale - 7.5);
                                    y = enemy.y + Math.sin(angle + 1.57) * (enemy.scale - 7.5);
                                } else if (i == 1) {
                                    x = enemy.x + Math.cos(angle + 0.39) * (enemy.scale - 7.5);
                                    y = enemy.y + Math.sin(angle + 0.39) * (enemy.scale - 7.5);
                                } else if (i == 2) {
                                    x = enemy.x + Math.cos(angle - 0.39) * (enemy.scale - 7.5);
                                    y = enemy.y + Math.sin(angle - 0.39) * (enemy.scale - 7.5);
                                } else {
                                    x = enemy.x + Math.cos(angle - 1.57) * (enemy.scale - 7.5);
                                    y = enemy.y + Math.sin(angle - 1.57) * (enemy.scale - 7.5);
                                }
                                let ang = Math.atan2(playerRobot.y - y, playerRobot.x - x);
                                projectiles.push({
                                    projType: "normal",
                                    x: x,
                                    y: y,
                                    oldX: x,
                                    oldY: y,
                                    velx: 0,
                                    vely: 0,
                                    scale: 20,
                                    speed: 0.3,
                                    dmg: dmg,
                                    range: 2e3,
                                    dotEffect: {
                                        name: "dot",
                                        last: 3e3,
                                        dmg: dmg * 0.24,
                                        owner: enemy
                                    },
                                    aoeRange: (enemy.health / enemy.maxhealth) < .5 ? 60 : 0,
                                    dir: ang + getRandomOffset(5),
                                    color: "./images/bullets/bullet.png",
                                    owner: enemy,
                                    isAlly: false
                                });
                            }
                        }
                    } else if (enemy.name == "DoT Circle") {
                        if (dist(playerRobot, enemy) <= enemy.range) {
                            if (enemy.lastRate == null) enemy.lastRate = 0;
                            if (Date.now() - enemy.lastRate >= enemy.fireRate) {
                                enemy.lastRate = Date.now();
                                projectiles.push({
                                    projType: "energy",
                                    x: enemy.x,
                                    y: enemy.y,
                                    oldX: enemy.x,
                                    oldY: enemy.y,
                                    velx: 0,
                                    vely: 0,
                                    scale: 25,
                                    speed: .25,
                                    dotEffect: {
                                        name: "dot",
                                        last: 6e3,
                                        dmg: enemy.dmg,
                                        owner: enemy
                                    },
                                    dmg: enemy.dmg,
                                    range: enemy.range,
                                    dir: angle,
                                    isAlly: false,
                                    color: "./images/bullets/dot_bullet.png",
                                    owner: enemy
                                });
                            }
                        }
                        if (dist(playerRobot, enemy) <= 450) {
                            angle += Math.PI;
                        }
                    } else if (enemy.name == "Anti Healing Circle") {
                        if (dist(playerRobot, enemy) <= enemy.range) {
                            if (enemy.lastRate == null) enemy.lastRate = 0;
                            if (Date.now() - enemy.lastRate >= enemy.fireRate) {
                                enemy.lastRate = Date.now();
                                playerRobot.effects.push({
                                    name: "rust",
                                    power: 0.025,
                                    neg: true,
                                    lastTime: 15e3
                                });
                            }
                        }
                    } else if (enemy.name == "Attacker Circle") {
                        if (dist(playerRobot, enemy) <= enemy.range) {
                            if (enemy.lastRate == null) enemy.lastRate = 0;
                            if (Date.now() - enemy.lastRate >= enemy.fireRate) {
                                enemy.lastRate = Date.now();
                                projectiles.push({
                                    projType: "normal",
                                    x: enemy.x,
                                    y: enemy.y,
                                    oldX: enemy.x,
                                    oldY: enemy.y,
                                    velx: 0,
                                    vely: 0,
                                    scale: 25,
                                    avoidBuildings: true,
                                    speed: .3,
                                    dmg: enemy.dmg,
                                    range: enemy.range,
                                    dir: angle + getRandomOffset(4),
                                    isAlly: false,
                                    color: "./images/bullets/bullet.png",
                                    owner: enemy,
                                    defensePointsBypass: .75,
                                    grayDmg: 1
                                });
                            }
                        }
                        if (dist(playerRobot, enemy) <= 400) {
                            angle += Math.PI;
                        }
                    }
                    enemy.velx += Math.cos(angle) * moveSpeed * delta;
                    enemy.vely += Math.sin(angle) * moveSpeed * delta;
                }
                if (enemy.lockdown) {
                    enemy.velx = 0;
                    enemy.vely = 0;
                }
                if (enemy.x + (enemy.velx * delta) >= enemy.scale && enemy.x + (enemy.velx * delta) <= mapInfo.x - enemy.scale) {
                    enemy.x += (enemy.velx * delta);
                } else {
                    if (enemy.x + (enemy.velx * delta) >= mapInfo.x - enemy.scale) {
                        enemy.x = mapInfo.x - enemy.scale;
                    } else {
                        enemy.x = enemy.scale;
                    }
                }
                if (enemy.y + (enemy.vely * delta) >= enemy.scale && enemy.y + (enemy.vely * delta) <= mapInfo.y - enemy.scale) {
                    enemy.y += (enemy.vely * delta);
                } else {
                    if (enemy.y + (enemy.vely * delta) >= mapInfo.y - enemy.scale) {
                        enemy.y = mapInfo.y - enemy.scale;
                    } else {
                        enemy.y = enemy.scale;
                    }
                }
                if (enemy.velx) enemy.velx *= Math.pow(0.993, delta);
                if (enemy.vely) enemy.vely *= Math.pow(0.993, delta);
                checkIfHitByProj(enemy, false);
                if (enemy.health > (enemy.maxhealth - enemy.grayDamage)) {
                    enemy.health = (enemy.maxhealth - enemy.grayDamage);
                }
                if (enemy.health <= 0 || enemy.kill) {
                    if (enemy.name == "Bastion") {
                        let pos = exterminationEnemies.filter(e => !e.boss);
                        if (pos.length && data.modifiers) {
                            for (let t = 0; t < 50; t++) {
                                let en = new ENEMEMENENMEMMEMEMEMEY(pos[Math.floor(Math.random() * pos.length)], data.modifiers);
                                let rng = Math.random() * (Math.PI * 2);
                                en.x = enemy.x + Math.cos(rng) * Math.randInt(0, 600);
                                en.y = enemy.y + Math.sin(rng) * Math.randInt(0, 600);
                                enemies.push(en);
                            }
                        }

                        enemies.splice(i, 1);
                    } else {
                        enemies.splice(i, 1);
                    }
                }
            }
        }
    }
    function updateBullets(delta) {
        for (let i = 0; i < projectiles.length; i++) {
            let bullet = projectiles[i];
            if (bullet) {
                let asd = bullet.avoidBuildings ? false : buildings.find(e => e.name == "wall rect" && circleSquareCollision(bullet, e, true));
                if (asd || bullet.kill || Math.hypot(bullet.oldY - bullet.y, bullet.oldX - bullet.x) >= bullet.range) {
                    if (bullet.aoeRange && (asd || Math.hypot(bullet.oldY - bullet.y, bullet.oldX - bullet.x) >= bullet.range)) {
                        if (hasPlayers()) {
                            for (let t = 0; t < players.length; t++) {
                                let player = players[t].robots[players[t].robotIndex];
                                if (player && players[t].isAlly != bullet.isAlly) {
                                    if (Math.hypot(bullet.y - player.y, bullet.x - player.x) <= bullet.aoeRange + player.scale) {
                                        changeHealth(player, {
                                            amount: -bullet.dmg,
                                            graydmg: bullet.grayDamageAmount,
                                            defensePointsBypass: bullet.defensePointsBypass,
                                            bypassReflector: bullet.bypassReflector,
                                            motherShipCharge: bullet.motherShipCharge
                                        }, bullet.owner.isMe, bullet.owner);
                                    }
                                }
                            }
                            bombeffect.push({
                                x: bullet.x,
                                y: bullet.y,
                                scale: 0,
                                color: bullet.weaponOwner && bullet.weaponOwner.cold ? "white" : "",
                                maxScale: bullet.aoeRange
                            });
                        } else {
                            let touchedEnemies = enemies.filter(e => Math.hypot(bullet.y - e.y, bullet.x - e.x) <= bullet.aoeRange + e.scale);
                            for (let t = 0; t < touchedEnemies.length; t++) {
                                if (touchedEnemies[i]) {
                                    changeHealth(touchedEnemies[i], {
                                        amount: -bullet.dmg,
                                        graydmg: bullet.grayDamageAmount,
                                        defensePointsBypass: bullet.defensePointsBypass,
                                        bypassReflector: bullet.bypassReflector,
                                        motherShipCharge: bullet.motherShipCharge
                                    }, true, bullet.owner);
                                }
                            }
                            bombeffect.push({
                                x: bullet.x,
                                y: bullet.y,
                                scale: 0,
                                color: bullet.weaponOwner && bullet.weaponOwner.cold ? "white" : "",
                                maxScale: bullet.aoeRange
                            });
                        }
                    }
                    if (bullet.onKillDomain) {
                        domains.push({
                            x: bullet.x,
                            y: bullet.y,
                            scale: 300,
                            increaseSpeedOfPinkishRedAbility: bullet.onKillDomain.increaseSpeedOfPinkishRedAbility,
                            isAlly: bullet.onKillDomain.isAlly,
                            lastingTime: bullet.onKillDomain.last,
                            owner: bullet.owner,
                            name: bullet.onKillDomain.name,
                            dmg: bullet.onKillDomain.dmg
                        });
                    }
                    projectiles.splice(i, 1);
                } else {
                    if (bullet.owner && bullet.owner.effects && bullet.owner.effects.find(e => e.name == "shield break")) {
                        bullet.bypassShields = true;
                    }
                    bullet.velx = Math.cos(bullet.dir) * (bullet.speed * delta);
                    bullet.vely = Math.sin(bullet.dir) * (bullet.speed * delta);
                    if (bullet.freeze) {
                        bullet.velx = bullet.vely = 0;
                        bullet.freeze = false;
                    }
                    bullet.lastX = bullet.x;
                    bullet.lastY = bullet.y;
                    bullet.x += (bullet.velx * delta);
                    bullet.y += (bullet.vely * delta);
                    if (bullet.splitData) {
                        if (dist({ x: bullet.oldX, y: bullet.oldY }, bullet) >= bullet.splitData.range) {
                            for (let t = 0; t < bullet.splitData.amount; t++) {
                                projectiles.push({
                                    x: bullet.x,
                                    y: bullet.y,
                                    oldX: bullet.x,
                                    oldY: bullet.y,
                                    projType: bullet.projType,
                                    velx: 0,
                                    vely: 0,
                                    scale: bullet.scale,
                                    speed: 0.25,
                                    dmg: bullet.dmg / bullet.splitData.amount,
                                    range: bullet.range - bullet.splitData.range,
                                    dir: bullet.dir + getRandomOffset(bullet.splitData.spread),
                                    isAlly: bullet.isAlly,
                                    defensePointsBypass: bullet.defensePointsBypass,
                                    color: "./images/bullets/red_bullet.png",
                                    avoidBuildings: bullet.avoidBuildings,
                                    owner: bullet.owner,
                                    weaponOwner: {
                                        name: bullet.weaponOwner.name,
                                        level: bullet.weaponOwner.level
                                    }
                                });
                            }
                            bullet.kill = true;
                            bullet.dmg = 0;
                        }
                    }
                    if (bullet.targetDir == null) bullet.targetDir = bullet.dir;
                    if (bullet.autoTargetData && !bullet.owner.blind) {
                        if (dist({ x: bullet.oldX, y: bullet.oldY }, bullet) >= bullet.autoTargetData.range || bullet.autoTargetData.canDo) {
                            bullet.autoTargetData.canDo = true;
                            if (bullet.autoTargetData.type == "nearest") {
                                let near = [];
                                if (hasPlayers()) {
                                    for (let t = 0; t < players.length; t++) {
                                        let player = players[t].robots[players[t].robotIndex];
                                        if (player && !player.invis && players[t].isAlly != bullet.isAlly) {
                                            if (Math.hypot(player.y - bullet.owner.y, player.x - bullet.owner.x) <= bullet.range) {
                                                if (bullet.autoTargetData.better) {
                                                    if (player.effects.find(e => e.name == "phase shift")) continue;
                                                    if (player.effects.find(e => e.name == "last stand")) continue;
                                                    if (player.shields.find(e => e.type == "purple")) continue;
                                                    near.push(player);
                                                } else {
                                                    near.push(player);
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (bullet.owner.name == "Homing Circle") {
                                        if (players[0].robots[players[0].robotIndex]) {
                                            near = [players[0].robots[players[0].robotIndex]];
                                        } else {
                                            near = [];
                                        }
                                    } else {
                                        near = enemies.filter(e => Math.hypot(e.y - bullet.owner.y, e.x - bullet.owner.x) <= bullet.range);
                                    }
                                }
                                let nearest = near.sort((a, b) => dist(a, bullet.owner) - dist(b, bullet.owner))[0];
                                if (nearest) {
                                    bullet.targetDir = Math.atan2(nearest.y - bullet.y, nearest.x - bullet.x);
                                }
                            } else if (bullet.autoTargetData.type == "cursor") {
                                if (bullet.dmg == 0) bullet.kill = true;
                                if (bullet.autoTargetData.range && dist({ x: bullet.oldX, y: bullet.oldY }, bullet) < bullet.autoTargetData.range) {
                                } else {
                                    if (bullet.owner.isMe) {
                                        bullet.targetDir = Math.atan2(bullet.owner.cursorLocation.y - bullet.y, bullet.owner.cursorLocation.x - bullet.x);
                                    } else if (bullet.owner.target) {
                                        bullet.targetDir = Math.atan2(bullet.owner.target.y - bullet.y, bullet.owner.target.x - bullet.x);
                                    }
                                }
                            }
                        }
                    }
                    if (bullet.dir != bullet.targetDir) {
                        bullet.dir %= (Math.PI * 2);
                        let netAngle = (bullet.dir - bullet.targetDir + (Math.PI * 2)) % (Math.PI * 2);
                        let amnt = Math.min(Math.abs(netAngle - (Math.PI * 2)), netAngle, (bullet.changeDirSpeed || 1) * delta);
                        let sign = (netAngle - Math.PI) >= 0 ? 1 : -1;
                        if (!isNaN(netAngle)) {
                            bullet.dir += sign * amnt + (Math.PI * 2);
                        }
                    }
                    if ((bullet.owner && bullet.owner.dead) || isNaN(bullet.dir) || isNaN(bullet.x) || isNaN(bullet.y) || isNaN(bullet.velx) || isNaN(bullet.vely)) {
                        bullet.kill = true;
                    }
                }
            }
        }
    }
    function renderEnemies() {
        ctx.globalAlpha = 1;
        for (let i = 0; i < Math.min(enemies.length, 250); i++) {
            let enemy = enemies[i];
            if (enemy) {
                ctx.save();
                ctx.translate(enemy.x - offset.x, enemy.y - offset.y);
                let color = "#808080";
                if (enemy.name == "Burner Circle") {
                    color = "#f00";
                } else if (enemy.name == "Homing Circle") {
                    color = "#000";
                } else if (enemy.name == "DoT Circle") {
                    color = "#0f0";
                } else if (enemy.name == "Anti Healing Circle") {
                    color = "#800080";
                }
                renderCircle(0, 0, enemy.scale, ctx, false, false, color, enemy.lockdown ? "#800080" : enemy.isFREEZE ? "#fff" : "#000", enemy.lockdown ? 15 : undefined);
                if (enemy.effects.find(e => e.name == "track")) {
                    ctx.drawImage(crosshair, -enemy.scale, -enemy.scale, enemy.scale * 2, enemy.scale * 2);
                }
                if (enemy.name == "Anti Healing Circle" || enemy.name == "Burner Circle" || enemy.name == "Bastion") {
                    renderCircle(0, 0, enemy.name == "Bastion" ? 1e3 : enemy.range, ctx, false, true, "#fff", (enemy.name == "Anti Healing Circle" ? "#800080" : "#f00"), 10);
                }
                drawCanvasHealthBars(enemy, false, ctx);
                ctx.restore();
            }
        }
    }
    var bulletImages = {};
    var bulletSprites = {};
    var crosshair = null;
    var crosshairImageLink = "https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Crosshairs_Red.svg/1200px-Crosshairs_Red.svg.png";
    let tmpSprite = new Image();
    tmpSprite.onload = function () {
        this.isLoaded = true;
    };
    tmpSprite.src = crosshairImageLink;
    crosshair = tmpSprite;
    function getBulletSprite(obj) {
        let tmp = bulletSprites[obj.color];
        if (!tmp) {
            tmp = new Image();
            tmp.src = obj.color;
            tmp.onload = function () {
                tmp.isLoaded = true;
            }
            bulletSprites[obj.color] = tmp;
        }
        if (tmp.isLoaded) {
            return tmp;
        }
    }
    function getBulletImage(obj) {
        if (obj.color.includes("rgb")) return;
        let tmp = bulletImages[obj.color + JSON.stringify(obj.shadow)];
        if (!tmp) {
            let image = getBulletSprite(obj);
            if (image) {
                let tmpCanvas = document.createElement("canvas");
                tmpCanvas.width = tmpCanvas.height = (160 * (obj.shadow ? obj.shadow.spriteSize : 1));
                tmpCanvas.style.width = tmpCanvas.style.height = (160 * (obj.shadow ? obj.shadow.spriteSize : 1)) + "px";
                let tmpCtx = tmpCanvas.getContext("2d");
                tmpCtx.globalAlpha = 1;
                tmpCtx.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                if (obj.shadow && settingToggles.renderBulletShadows) {
                    tmpCtx.shadowBlur = obj.shadow.size;
                    tmpCtx.shadowColor = obj.shadow.color;
                }
                let size = (obj.shadow ? obj.shadow.spriteSize * 160 : 160);
                tmpCtx.drawImage(image, -size / 2, -size / 2, size, size);
                bulletImages[obj.color + JSON.stringify(obj.shadow)] = tmp = tmpCanvas;
            }
        }
        return tmp;
    }
    function renderBullets() {
        ctx.globalAlpha = 1;
        for (let i = 0; i < projectiles.length; i++) {
            let bullet = projectiles[i];
            if (bullet && (projectiles.length > 250 ? projectiles.length > 1e3 ? i % 10 == 0 : i % 3 == 0 : true) && isOnScreen(bullet.x - offset.x, bullet.y - offset.y, bullet.scale)) {
                if (!bullet.noInvisWhenOwnerInvis && bullet.owner && bullet.owner.invis) continue;
                ctx.save();
                ctx.translate(bullet.x - offset.x, bullet.y - offset.y);
                let image = getBulletImage(bullet);
                if (image) {
                    ctx.rotate(bullet.dir);
                    let size = bullet.shadow ? 40 * bullet.shadow.spriteSize : 40;
                    ctx.drawImage(image, -size / 2, -size / 2, size, size);
                } else {
                    renderCircle(0, 0, bullet.scale, ctx, false, false, bullet.color.includes("#") || bullet.color.includes("rgb") ? bullet.color : "#808080", "#000", 1);
                }
                ctx.restore();
            }
        }
    }
    var bombeffect = [];
    var gameTimePlayed = 0;
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
        if (width < 2 * radius) radius = width / 2;
        if (height < 2 * radius) radius = height / 2;
        if (radius < 0) radius = 0;
        this.beginPath();
        this.moveTo(x + radius, y);
        this.arcTo(x + width, y, x + width, y + height, radius);
        this.arcTo(x + width, y + height, x, y + height, radius);
        this.arcTo(x, y + height, x, y, radius);
        this.arcTo(x, y, x + width, y, radius);
        this.closePath();
        return this;
    }
    function drawCanvasHealthBars(robot, isAlly, ctx) {
        let playerRobot = players[0].robots[players[0].robotIndex];
        if (!playerRobot) return;
        ctx.globalAlpha = 1;
        if (robot.invis) return;
        if (isAlly != "me") {
            if (robot.dummy) {
                ctx.save();
                ctx.zIndex = 1920139120390123;
                ctx.globalAlpha = 1;
                ctx.textBaseline = "middle";
                ctx.textAlign = "center";
                let text = `${robot.dps || 0} | ${robot.dpsh || 0} | ${robot.dpm || 0}`
                ctx.fillStyle = "#fff";
                ctx.font = `${Math.min(50, robot.scale * (1 / 3))}px Open Sans`;
                ctx.fillText(text, 0, 0);
                ctx.restore();
            }
            let width = (robot.scale + 20);
            let padding = 4.5;
            let x = -(width + padding);
            let y = (robot.scale * 1.5);
            ctx.fillStyle = "#000";
            ctx.roundRect(x, y, (width * 2) + (padding * 2), 20.4, 8);
            ctx.fill();
            ctx.fillStyle = "#808080";
            ctx.roundRect((x + padding) + (width * 2 * (1 - (robot.grayDamage / robot.maxhealth))), y + padding, (width * 2) * (robot.grayDamage / robot.maxhealth), (20.4 - (padding * 2)), 8);
            ctx.fill();
            ctx.fillStyle = isAlly == true ? "#0f0" : "#f00";
            ctx.roundRect(x + padding, y + padding, (width * 2) * (robot.health / robot.maxhealth), (20.4 - (padding * 2)), 8);
            ctx.fill();
            ctx.fillStyle = "#ffff00";
            ctx.roundRect((x + padding) + ((width * 2) * (robot.health / robot.maxhealth)) - ((width * 2) * (Math.min(robot.dotDamage, robot.health) / robot.maxhealth)), y + padding, (width * 2) * (Math.min(robot.dotDamage, robot.health) / robot.maxhealth), (20.4 - (padding * 2)), 8);
            ctx.fill();
            if (robot.lastStandThreshold) {
                let invis = "rgb(0, 0, 0, 0)";
                let color = "rgb(0, 0, 0, 0.4)";
                let effect = robot.effects.find(e => e.name == "last stand");
                ctx.fillStyle = effect ? effect.LOLOL ? color : invis : robot.usedLastStand ? invis : color;
                ctx.roundRect(x + padding, y + padding, (width * 2) * ((robot.lastStandThreshold * robot.maxhealth) / robot.maxhealth), (20.4 - (padding * 2)), 8);
                ctx.fill();
            }
        }
        if (robot.effects.filter(e => e.name == "block").length) {
            ctx.save();
            ctx.zIndex = 1920139120390123;
            ctx.globalAlpha = 1;
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            let colors = ["#ffff00", "#fff", "#ffffff"];
            ctx.fillStyle = (colors.includes(robot.color) ? "#000" : "#fff");
            ctx.strokeStyle = "#f00";
            ctx.lineWidth = 10;
            ctx.font = `${Math.min(50, robot.scale * (1 / 2))}px Open Sans`;
            ctx.strokeText(robot.effects.filter(e => e.name == "block").length, 0, 0);
            ctx.fillText(robot.effects.filter(e => e.name == "block").length, 0, 0);
            ctx.restore();
        }
        if (isAlly != "me") {
            if (robot.shields && robot.shields.length) {
                let shieldss = robot.shields.filter(e => e.health || e.type == "purple");
                shieldss = shieldss.filter(e => e.type != "normal");
                for (let i = 0; i < 5; i++) {
                    let shield = shieldss[i];
                    let width = (robot.scale + 20);
                    let padding = 4.5;
                    let x = -(width + padding);
                    let y = (robot.scale * 1.5) + (26.4 + (26.4 * i));
                    if (shield) {
                        ctx.save();
                        ctx.globalAlpha = shield.notActive ? .4 : 1;
                        ctx.fillStyle = "#000";
                        ctx.roundRect(x, y, (width * 2) + (padding * 2), 20.4, 8);
                        ctx.fill();
                        ctx.fillStyle = shield.type == "yellow" ? "#ffff00" : ((shield.type == "purple normal" || shield.type == "purple") ? "#800080" : "#02ccaa");
                        ctx.roundRect(x + padding, y + padding, (width * 2) * (shield.type == "purple normal" ? Math.min(1, shield.health / shield.limit) : shield.type == "purple" ? 1 : (shield.health / shield.maxhealth)), (20.4 - (padding * 2)), 8);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }
        }
    }
    function renderPlayers(delta) {
        for (let i = 1; i < players.length; i++) {
            let player = players[i];
            if (player.robotIndex >= 0) {
                let robot = player.robots[player.robotIndex];
                if (robot && (robot.bonds && robot.bonds.length ? true : isOnScreen(robot.x - offset.x, robot.y - offset.y, robot.scale))) {
                    ctx.save();
                    ctx.translate(robot.x - offset.x, robot.y - offset.y);
                    if (!robot.invis && !robot.effects.find(e => e.name == "phase shift")) {
                        ctx.globalAlpha = 1;
                        ctx.fillStyle = players[i].isAlly == true ? "#00f" : "#f00";
                        ctx.font = "34px Open Sans";
                        ctx.textBaseline = "middle";
                        ctx.textAlign = "center";
                        ctx.fillText(players[i].name, 0, -(robot.scale + 20));
                    }
                    renderPhysicalShields(robot, delta, ctx);
                    if (robot.globalAlpha == null) robot.globalAlpha = 1;
                    if (robot.invis) {
                        robot.globalAlpha = Math.max(robot.globalAlpha - (delta * 0.005), 0.025);
                    } else if (robot.effects.find(e => e.name == "phase shift")) {
                        robot.globalAlpha = Math.max(robot.globalAlpha - (delta * 0.0025), 0.4);
                    } else {
                        robot.globalAlpha = Math.min(robot.globalAlpha + (delta * 0.0025), 1);
                    }
                    ctx.globalAlpha = robot.globalAlpha;
                    if (robot.specialOf) {
                        let image = getShapeImage(robot);
                        if (image.isLoaded) {
                            let size = 250;
                            ctx.rotate(robot.dir + Math.PI);
                            ctx.drawImage(image, -(size / 2), -(size / 2), size, size);
                            ctx.rotate(-(robot.dir + Math.PI));
                        }
                    } else {
                        renderShapeBody(ctx, robot);
                    }
                    renderDrone(ctx, robot, robot.drones, delta);
                    if (robot.bonds) {
                        if (!robot.invis) ctx.globalAlpha = 1;
                        for (let i = 0; i < robot.bonds.length; i++) {
                            let bond = robot.bonds[i];
                            if (bond) {
                                ctx.save();
                                ctx.translate(-(robot.x - offset.x), -(robot.y - offset.y));
                                ctx.lineWidth = bond.name == "Active Support" ? 16 : 32;
                                ctx.strokeStyle = bond.name == "Active Support" ? "rgb(1, 50, 32, .6)" : bond.isAlly ? "rgb(255, 0, 255, .6)" : "rgb(255, 0, 0, .6)";
                                ctx.lineCap = "round";
                                ctx.beginPath();
                                ctx.moveTo(robot.x - offset.x, robot.y - offset.y);
                                ctx.lineTo(bond.target.x - offset.x, bond.target.y - offset.y);
                                ctx.stroke();
                                ctx.restore();
                                doBondStuff(bond, delta, i, robot);
                            }
                        }
                    }
                    if (robot.effects.find(e => e.name == "track")) {
                        ctx.drawImage(crosshair, -robot.scale, -robot.scale, robot.scale * 2, robot.scale * 2);
                    }
                    drawCanvasHealthBars(robot, player.isAlly, ctx);
                    ctx.restore();
                    let drone = robot.drones[0];
                    if (drone && drone.abilities.find(e => e.name == "Imitating Comet Laser")) {
                        let weapon = drone.abilities.find(e => e.name == "Imitating Comet Laser");
                        if (weapon.droneIsFiring) {
                            let color1 = "rgb(255, 165, 0)";
                            let tmp = drone.visualData.addOnCoord;
                            ctx.save();
                            ctx.lineWidth = 16;
                            ctx.strokeStyle = color1;
                            ctx.beginPath();
                            ctx.moveTo((robot.x + tmp.x) - offset.x, (robot.y + tmp.y) - offset.y);
                            ctx.lineTo(weapon.target.x - offset.x, weapon.target.y - offset.y);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                }
            }
        }
    }
    function drawTracer(_, sid, isAlly) {
        let player = players[0].robots[players[0].robotIndex];
        if (player && !_.invis) {
            if (!document.getElementById("enemyradar" + sid)) {
                let newE = document.createElement("div");
                newE.id = `enemyradar${sid}`;
                newE.style = `
                display: none;
                position: absolute;
                left: 0;
                top: 0;
                color: ${isAlly == true ? "#00f" : "#f00"};
                width: 0;
                height: 0;
                border: solid;
                border-color: transparent transparent transparent ${isAlly == true ? "#00f" : "#f00"};
                `;
                document.body.appendChild(newE);
            }
            let center_x = window.innerWidth / 2, center_y = window.innerHeight / 2;
            let rad = Math.atan2(_.y - player.y, _.x - player.x), alpha = Math.sqrt(Math.pow(0 - (player.x - _.x), 2) + Math.pow(0 - (player.y - _.y) * (16 / 9), 2)) * 100 / (maxScreen.y / 2) / center_y;
            if (alpha > 1.0) alpha = 1.0;
            let tx = center_x + (center_y * alpha) * Math.cos(rad) - 20 / 2, ty = center_y + (center_y * alpha) * Math.sin(rad) - 20 / 2;
            document.getElementById("enemyradar" + sid).style.borderWidth = "10px 0px 10px 20px";
            document.getElementById("enemyradar" + sid).style.pointerEvents = "none";
            document.getElementById("enemyradar" + sid).style.left = Math.max(20, Math.min(tx, window.innerWidth - 20)) + "px";
            document.getElementById("enemyradar" + sid).style.top = Math.max(20, Math.min(ty, window.innerHeight - 20)) + "px";
            document.getElementById("enemyradar" + sid).style.opacity = alpha;
            document.getElementById("enemyradar" + sid).style.transform = `rotate(${((rad * 180) / Math.PI)}deg)`;
            document.getElementById("enemyradar" + sid).style.display = "block";
        }
    }
    function doCollRectMovement(target, robot) {
        if (robot.avoidBuildings) return null;
        for (let i = 0; i < buildings.length; i++) {
            let obj = buildings[i];
            if (obj.name == "coll rect") {
                if (circleSquareCollision(robot, obj)) {
                    if (obj.middleX) {
                        let y = obj.y + obj.height;
                        if ((target.y <= obj.y && robot.y >= obj.y) || (target.y >= y && robot.y <= y)) {
                            if (obj.onlyDir != null) return obj.onlyDir;
                            if (target.x > obj.middleX) {
                                return 0;
                            } else {
                                return Math.PI;
                            }
                        }
                    } else {
                        let x = obj.x + obj.width;
                        if ((target.x >= obj.x && obj.x >= robot.x) || (target.x <= x && robot.x >= x)) {
                            if (obj.onlyDir != null) return obj.onlyDir;
                            if (target.y > obj.middleY) {
                                return Math.PI / 2;
                            } else {
                                return -Math.PI / 2;
                            }
                        }
                    }
                }
            }
        }
        return null;
    }
    function doMoveStuff(robot, isAlly) {
        let beacons = buildings.filter(e => e.name == "beacon");
        let nearestBeaconToGo = null;
        if (beacons.length) {
            beacons = beacons.sort((a, b) => dist(a, robot) - dist(b, robot));
            nearestBeaconToGo = beacons.find(e => isAlly ? e.ALLYPOINTS < 5e3 : e.ENEMYPOINTS < 5e3);
        }
        let enemies = [];
        let allies = [];
        let robots = [];
        let nearestEnemy = null;
        for (let i = 0; i < players.length; i++) {
            if (players[i].robots[players[i].robotIndex]) {
                let Robot = players[i].robots[players[i].robotIndex];
                if (players[i].isAlly != isAlly) {
                    enemies.push(Robot);
                } else if (Robot != robot && player.gameMode == 2) {
                    allies.push(Robot);
                }
            }
        }
        if (enemies.length) {
            enemies = enemies.sort((a, b) => dist(a, robot) - dist(b, robot));
            nearestEnemy = enemies[0];
            let allyBeacons = beacons.filter(e => isAlly ? e.ALLYPOINTS >= 5e3 : e.ENEMYPOINTS >= 5e3);
            let bData = [];
            for (let i = 0; i < allyBeacons.length; i++) {
                let beacon = allyBeacons[i];
                if (beacon) {
                    let tmp = {
                        enemiesNear: 0,
                        alliesNear: 0,
                        x: beacon.x,
                        y: beacon.y
                    };
                    for (let i = 0; i < enemies.length; i++) {
                        let enemy = enemies[i];
                        if (enemy) {
                            if (dist(enemy, beacon) <= 500 + enemy.scale * 2) {
                                tmp.enemiesNear++;
                            }
                        }
                    }
                    for (let i = 0; i < allies.length; i++) {
                        let ally = allies[i];
                        if (ally) {
                            if (dist(ally, beacon) <= 500 + ally.scale * 2) {
                                tmp.alliesNear++;
                            }
                        }
                    }
                    bData.push(tmp);
                }
            }
            let closestBData = bData.filter(e => e.alliesNear < e.enemiesNear && e.enemiesNear > 0 && e.alliesNear < 2).sort((a, b) => dist(a, robot) - dist(b, robot))[0];
            if (closestBData && nearestBeaconToGo) {
                if (dist(nearestBeaconToGo, robot) > dist(closestBData, robot)) {
                    nearestBeaconToGo = closestBData;
                }
            }
        }
        let target = null;
        if (player.gameMode == 4) {
            if (nearestEnemy && dist(nearestEnemy, robot) >= robot.scale * 3) {
                target = nearestEnemy;
            }
        } else if (player.gameMode == 9 || player.gameMode == 2 || player.gameMode == 7) {
            if (nearestBeaconToGo && dist(nearestBeaconToGo, robot) >= 400 - (robot.scale * 2)) {
                target = nearestBeaconToGo;
            } else if (nearestEnemy && dist(nearestEnemy, robot) >= robot.scale * 3) {
                target = nearestEnemy;
            }
        }
        if (player.gameMode == 2 && ["Ultimate Green Circle", "Green Triangle"].includes(robot.name)) {
            let theThing = null;
            for (let i = 0; i < allies.length; i++) {
                let ally = allies[i];
                if (ally) {
                    if (nearestBeaconToGo && dist(nearestBeaconToGo, robot) > dist(ally, robot)) {
                        theThing = ally;
                    } else if (!nearestBeaconToGo && nearestEnemy && dist(nearestEnemy, robot) > dist(ally, robot)) {
                        theThing = ally;
                    }
                }
            }
            if (robot.name == "Ultimate Green Circle") {
                if (theThing && theThing.health < .8 * theThing.maxhealth) {
                    target = theThing;
                }
            } else {
                if (theThing && theThing.health < .95 * (theThing.maxhealth - theThing.grayDamage)) {
                    target = theThing;
                }
            }
        }
        robot.movementTarget = target;
        if (domains.find(e => e.name == "healfield" && dist(e, robot) <= e.scale + robot.scale && e.isAlly == isAlly)) {
            return null;
        }
        if (target) {
            let extra = doCollRectMovement(target, robot);
            if (extra != null && extra != undefined) return extra;
            return Math.atan2(target.y - robot.y, target.x - robot.x);
        } else {
            return null;
        }
    }
    function PLAYERKNOCKBACK(robot, isAlly) {
        for (let i = 0; i < players.length; i++) {
            let ROBOT = players[i].robots[players[i].robotIndex];
            if (ROBOT && (ROBOT.name == "Polygon" ? true : robot.avoidBuildings == ROBOT.avoidBuildings)) {
                let distance = Math.hypot(ROBOT.y - robot.y, ROBOT.x - robot.x);
                if (distance <= (robot.scale + ROBOT.scale) * .75) {
                    let angle = Math.atan2(ROBOT.y - robot.y, ROBOT.x - robot.x) + Math.PI;
                    let tmpInt = distance - (robot.scale + ROBOT.scale) * .75;
                    tmpInt = (tmpInt * -1) / 2;
                    if (!robot.effects.find(e => e.name == "Ultimate Reflecting Dash")) {
                        robot.x += (tmpInt * Math.cos(angle));
                        robot.y += (tmpInt * Math.sin(angle));
                        if (ROBOT.name == "Polygon") {
                            let angle = Math.atan2(robot.y - ROBOT.y, robot.x - ROBOT.x);
                            robot.velx += Math.cos(angle) * 5;
                            robot.vely += Math.sin(angle) * 5;
                            changeHealth(robot, {
                                amount: -200e3
                            }, true, ROBOT);
                        }
                    }
                    if (!ROBOT.effects.find(e => e.name == "Ultimate Reflecting Dash")) {
                        ROBOT.x -= (tmpInt * Math.cos(angle));
                        ROBOT.y -= (tmpInt * Math.sin(angle));
                    }
                    if (player) {
                        robot.velx *= 0.9;
                        robot.vely *= 0.9;
                    }
                }
            }
        }
    }
    function updatePlayers(delta, isBlind) {
        for (let i = 1; i < players.length; i++) {
            let robot = players[i].robots[players[i].robotIndex];
            if (robot) {
                PLAYERKNOCKBACK(robot, players[i].isAlly);
                if (!isBlind) drawTracer(robot, i, players[i].isAlly);
                updateRobot(robot, players[i].isAlly, delta, i);
            } else {
                if (document.getElementById("enemyradar" + i)) {
                    document.getElementById("enemyradar" + i).style.display = "none";
                }
            }
        }
    }
    function clamp(value, min, max) {
        return Math.max(min, Math.min(value, max));
    }
    function circleSquareCollision(circle, rect, t) {
        if (circle.effects && circle.effects.find(e => e.name == "phase shift")) {
            return false;
        }
        const closestX = clamp(circle.x, rect.x, rect.x + rect.width);
        const closestY = clamp(circle.y, rect.y, rect.y + rect.height);
        const distanceX = circle.x - closestX;
        const distanceY = circle.y - closestY;
        const distanceSquared = distanceX ** 2 + distanceY ** 2;
        if (distanceSquared <= circle.scale ** 2) {
            return true;
        } else {
            if (circle.x >= rect.x && circle.x <= rect.x + rect.width) {
                if (circle.y >= rect.y && circle.y <= rect.y + rect.height) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
    }
    function isOnScreen(x, y, s) {
        return (x + s >= 0 && x - s <= maxScreen.x && y + s >= 0 && y - s <= maxScreen.y);
    }
    function doCapturedBeaconStuff(obj, isAlly) {
        for (let i = 0; i < players.length; i++) {
            let player = players[i].robots[players[i].robotIndex];
            if (player && players[i].isAlly == isAlly) {
                if (dist(obj, player) <= 400) {
                    if (player.battleStats == null) player.battleStats = {};
                    if (player.battleStats.beacons == null) player.battleStats.beacons = 0;
                    player.battleStats.beacons++;
                    let Player = players[player.playersIndexSid];
                    Player.titanCharge += .07;
                    if (Player && Player.mothership && Player.mothership.data) {
                        Player.mothership.current += .185 * (1 + Player.mothership.data.chargeSpeed);
                        if (Player.mothership.current > 1) Player.mothership.current = 1;
                    }
                    if (player.drones.length) {
                        for (let k = 0; k < player.drones.length; k++) {
                            for (let t = 0; t < player.drones[k].abilities.length; t++) {
                                let data = player.drones[k].abilities[t];
                                if (data) {
                                    if (data.name == "On Beacon Capture: Defense") {
                                        if (!player.effects.find(e => e.name == "cooldown_timer" && e.reason == data.name)) {
                                            player.effects.push({
                                                name: "defense points",
                                                lastForever: true,
                                                amount: data.defenseIncrease,
                                                lastTime: 1
                                            });
                                            player.effects.push({
                                                name: "cooldown_timer",
                                                reason: data.name,
                                                lastTime: data.reload
                                            });
                                            player.drones[0].effects.push({
                                                name: "speed",
                                                amount: 1,
                                                lastTime: 5e3
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    function updateBuildingObj(obj, delta) {
        if (obj.name == "beacon" && !obj.isHAVEON) {
            if (obj.ALLYPOINTS < 5e3) obj.ALLYPOINTS = Math.max(obj.ALLYPOINTS - delta * .25, 0);
            if (obj.ENEMYPOINTS < 5e3) obj.ENEMYPOINTS = Math.max(obj.ENEMYPOINTS - delta * .25, 0);
        }
        if (obj.name == "beacon") {
            if (obj.LASTLAST == null) obj.LASTLAST = 0;
            if (obj.ENEMYPOINTS <= delta * 10 && obj.ALLYPOINTS <= delta * 10) {
                obj.captureStatus = "white";
            }
            if (Date.now() - obj.LASTLAST >= (player.mapID == 1 ? 87.5 : 175)) {
                obj.LASTLAST = Date.now();
                if (obj.ENEMYPOINTS >= 5e3) {
                    if (obj.LASTENEMYPOINTS < 5e3 && obj.captureStatus != "enemy") {
                        obj.captureStatus = "enemy";
                        doCapturedBeaconStuff(obj, false);
                    }
                    beaconPoints.enemy = Math.min(beaconPoints.enemy + 1, 3500);
                }
                obj.LASTENEMYPOINTS = obj.ENEMYPOINTS;
                if (obj.ALLYPOINTS >= 5e3) {
                    if (obj.LASTALLYPOINTS < 5e3 && obj.captureStatus != "ally") {
                        obj.captureStatus = "ally";
                        doCapturedBeaconStuff(obj, true);
                    }
                    beaconPoints.ally = Math.min(beaconPoints.ally + 1, 3500);
                }
                obj.LASTALLYPOINTS = obj.ALLYPOINTS;
            }
        }
        obj.isHAVEON = false;
        if (obj.name == "beacon") {
            BEACONS.push(obj);
        }
        if (!obj.name.includes("col")) {
            ACTUALBUILDINGSTOTOUCH.push(obj);
        }
        if (obj.name == "Remote Repair" || obj.name.includes("Blink Turret") || obj.name == "Blink Assault" || obj.name == "Remote Assault") {
            let nearestEnemies = [];
            if (obj.name == "Remote Repair") {
                nearestEnemies = getNearest(obj, obj.range, obj.isAlly, true);
            } else if (hasPlayers()) {
                for (let t = 0; t < players.length; t++) {
                    let Robot = players[t].robots[players[t].robotIndex];
                    if (Robot && obj.isAlly != players[t].isAlly) {
                        if (!Robot.invis && Math.hypot(obj.y - Robot.y, obj.x - Robot.x) <= obj.range + obj.scale) {
                            if (obj.name == "Blink Assault" && Robot.shields.find(e => e.type == "purple")) {
                                continue;
                            }
                            nearestEnemies.push(Robot);
                        }
                    }
                }
            } else {
                nearestEnemies = enemies.filter(e => Math.hypot(e.y - obj.y, e.x - obj.x) <= obj.range + e.scale)
            }
            if (obj.name != "Remote Repair") nearestEnemies = nearestEnemies.sort((a, b) => dist(a, obj) - dist(b, obj))[0];
            obj.duration -= delta;
            if (obj.name == "Remote Repair" && nearestEnemies.length) {
                if (obj.lastFire == null) obj.lastFire = 0;
                if (Date.now() - obj.lastFire >= obj.rate) {
                    obj.lastFire = Date.now();
                    nearestEnemies.forEach(e => {
                        e.grayDamage = Math.max(e.grayDamage - (obj.healing * .15), 0);
                        changeHealth(e, {
                            amount: obj.healing
                        }, false, obj.owner);
                    });
                }
            } else if (nearestEnemies) {
                if (obj.lastFire == null) obj.lastFire = 0;
                if (obj.name == "Remote Assault") {
                    if (!obj.owner.effects.find(e => e.abilityEffect == obj.name)) {
                        obj.kill = true;
                    }
                    if (Date.now() - obj.lastFire >= obj.rate) {
                        obj.lastFire = Date.now();
                        let dir = Math.atan2(nearestEnemies.y - obj.y, nearestEnemies.x - obj.x);
                        projectiles.push({
                            noInvisWhenOwnerInvis: true,
                            x: obj.x,
                            y: obj.y,
                            oldX: obj.x,
                            oldY: obj.y,
                            projType: "rocket",
                            velx: 0,
                            vely: 0,
                            scale: 20,
                            speed: 0.15,
                            aoeRange: 120,
                            dmg: obj.dmg,
                            range: obj.range,
                            dir: dir,
                            isAlly: obj.isAlly,
                            color: "./images/bullets/rocket.png",
                            slowEffect: {
                                name: "slowdown",
                                power: .05,
                                last: 5e3
                            },
                            owner: obj.owner,
                            weaponOwner: {
                                name: obj.name,
                                level: obj.owner.level
                            }
                        });
                    }
                } else if (obj.name == "Blink Turret T1" || obj.name == "Blink Assault") {
                    if (Date.now() - obj.lastFire >= obj.rate) {
                        obj.lastFire = Date.now();
                        let dir = Math.atan2(nearestEnemies.y - obj.y, nearestEnemies.x - obj.x);
                        projectiles.push({
                            noInvisWhenOwnerInvis: true,
                            x: obj.x + Math.cos(dir + Math.PI / 2) * obj.scale,
                            y: obj.y + Math.sin(dir + Math.PI / 2) * obj.scale,
                            oldX: obj.x + Math.sin(dir + Math.PI / 2) * obj.scale,
                            oldY: obj.y + Math.sin(dir + Math.PI / 2) * obj.scale,
                            projType: "normal",
                            velx: 0,
                            vely: 0,
                            scale: 20,
                            speed: 0.25,
                            dmg: obj.dmg,
                            range: obj.range,
                            dir: dir,
                            isAlly: obj.isAlly,
                            color: "./images/bullets/bullet.png",
                            owner: obj.owner,
                            slowEffect: obj.name == "Blink Assault" ? {
                                name: "slowdown",
                                power: .0075,
                                last: 3e3
                            } : undefined,
                            weaponOwner: {
                                name: obj.name,
                                level: obj.owner.level
                            }
                        });
                        projectiles.push({
                            noInvisWhenOwnerInvis: true,
                            x: obj.x + Math.cos(dir - Math.PI / 2) * obj.scale,
                            y: obj.y + Math.sin(dir - Math.PI / 2) * obj.scale,
                            oldX: obj.x + Math.sin(dir - Math.PI / 2) * obj.scale,
                            oldY: obj.y + Math.sin(dir - Math.PI / 2) * obj.scale,
                            projType: "normal",
                            velx: 0,
                            vely: 0,
                            scale: 20,
                            speed: 0.25,
                            dmg: obj.dmg,
                            range: obj.range,
                            dir: dir,
                            isAlly: obj.isAlly,
                            color: "./images/bullets/bullet.png",
                            owner: obj.owner,
                            slowEffect: obj.name == "Blink Assault" ? {
                                name: "slowdown",
                                power: .0075,
                                last: 3e3
                            } : undefined,
                            weaponOwner: {
                                name: obj.name,
                                level: obj.owner.level
                            }
                        });
                    }
                } else {
                    if (Date.now() - obj.lastFire >= obj.rate) {
                        obj.lastFire = Date.now();
                        let dir = Math.atan2(nearestEnemies.y - obj.y, nearestEnemies.x - obj.x);
                        projectiles.push({
                            noInvisWhenOwnerInvis: true,
                            x: obj.x,
                            y: obj.y,
                            oldX: obj.x,
                            oldY: obj.y,
                            projType: "energy",
                            velx: 0,
                            vely: 0,
                            scale: 20,
                            speed: 0.25,
                            dmg: obj.dmg,
                            range: obj.range,
                            dir: dir,
                            isAlly: obj.isAlly,
                            color: "./images/bullets/energy_bullet.png",
                            slowEffect: {
                                name: "slowdown",
                                power: .025,
                                last: 10e3
                            },
                            dotEffect: {
                                name: "dot",
                                dmg: obj.dmg * 10,
                                last: 10e3
                            },
                            blastEffect: {
                                name: "blast",
                                power: .15,
                                last: 10e3
                            },
                            owner: obj.owner,
                            weaponOwner: {
                                name: obj.name,
                                level: obj.owner.level
                            }
                        });
                    }
                }
            }
            if (obj.duration <= 0) {
                obj.kill = true;
            }
        }
    }
    var BEACONS = [];
    var ACTUALBUILDINGSTOTOUCH = [];
    function renderBuildings(delta, asd) {
        BEACONS = [];
        ACTUALBUILDINGSTOTOUCH = [];
        ctx.globalAlpha = 1;
        for (let i = 0; i < buildings.length; i++) {
            let obj = buildings[i];
            if (obj && obj.name != "coll rect") {
                ctx.save();
                ctx.translate(obj.x - offset.x, obj.y - offset.y);
                if (obj.name == "beacon") {
                    if (obj.ALLYPOINTS == null) obj.ALLYPOINTS = 0;
                    if (obj.ENEMYPOINTS == null) obj.ENEMYPOINTS = 0;
                    let color = obj.ENEMYPOINTS >= 5000 ? "#f00" : obj.ALLYPOINTS >= 5000 ? "#00f" : "#fff";
                    renderCircle(0, 0, 35, ctx, false, false, "#808080", "#000");
                    renderCircle(0, 0, 20, ctx, true, false, color, "#000");
                    let color2 = obj.ENEMYPOINTS >= 5000 ? "rgb(255, 0, 0" : obj.ALLYPOINTS >= 5000 ? "rgb(0, 0, 255" : "rgb(255, 255, 255";
                    renderCircle(0, 0, 400, ctx, false, true, null, color2 + ", 0.55)", 14);
                    ctx.lineWidth = 14;
                    let multi = 1;
                    if (obj.ENEMYPOINTS > obj.ALLYPOINTS) {
                        color2 = "rgb(255, 0, 0";
                        multi = (obj.ENEMYPOINTS / 5e3);
                    } else {
                        color2 = "rgb(0, 0, 255";
                        multi = (obj.ALLYPOINTS / 5e3);
                    }
                    ctx.strokeStyle = color2 + ", 0.55)";
                    ctx.beginPath();
                    ctx.arc(0, 0, 400, 0, (Math.PI * 2) * multi);
                    ctx.stroke();
                    ctx.translate(0, 35);
                    ctx.fillStyle = color;
                    renderStar(ctx, 1.5, 15, 15);
                    ctx.fill();
                    ctx.translate(0, -70);
                    ctx.rotate(Math.PI)
                    ctx.fillStyle = color;
                    renderStar(ctx, 1.5, 15, 15);
                    ctx.fill();
                    ctx.save();
                    ctx.translate(35, -35);
                    ctx.rotate(-Math.PI + 1.57);
                    ctx.fillStyle = color;
                    renderStar(ctx, 1.5, 15, 15);
                    ctx.fill();
                    ctx.restore();
                    ctx.save();
                    ctx.translate(-35, -35);
                    ctx.rotate(-Math.PI - 1.57);
                    ctx.fillStyle = color;
                    renderStar(ctx, 1.5, 15, 15);
                    ctx.fill();
                    ctx.restore();
                } else if (obj.name == "wall rect") {
                    ctx.fillStyle = "#808080";
                    ctx.fillRect(0, 0, obj.width, obj.height);
                    ctx.fillStyle = "#969595";
                    ctx.fillRect(20, 20, obj.width - 40, obj.height - 40);
                } else if (obj.name == "Remote Repair" || obj.name.includes("Blink Turret") || obj.name == "Blink Assault" || obj.name == "Remote Assault") {
                    if (obj.globalAlpha == null) obj.globalAlpha = 0;
                    obj.globalAlpha += 0.003 * delta;
                    if (obj.globalAlpha > 1) obj.globalAlpha = 1;
                    ctx.globalAlpha = obj.globalAlpha;
                    let color = obj.name == "Remote Repair" ? "#0f0" : obj.name == "Blink Assault" ? "#cc8400" : obj.name == "Remote Assault" ? "#964b00" : obj.name == "Blink Turret T2" ? "#00ffff" : "#00f";
                    renderCircle(0, 0, obj.scale, ctx, false, false, color, obj.isAlly ? "#000" : "#f00");
                    if (obj.name == "Remote Repair") {
                        renderCircle(0, 0, obj.range, ctx, false, true, "#fff", obj.isAlly ? "#018f01" : "#f00", 20);
                    }
                } else if (obj.name == "border rect") {
                    ctx.globalAlpha = obj.opacity || .18;
                    ctx.fillStyle = "#000";
                    ctx.fillRect(0, 0, obj.width, obj.height);
                } else if (obj.name == "rect") {
                    ctx.fillStyle = obj.color;
                    ctx.fillRect(0, 0, obj.width, obj.height);
                } else if (obj.name == "pond" && asd) {
                    if (obj.tmpScale == null) obj.tmpScale = obj.scale;
                    if (obj.tmpAdjust == null) obj.tmpAdjust = 1;
                    let speed = 0.015;
                    if (obj.tmpAdjust == 1) {
                        if (obj.tmpScale < obj.scale * 1.05) {
                            obj.tmpScale = Math.min(obj.scale * 1.05, obj.tmpScale + (speed * delta));
                        } else {
                            obj.tmpAdjust = -1;
                        }
                    } else {
                        if (obj.tmpScale > obj.scale) {
                            obj.tmpScale = Math.max(obj.scale, obj.tmpScale - (speed * delta));
                        } else {
                            obj.tmpAdjust = 1;
                        }
                    }
                    renderCircle(0, 0, obj.scale * 1.15, ctx, true, false, "#ffff00");
                    renderCircle(0, 0, obj.tmpScale, ctx, true, false, "#1ca3ec");
                } else if (obj.name == "coll rect") {
                    ctx.fillStyle = obj.onlyDir != null ? "#000" : obj.onlyDir != undefined ? "#000" : "#1ca3ec";
                    ctx.fillRect(0, 0, obj.width, obj.height);
                } else if (obj.name == "hill") {
                    renderCircle(0, 0, obj.scale, ctx, true, false, "#236b43");
                } else if (obj.name == "water" && asd) {
                    ctx.fillStyle = "#1ca3ec";
                    ctx.fillRect(0, 0, obj.width, obj.height);
                }
                ctx.restore();
            }
            if (obj && !asd) updateBuildingObj(obj, delta);
            if (obj.kill) buildings.splice(i, 1);
        }
    }
    var LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    function renderGameDataThing() {
        let value = (gameTimePlayed / 1000) / 60;
        let data = player.exterminationData;
        if (data && data.timeLimit <= gameTimePlayed) {
            endGame(players, false);
            return;
        }
        value = value.toString().split(".");
        let minutes = value[0];
        let seconds = parseFloat("0." + value[1]) * 60;
        let text = "";
        if (gameTimePlayed <= 59999) {
            text = `0:${gameTimePlayed <= 10e3 ? "0" : ""}${removeDecimals(gameTimePlayed / 1000)}`;
        } else {
            text = `${minutes}:${seconds <= 10 ? "0" : ""}${removeDecimals(seconds)}`;
        }
        let beaconIndexx = 0;
        let maxwidth = BEACONS.length * 30 - 5;
        document.getElementById("gameDataThing").innerHTML = `
        <div style="position: absolute; top: 0px; color: ${player.mapID == 1 ? "#fff" : "#000"}; font-size: 18px; text-align: center; left: 0px; width: 100%;">
        ${text}
        </div>
        <div style="display: ${BEACONS.length ? player.gameMode == 0 ? "none" : "block" : "none"}; position: absolute; height: 25px; left: ${(window.innerWidth / 2) - ((maxwidth * 1.5) - 10)}px; top: 25px; width: 125px; border-radius: 2px; overflow: hidden; background-color: ${player.mapID == 0 ? "rgb(255, 255, 255, .6)" : "rgb(0, 0, 0, .6)"};">
        <div style="position: absolute; height: 100%; left: 0px; top: 0px; width: ${(beaconPoints.ally / 3500) * 100}%; background-color: #00e3e3;">
        </div>
        </div>
        <div style="display: ${BEACONS.length ? player.gameMode == 0 ? "none" : "block" : "none"}; position: absolute; height: 25px; left: ${(window.innerWidth / 2) + ((maxwidth * .5) + 10)}px; top: 25px; width: 125px; border-radius: 2px; overflow: hidden; background-color: ${player.mapID == 0 ? "rgb(255, 255, 255, .6)" : "rgb(0, 0, 0, .6)"};">
        <div style="position: absolute; height: 100%; right: 0px; top: 0px; width: ${(beaconPoints.enemy / 3500) * 100}%; background-color: #f00;">
        </div>
        </div>
        `;
        for (let i = 0; i < BEACONS.length; i++) {
            let obj = BEACONS[i];
            let backgroundcolor = "#fff";
            let multi = 1;
            let textColor = "#000";
            if (obj.ENEMYPOINTS > obj.ALLYPOINTS) {
                backgroundcolor = "#f00";
                multi = obj.ENEMYPOINTS / 5e3;
            } else {
                backgroundcolor = "#00e3e3";
                multi = obj.ALLYPOINTS / 5e3;
            }
            document.getElementById("gameDataThing").innerHTML += `
            <div style="position: absolute; top: 25px; left: ${window.innerWidth / 2 - (maxwidth / 2)}">
            <div style="position: absolute; top: 0px; left: ${(30 * beaconIndexx)}px; border-radius: 100%; width: 25px; height: 25px; background-color: #fff; overflow: hidden;">
            <div style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; border-radius: 100%; background: conic-gradient(${backgroundcolor} ${360 * (multi)}deg, #fff 0deg);">
            </div>
            <div style="position: absolute; height: 100%; width: 100%; display: flex; align-items: center; top: 0px; left: 0px; color: ${textColor};">
            <div style="width: 100%; text-align: center; font-size: 18px;">${LETTERS[beaconIndexx]}</div>
            </div>
            </div>
            </div>
            `;
            beaconIndexx++;
        }
        if (beaconPoints.enemy >= 3500) {
            beaconPoints.enemy = 0;
            beaconPoints.ally = 0;
            document.getElementById("useAbility").style.display = "none";
            document.getElementById("useAbility2").style.display = "none";
            document.getElementById("useActiveModule").style.display = "none";
            document.getElementById("weaponThing").style.display = "none";
            document.getElementById("healthBar").style.display = "none";
            document.getElementById("mothershipBar").style.display = "none";
            document.getElementById("titanChargeBar").style.display = "none";
            document.getElementById("chooseSlot").style.bottom = "-200px";
            endGame([...players], false);
        } else if (beaconPoints.ally >= 3500) {
            beaconPoints.enemy = 0;
            beaconPoints.ally = 0;
            document.getElementById("useAbility").style.display = "none";
            document.getElementById("useAbility2").style.display = "none";
            document.getElementById("useActiveModule").style.display = "none";
            document.getElementById("weaponThing").style.display = "none";
            document.getElementById("healthBar").style.display = "none";
            document.getElementById("mothershipBar").style.display = "none";
            document.getElementById("titanChargeBar").style.display = "none";
            document.getElementById("chooseSlot").style.bottom = "-200px";
            endGame([...players], true);
        }
    }
    function levelToMKColor(level) {
        if (level >= 18) {
            return "000";
        } else if (level == 17) {
            return "ffa500";
        } else if (level == 16) {
            return "800080";
        } else if (level == 15) {
            return "f00";
        } else if (level == 14) {
            return "ffff00";
        } else if (level == 13) {
            return "0f0";
        }
        return "#f00";
    }
    function levelToMKText(level) {
        return "MK" + ((level - 12) + 1);
    }
    var fpsInfo = {
        count: 0,
        real: 0,
        last: Date.now()
    }
    function renderDomains(delta) {
        for (let i = 0; i < domains.length; i++) {
            let domain = domains[i];
            if (domain) {
                if (domain.oldLast == null) domain.oldLast = domain.lastingTime;
                if (domain.tmpScale == null) domain.tmpScale = 0;
                domain.tmpScale = Math.min(domain.tmpScale + (3.2 * delta), domain.scale);
                ctx.save();
                ctx.translate(domain.x - offset.x, domain.y - offset.y);
                let color1 = null;
                let color2 = null;
                if (domain.name == "Roulette Strike" || domain.name == "mutefield") {
                    color1 = "rgb(128, 0, 128, .4)";
                    color2 = "rgb(128, 0, 128)";
                } else if (domain.name == "Dismantle") {
                    color1 = "rgb(255, 0, 0, .2)";
                    color2 = "rgb(255, 0, 0)";
                } else if (domain.name == "dmgfield") {
                    color1 = "rgb(255, 255, 0, .2)";
                    color2 = "rgb(255, 255, 0)";
                } else if (domain.name == "healfield") {
                    color1 = "rgb(0, 255, 0, .2)";
                    color2 = "rgb(0, 255, 0)";
                } else if (domain.name == "Nuclear Strike") {
                    color1 = "rgb(0, 145, 0, .6)";
                    color2 = "rgb(0, 145, 0)";
                }
                renderCircle(0, 0, domain.tmpScale, ctx, false, false, color1 || "rgb(0, 0, 255, .4)", domain.isAlly == true ? "rgb(0, 0, 128)" : "rgb(255, 0, 0)", 16);
                let multi = (domain.lastingTime / domain.oldLast);
                ctx.strokeStyle = color2 || "#0000ff";
                ctx.lineWidth = 16;
                ctx.beginPath();
                ctx.arc(0, 0, domain.tmpScale, 0, (Math.PI * 2) * multi);
                ctx.stroke();
                ctx.restore();
            }
        }
    }
    function updateDomains(delta) {
        for (let i = 0; i < domains.length; i++) {
            let domain = domains[i];
            if (domain) {
                domain.lastingTime -= delta;
                if (domain.name == "dmgfield" || domain.name == "healfield" || domain.name == "mutefield") {
                } else if (domain.name == "Roulette Strike") {
                    if (domain.effectThingy == null) domain.effectThingy = 0;
                    domain.effectThingy -= delta;
                    let cando = false;
                    if (domain.effectThingy <= 0) {
                        cando = true;
                        domain.effectThingy = 100;
                    }
                    for (let t = 0; t < players.length; t++) {
                        let robot = players[t].robots[players[t].robotIndex];
                        if (robot && players[t].isAlly != domain.isAlly && cando) {
                            if (Math.hypot(domain.y - robot.y, domain.x - robot.x) <= domain.scale + (robot.scale + 90)) {
                                if (Math.hypot(domain.y - robot.y, domain.x - robot.x) <= domain.scale + robot.scale) {
                                    changeHealth(robot, {
                                        amount: -(domain.dmg * 5),
                                        graydmg: 0
                                    }, false, domain.owner);
                                }
                                robot.effects.push({
                                    name: "rust",
                                    power: .1,
                                    lastTime: 15e3
                                });
                                robot.effects.push({
                                    name: "dot",
                                    owner: domain.owner,
                                    dmg: domain.dmg,
                                    lastTime: 15e3
                                });
                                robot.effects.push({
                                    name: "slowdown",
                                    power: .075,
                                    lastTime: 251
                                });
                            }
                        }
                    }
                    for (let t = 0; t < enemies.length; t++) {
                        let enemy = enemies[t];
                        if (cando && Math.hypot(domain.y - enemy.y, domain.x - enemy.x) <= domain.scale + (enemy.scale + 90)) {
                            if (Math.hypot(domain.y - enemy.y, domain.x - enemy.x) <= domain.scale + enemy.scale) {
                                changeHealth(enemy, {
                                    amount: -(domain.dmg * 5),
                                    graydmg: 0
                                }, false, domain.owner);
                            }
                            enemy.effects.push({
                                name: "rust",
                                power: .1,
                                lastTime: 15e3
                            });
                            enemy.effects.push({
                                name: "dot",
                                owner: domain.owner,
                                dmg: domain.dmg,
                                lastTime: 15e3
                            });
                            enemy.effects.push({
                                name: "slowdown",
                                power: .17,
                                lastTime: 251
                            });
                        }
                    }
                } else if (domain.name == "Nuclear Strike") {
                    let enemies = getNearest(domain, domain.scale, domain.isAlly);
                    let dmg = domain.owner.abilities.find(e => e.name == domain.name).dmg;
                    enemies.forEach(enemy => {
                        if (enemy.lastHitByNuclearStrikeDomain == null) enemy.lastHitByNuclearStrikeDomain = 0;
                        if (Date.now() - enemy.lastHitByNuclearStrikeDomain >= 200) {
                            enemy.lastHitByNuclearStrikeDomain = Date.now();
                            changeHealth(enemy, {
                                amount: -dmg
                            }, false, domain.owner);
                            enemy.effects.push({
                                name: "frag",
                                neg: true,
                                power: 0.0025,
                                lastForever: true,
                                lastTime: 1
                            });
                            enemy.effects.push({
                                name: "dot",
                                neg: true,
                                owner: domain.owner,
                                dmg: dmg / 16,
                                lastTime: 16e3
                            });
                        }
                    });
                } else if (domain.name == "Dismantle") {
                    let enemies = getNearest(domain, domain.scale, domain.isAlly);
                    let dmgmmg = domain.owner.abilities.find(e => e.name == domain.name).dmg;
                    for (let i = 0; i < enemies.length; i++) {
                        let enemy = enemies[i];
                        if (enemy) {
                            if (enemy.lastHitByDismantle == null) enemy.lastHitByDismantle = 0;
                            if (Date.now() - enemy.lastHitByDismantle >= 125) {
                                enemy.lastHitByDismantle = Date.now();
                                changeHealth(enemies[i], {
                                    amount: -dmgmmg,
                                    graydmg: 0,
                                    defensePointsBypass: .5,
                                    onDamageHealBack: 1
                                }, false, domain.owner);
                            }
                        }
                    }
                    domains.forEach(e => {
                        if (e.isAlly != domain.isAlly && dist(e, domain) <= e.scale + domain.scale && e.name != "Dismantle") {
                            e.lastingTime = 0;
                            changeHealth(domain.owner, {
                                amount: domain.owner.maxhealth * .1
                            }, false, domain.owner);
                        }
                    });
                    buildings.forEach(e => {
                        if (e.isAlly != domain.isAlly && e.dmg && e.duration && dist(e, domain) <= e.scale + domain.scale) {
                            e.duration = 0;
                            changeHealth(domain.owner, {
                                amount: domain.owner.maxhealth * .1
                            }, false, domain.owner);
                        }
                    });
                    for (let t = 0; t < projectiles.length; t++) {
                        let bullet = projectiles[t];
                        if (bullet.dmg > 0 && bullet.isAlly != domain.isAlly && Math.hypot(domain.y - bullet.oldY, domain.x - bullet.oldX) > domain.scale && Math.hypot(domain.y - bullet.y, domain.x - bullet.x) <= domain.scale) {
                            bullet.dmg = 0;
                            bullet.speed *= .1;
                            bullet.color = "rgb(255, 0, 0)";
                        }
                    }
                    if (domain.owner.dead) {
                        domain.lastingTime = 0;
                    }
                } else {
                    for (let t = 0; t < players.length; t++) {
                        let robot = players[t].robots[players[t].robotIndex];
                        if (robot) {
                            if (Math.hypot(domain.y - robot.y, domain.x - robot.x) <= domain.scale) {
                                if (domain.name == "Infinite Void" && robot.name == domain.ownerName && robot.effects) {
                                    if (!robot.effects.find(e => e.name == "speed" && e.domainEffect == domain.name)) {
                                        if (domain.doneToEnemies == null) domain.doneToEnemies = [];
                                        domain.doneToEnemies.push(robot.inGameSid);
                                        robot.effects.unshift({
                                            name: "speed",
                                            domainEffect: domain.name,
                                            power: 2.5,
                                            lastForever: true,
                                            lastTime: 1
                                        });
                                    }
                                    if (!robot.effects.find(e => e.name == "defense points" && e.domainEffect == domain.name)) {
                                        robot.effects.push({
                                            name: "defense points",
                                            domainEffect: domain.name,
                                            amount: 100,
                                            lastForever: true,
                                            lastTime: 1
                                        });
                                    }
                                }
                                if (domain.name == "Infinite Void" && players[t].isAlly != domain.isAlly) {
                                    robot.freeze = true;
                                }
                            } else {
                                if (domain.doneToEnemies && domain.doneToEnemies.includes(robot.inGameSid)) {
                                    let done = false, done1 = false;
                                    robot.effects.find(e => {
                                        if (!done && e.name == "speed" && e.domainEffect == domain.name) {
                                            done = true;
                                            e.lastForever = false;
                                        }
                                        if (!done1 && e.name == "defense points" && e.domainEffect == domain.name) {
                                            done1 = true;
                                            e.lastForever = false;
                                        }
                                    });
                                    let idnex = domain.doneToEnemies.find(e => e == robot.inGameSid);
                                    domain.doneToEnemies.splice(idnex, 1);
                                }
                            }
                        }
                    }
                    for (let t = 0; t < enemies.length; t++) {
                        let enemy = enemies[t];
                        if (domain.name == "Infinite Void" && Math.hypot(domain.y - enemy.y, domain.x - enemy.x) <= domain.scale) {
                            enemy.freeze = true;
                        }
                    }
                    for (let t = 0; t < projectiles.length; t++) {
                        let bullet = projectiles[t];
                        if (domain.name == "Infinite Void" && bullet.isAlly != domain.isAlly && Math.hypot(domain.y - bullet.y, domain.x - bullet.x) <= domain.scale) {
                            bullet.dmg = 0;
                            bullet.freeze = true;
                        }
                    }
                }
                if (domain.lastingTime <= 0) {
                    if (domain.name == "Infinite Void") {
                        for (let t = 0; t < players.length; t++) {
                            let robot = players[t].robots[players[t].robotIndex];
                            if (robot) {
                                if (domain.doneToEnemies && domain.doneToEnemies.includes(robot.inGameSid)) {
                                    let done = false, done1 = false;
                                    robot.effects.find(e => {
                                        if (!done && e.name == "speed" && e.domainEffect == domain.name) {
                                            done = true;
                                            e.lastForever = false;
                                        }
                                        if (!done1 && e.name == "defense points" && e.domainEffect == domain.name) {
                                            done1 = true;
                                            e.lastForever = false;
                                        }
                                    });
                                }
                            }
                        }
                        domain.owner.effects.push({
                            name: "defense points",
                            amount: 1000,
                            lastTime: 2e3
                        });
                    } else if (domain.name == "Dismantle") {
                        let enemies = getNearest(domain, domain.scale, domain.isAlly);
                        domain.owner.effects.push({
                            name: "defense points",
                            amount: (250 * enemies.length) + 250,
                            lastTime: 10e3
                        });
                    } else if (domain.name == "dmgfield") {
                        let enemies = getNearest(domain, domain.scale, domain.isAlly);
                        enemies.forEach(e => {
                            changeHealth(e, {
                                amount: -domain.dmg,
                                graydmg: 0
                            }, false, domain.owner);
                        });
                    } else if (domain.name == "healfield") {
                        let allies = getNearest(domain, domain.scale, domain.isAlly, true);
                        allies.forEach(e => {
                            if (domain.repair && typeof domain.repair == "object") {
                                e.effects.push({
                                    name: "healing",
                                    type: "percent",
                                    power: domain.repair.power,
                                    rate: domain.repair.rate,
                                    lastTime: domain.repair.duration
                                });
                            } else if (domain.repair) {
                                changeHealth(e, {
                                    amount: domain.repair
                                }, false, domain.owner);
                            }
                            if (domain.yellowShield && e.shields) {
                                e.shields.push({
                                    type: "yellow",
                                    health: domain.yellowShield,
                                    maxhealth: domain.yellowShield,
                                    regen: 0
                                });
                            }
                        });
                    } else if (domain.name == "mutefield") {
                        let enemies = getNearest(domain, domain.scale, domain.isAlly);
                        enemies.forEach(e => {
                            if (e.effects) {
                                e.effects.push({
                                    name: "blind",
                                    neg: true,
                                    lastTime: domain.duration
                                });
                                e.effects.push({
                                    name: "emp",
                                    neg: true,
                                    lastTime: domain.duration
                                });
                            }
                        });
                    }
                    domains.splice(i, 1);
                }
            }
        }
    }
    function getWeaponOffsets(weapon, shape) {
        let hardpoints = shape.hardpoints.light + shape.hardpoints.heavy;
        let x = 0;
        let y = 0;
        let scale = 0;
        scale = 15;
        if (weapon.name == "Toxin" || weapon.name == "Bane") {
            scale = 30;
        } else if (weapon.name == "Devastator" || weapon.name == "Scatter" || weapon.name == "Evora" || weapon.name == "Veyron" || weapon.name == "Disintegrator" || weapon.name == "Havoc") {
            scale = 25;
        }
        let hScale = scale / 2;
        if (shape.target && !shape.isMe) {
            shape.dir = Math.atan2(shape.target.y - shape.y, shape.target.x - shape.x);
        }
        if (hardpoints == 1 || weapon.name == "Skyward") {
            x = shape.x + Math.cos(shape.dir) * (shape.scale - hScale);
            y = shape.y + Math.sin(shape.dir) * (shape.scale - hScale);
        } else if (hardpoints == 2) {
            if (weapon.slot == 0) {
                x = shape.x + Math.cos(shape.dir + 1.57) * (shape.scale - hScale);
                y = shape.y + Math.sin(shape.dir + 1.57) * (shape.scale - hScale);
            } else {
                x = shape.x + Math.cos(shape.dir - 1.57) * (shape.scale - hScale);
                y = shape.y + Math.sin(shape.dir - 1.57) * (shape.scale - hScale);
            }
        } else if (hardpoints == 3) {
            if (weapon.slot == 0) {
                x = shape.x + Math.cos(shape.dir + 1.57) * (shape.scale - hScale);
                y = shape.y + Math.sin(shape.dir + 1.57) * (shape.scale - hScale);
            } else if (weapon.slot == 1) {
                x = shape.x + Math.cos(shape.dir) * (shape.scale - hScale);
                y = shape.y + Math.sin(shape.dir) * (shape.scale - hScale);
            } else {
                x = shape.x + Math.cos(shape.dir - 1.57) * (shape.scale - hScale);
                y = shape.y + Math.sin(shape.dir - 1.57) * (shape.scale - hScale);
            }
        } else {
            if (weapon.slot == 0 || weapon.slot == 4) {
                x = shape.x + Math.cos(shape.dir + 1.57) * (shape.scale - 7.5);
                y = shape.y + Math.sin(shape.dir + 1.57) * (shape.scale - 7.5);
            } else if (weapon.slot == 1 || weapon.slot == 5) {
                x = shape.x + Math.cos(shape.dir + 0.39) * (shape.scale - 7.5);
                y = shape.y + Math.sin(shape.dir + 0.39) * (shape.scale - 7.5);
            } else if (weapon.slot == 2 || weapon.slot == 6) {
                x = shape.x + Math.cos(shape.dir - 0.39) * (shape.scale - 7.5);
                y = shape.y + Math.sin(shape.dir - 0.39) * (shape.scale - 7.5);
            } else {
                x = shape.x + Math.cos(shape.dir - 1.57) * (shape.scale - 7.5);
                y = shape.y + Math.sin(shape.dir - 1.57) * (shape.scale - 7.5);
            }
        }
        return weapon.name == "Comet Laser" ? { x: shape.x, y: shape.y } : { x, y };
    }
    function renderLasers() {
        ctx.save();
        ctx.globalCompositeOperation = "source-over";
        for (let i = 0; i < players.length; i++) {
            let player = players[i].robots[players[i].robotIndex];
            if (player && !player.isFREEZE && (player.isMe ? keysPressed[32] : player.fireWeapon)) {
                player.weapons.forEach(weapon => {
                    if (!weapon.disabled && !weapon.notActive && ((weapon.chargingMechanic ? Date.now() - weapon.lastFire < 100 : false) || weapon.continueToFire || weapon.canFire || (weapon.continuousReload && weapon.ammo > 0))) {
                        let Offset = getWeaponOffsets(weapon, player);
                        if (["Striker", "Eagle", "Hawk"].includes(weapon.name)) {
                            let nearestEnemies = [];
                            if (hasPlayers()) {
                                for (let t = 0; t < players.length; t++) {
                                    let Robot = players[t].robots[players[t].robotIndex];
                                    if (Robot && players[i].isAlly != players[t].isAlly) {
                                        if (!Robot.invis && Math.hypot(player.y - Robot.y, player.x - Robot.x) <= weapon.range + player.scale) {
                                            nearestEnemies.push(Robot);
                                        }
                                    }
                                }
                            } else {
                                nearestEnemies = enemies.filter(e => Math.hypot(e.y - player.y, e.x - player.x) <= weapon.range + e.scale)
                            }
                            if (nearestEnemies.length) {
                                nearestEnemies = nearestEnemies.sort((a, b) => dist(a, (weapon.target || player)) - dist(b, (weapon.target || player)));
                                ctx.save();
                                ctx.shadowBlur = 15;
                                ctx.shadowColor = "#fff";
                                ctx.lineWidth = 16;
                                ctx.strokeStyle = weapon.name == "Striker" ? "#ffff00" : players[i].isAlly ? "#fff" : "rgb(255, 0, 0)";
                                ctx.beginPath();
                                for (let ttt = 0; ttt < 3; ttt++) {
                                    let enemy = nearestEnemies[ttt];
                                    let enemy2 = nearestEnemies[ttt - 1];
                                    if (enemy) {
                                        if (ttt == 0) {
                                            ctx.moveTo(Offset.x - offset.x, Offset.y - offset.y);
                                            ctx.lineTo(enemy.x - offset.x, enemy.y - offset.y);
                                        } else {
                                            ctx.lineTo(enemy2.x - offset.x, enemy2.y - offset.y);
                                            ctx.lineTo(enemy.x - offset.x, enemy.y - offset.y);
                                        }
                                    }
                                }
                                ctx.stroke();
                                ctx.restore();
                            }
                        } else if (["Comet Laser", "Skyward", "Leiming", "Fengbao", "Pantagruel", "Gangantua"].includes(weapon.name)) {
                            let Enemies = [];
                            let direction = player.dir;
                            let angle = weapon.name == "Comet Laser" ? Math.PI : ["Leiming", "Fengbao"].includes(weapon.name) ? (Math.PI / 2) : 0.72;
                            if (hasPlayers()) {
                                for (let t = 0; t < players.length; t++) {
                                    let ROBOTBOTBT = players[t].robots[players[t].robotIndex];
                                    if (ROBOTBOTBT && players[t].isAlly != players[i].isAlly) {
                                        let dir = Math.atan2(ROBOTBOTBT.y - player.y, ROBOTBOTBT.x - player.x);
                                        if ((["Leiming", "Fengbao"].includes(weapon.name) ? true : !ROBOTBOTBT.invis) && Math.getAngleDist(direction, dir) <= angle && dist(player, ROBOTBOTBT) <= weapon.range + ROBOTBOTBT.scale) {
                                            Enemies.push(ROBOTBOTBT);
                                        }
                                    }
                                }
                            } else {
                                for (let t = 0; t < enemies.length; t++) {
                                    let ROBOTBOTBT = enemies[t];
                                    if (ROBOTBOTBT) {
                                        let dir = Math.atan2(ROBOTBOTBT.y - player.y, ROBOTBOTBT.x - player.x);
                                        if (Math.getAngleDist(direction, dir) <= angle && dist(ROBOTBOTBT, player) <= weapon.range + ROBOTBOTBT.scale) {
                                            Enemies.push(ROBOTBOTBT);
                                        }
                                    }
                                }
                            }
                            Enemies.forEach(item => {
                                let tmp = {
                                    x: item.x,
                                    y: item.y
                                }
                                if (item.shields) {
                                    for (let i = 0; i < item.shields.length; i++) {
                                        let shield = item.shields[i];
                                        if (shield && !shield.notActive && (shield.health > 0 || shield.type == "purple")) {
                                            let dir = Math.atan2(item.y - player.y, item.x - player.x);
                                            tmp = {
                                                x: player.x + Math.cos(dir) * (dist(item, player) - (item.scale + 20)),
                                                y: player.y + Math.sin(dir) * (dist(item, player) - (item.scale + 20)),
                                            };
                                            break;
                                        }
                                    }
                                }
                                let color2 = players[i].isAlly == true ? "rgb(255, 255, 255)" : "rgb(0, 0, 0)";
                                let color1 = players[i].isAlly == true ? "rgb(0, 150, 0, .6)" : "rgb(255, 165, 0, .6)";
                                ctx.save();
                                ctx.lineWidth = ["Leiming", "Fengbao"].includes(weapon.name) ? 8 : weapon.name == "Skyward" ? weapon.target == item ? 32 : 20 : 16;
                                ctx.strokeStyle = ["Skyward", "Leiming", "Fengbao"].includes(weapon.name) ? color2 : color1;
                                if (weapon.name == "Skyward") ctx.lineCap = "round";
                                ctx.beginPath();
                                ctx.moveTo(Offset.x - offset.x, Offset.y - offset.y);
                                ctx.lineTo(tmp.x - offset.x, tmp.y - offset.y);
                                ctx.stroke();
                                ctx.restore();
                            });
                        } else if (["Calamity", "Spark"].includes(weapon.name)) {
                            let globalAlpha = 0;
                            if (weapon.target) {
                                let scale = 350 + weapon.target.scale;
                                if (dist(weapon.target, player) <= scale) {
                                    globalAlpha = 1;
                                } else {
                                    let distance = dist(weapon.target, player) - scale;
                                    let range = weapon.range - scale;
                                    globalAlpha = 1 - (distance / range);
                                }
                            }
                            globalAlpha = Math.max(globalAlpha, 0.05);
                            let color1 = players[i].isAlly == true ? `rgb(255, 255, 255, ${globalAlpha})` : `rgb(0, 0, 0, ${globalAlpha})`;
                            ctx.save();
                            ctx.lineWidth = 16;
                            ctx.strokeStyle = color1;
                            ctx.beginPath();
                            ctx.lineCap = "round";
                            ctx.moveTo(Offset.x - offset.x, Offset.y - offset.y);
                            ctx.lineTo(player.cursorLocation.x - offset.x, player.cursorLocation.y - offset.y);
                            ctx.stroke();
                            ctx.restore();
                        } else if (["Athos", "Aramis", "Fulgur", "Tonans"].includes(weapon.name) && (player.target || weapon.target)) {
                            let target = player.target || weapon.target;
                            if (!target.invis) {
                                ctx.save();
                                let tmp = {
                                    x: target.x,
                                    y: target.y
                                }
                                if (target.shields) {
                                    for (let i = 0; i < target.shields.length; i++) {
                                        let shield = target.shields[i];
                                        if (shield && !shield.notActive && (shield.health > 0 || shield.type == "purple")) {
                                            let dir = Math.atan2(target.y - player.y, target.x - player.x);
                                            tmp = {
                                                x: player.x + Math.cos(dir) * (dist(target, player) - (target.scale + 20)),
                                                y: player.y + Math.sin(dir) * (dist(target, player) - (target.scale + 20)),
                                            };
                                            break;
                                        }
                                    }
                                }
                                if (["Athos", "Aramis"].includes(weapon.name)) {
                                    let color1 = players[i].isAlly == true ? "rgb(0, 150, 0, .6)" : "rgb(255, 165, 0, .6)";
                                    ctx.save();
                                    ctx.lineWidth = 16;
                                    ctx.strokeStyle = color1;
                                    ctx.beginPath();
                                    ctx.moveTo(Offset.x - offset.x, Offset.y - offset.y);
                                    ctx.lineTo(tmp.x - offset.x, tmp.y - offset.y);
                                    ctx.stroke();
                                    ctx.restore();
                                } else {
                                    ctx.shadowBlur = 30;
                                    ctx.shadowColor = "#fff";
                                    ctx.lineWidth = 16;
                                    ctx.strokeStyle = players[i].isAlly ? "#fff" : "#f00";
                                    ctx.lineCap = "round";
                                    ctx.beginPath();
                                    ctx.moveTo(Offset.x - offset.x, Offset.y - offset.y);
                                    ctx.lineTo(tmp.x - offset.x, tmp.y - offset.y);
                                    ctx.stroke();
                                    ctx.restore();
                                }
                            }
                        }
                    }
                });
            }
        }
        ctx.restore();
    }
    function lerp(a, b, t) {
        return (1 - t) * a + t * b;
    }
    var oldMaxScreen = {
        x: 0,
        y: 0
    };
    function updateEffectDisplayOnEnemies(isBlind) {
        document.getElementById("effectsForEnemies").innerHTML = "";
        if (isBlind) {
            document.getElementById("effectsForEnemies").style.display = "none";
            return;
        }
        let playerRobot = players[0]?.robots[players[0]?.robotIndex];
        if (playerRobot) {
            let enemies = getNearest(playerRobot, 4e3, true);
            if (enemies.length) {
                enemies = enemies.filter(e => !e.invis);
                let enemy = enemies.sort((a, b) => dist(playerRobot.cursorLocation, a) - dist(playerRobot.cursorLocation, b))[0];
                if (enemy) {
                    document.getElementById("effectsForEnemies").style.display = "block";
                    document.getElementById("effectsForEnemies").innerHTML = `
                    <div style="color: #f00;">
                    ${enemy.playersIndexSid ? players[enemy.playersIndexSid].name : (enemy.dummy ? "Test Dummy" : (enemy.name || "unknown shape"))}
                    </div>
                    <div id="effectsForGood" style="text-align: right;"></div>
                    <div id="effectsForBad" style="text-align: right;"></div>
                    `;
                    let thinng = {};
                    if (enemy.effects) {
                        enemy.effects.forEach(effect => {
                            if (effect.name == "cooldown") {
                                thinng[effect.name + " " + i] = {
                                    neg: effect.neg
                                };
                            } else {
                                let indexName = effect.name + " " + effect.lastForever + " " + effect.isActiveModuleEffect;
                                if (!thinng[indexName]) {
                                    thinng[indexName] = {
                                        neg: effect.neg
                                    };
                                }
                            }
                        });
                    }
                    let index1 = 0;
                    let index2 = 0;
                    for (let i in thinng) {
                        if (i == "dot") {
                            thinng[i].neg = true;
                        }
                        let info = thinng[i];
                        if (info.neg) {
                            if (index2 < 10) {
                                document.getElementById("effectsForBad").innerHTML += `
                                <div style="display: inline-block; width: 30px; height: 30px; background-size: 30px 30px; ${typeof getEffectIcon(i) == "object" ? "" : `background-image: url('${getEffectIcon(i)}');`}">
                                ${typeof getEffectIcon(i) == "object" ? `
                                <span class="material-symbols-outlined" style="color: #fff; font-size: 30px; padding-right: 5px;">
                                ${getEffectIcon(i).name}
                                </span>
                                ` : ""}
                                </div>
                                `;
                                index2++;
                            }
                        } else {
                            if (index1 < 10) {
                                document.getElementById("effectsForGood").innerHTML += `
                                <div style="display: inline-block; width: 30px; height: 30px; background-size: 30px 30px; ${typeof getEffectIcon(i) == "object" ? "" : `background-image: url('${getEffectIcon(i)}');`}">
                                ${typeof getEffectIcon(i) == "object" ? `
                                <span class="material-symbols-outlined" style="color: #fff; font-size: 30px; padding-right: 5px;">
                                ${getEffectIcon(i).name}
                                </span>
                                ` : ""}
                                </div>
                                `;
                                index1++;
                            }
                        }
                    }
                } else {
                    document.getElementById("effectsForEnemies").style.display = "none";
                }
            }
        }
    }
    var camera = {
        x: 0,
        y: 0
    };
    function updateGame() {
        try {
            //Date.now() - lastUpdate;
            let delta = 1e3 / 60;
            lastUpdate = Date.now();
            fpsInfo.count++;
            if (Date.now() - fpsInfo.last >= 1e3) {
                fpsInfo.last = Date.now();
                fpsInfo.real = fpsInfo.count;
                fpsInfo.count = 0;
            }
            let isBlind = false;
            if (player.gameMode >= 0 && players[0]) {
                let cameraPlayer = undefined;
                if (players[0].robotIndex == -1) {
                    document.getElementById("LMAOLMAOLMAOLMAO").innerHTML = "";
                    if (players[0].oldIndex >= 0) {
                        cameraPlayer = players[0].robots[players[0].oldIndex];
                    } else {
                        cameraPlayer = {
                            x: mapInfo.x / 2,
                            y: mapInfo.x / 2
                        };
                    }
                } else {
                    let playerRobot = players[0].robots[players[0].robotIndex];
                    cameraPlayer = playerRobot;
                    isBlind = playerRobot.blind;
                    if (playerRobot) {
                        if (typeof playerRobot.flightVisualData == "object") {
                            let newMaxScreen = {
                                x: playerRobot.flightVisualData.fov.x,
                                y: playerRobot.flightVisualData.fov.y
                            };
                            if (transitionProgress < 1) {
                                maxScreen.x = lerp(maxScreen.x, newMaxScreen.x, transitionProgress);
                                maxScreen.y = lerp(maxScreen.y, newMaxScreen.y, transitionProgress);
                                transitionProgress += delta / (playerRobot.flightAnimationSpeed || 1e3);
                                transitionProgress = Math.min(transitionProgress, 1);
                            } else {
                                maxScreen.x = newMaxScreen.x;
                                maxScreen.y = newMaxScreen.y;
                            }
                            if (oldMaxScreen.x != maxScreen.x || oldMaxScreen.y != maxScreen.y) {
                                oldMaxScreen.x = maxScreen.x;
                                oldMaxScreen.y = maxScreen.y;
                                resize();
                            }
                        } else {
                            let newMaxScreen = {
                                x: 1980 * playerRobot.fieldOfViewMulti,
                                y: 1080 * playerRobot.fieldOfViewMulti
                            };
                            if (transitionProgress < 1) {
                                maxScreen.x = lerp(maxScreen.x, newMaxScreen.x, transitionProgress);
                                maxScreen.y = lerp(maxScreen.y, newMaxScreen.y, transitionProgress);
                                transitionProgress += delta / (playerRobot.flightAnimationSpeed || 1e3);
                                transitionProgress = Math.min(transitionProgress, 1);
                            } else {
                                maxScreen.x = newMaxScreen.x;
                                maxScreen.y = newMaxScreen.y;
                            }
                            if (oldMaxScreen.x != maxScreen.x || oldMaxScreen.y != maxScreen.y) {
                                oldMaxScreen.x = maxScreen.x;
                                oldMaxScreen.y = maxScreen.y;
                                resize();
                            }
                        }
                    }
                }
                if (cameraPlayer) {
                    let distance = dist(cameraPlayer, camera);
                    let cameraAngle = Math.atan2(cameraPlayer.y - camera.y, cameraPlayer.x - camera.x);
                    let cameraSpd = 0.018;
                    if (distance >= 3e3) {
                        cameraSpd = 0.001;
                    } else if (distance >= 2500) {
                        cameraSpd = 0.002;
                    } else if (distance >= 2e3) {
                        cameraSpd = 0.004;
                    } else if (distance >= 1500) {
                        cameraSpd = 0.01;
                    } else if (distance >= 1e3) {
                        cameraSpd = 0.011;
                    } else if (distance >= 700) {
                        cameraSpd = 0.012;
                    } else if (distance >= 400) {
                        cameraSpd = 0.014;
                    }
                    let camSpd = Math.min(distance * cameraSpd * delta, distance);
                    camera.x += Math.cos(cameraAngle) * camSpd;
                    camera.y += Math.sin(cameraAngle) * camSpd;
                }
                offset = {
                    x: camera.x - (maxScreen.x / 2),
                    y: camera.y - (maxScreen.y / 2)
                };
                renderBackground(delta);
                renderBuildings(delta);
                if (!isBlind) renderBullets(ctx);
                renderPlayer(delta);
                if (!isBlind) renderPlayers(delta);
                if (!isBlind) renderEnemies(ctx);
                ctx.globalAlpha = 1;
                for (let i = 0; i < bombeffect.length; i++) {
                    let effect = bombeffect[i];
                    if (effect) {
                        effect.scale += (effect.speed ? effect.speed : effect.blastttt ? 4 : effect.color ? effect.color == "stamp" ? 1.5 : 3.84 : (effect.doFaster || effect.maxScale == 500) ? 1.2 : 0.32) * delta * (effect.indexM || 1);
                        if (effect.scale <= 0) effect.scale = 0;
                        let color = effect.Color ? effect.Color : effect.color ? effect.color == "blue" ? "rgb(0, 0, 255, 0.3)" : effect.color == "stamp" ? "rgb(0, 0, 255, 0)" : "rgb(255, 255, 255, 0.3)" : "rgb(255, 0, 0, 0.3)";
                        let color2 = effect.Color2 ? effect.Color2 : effect.color ? effect.color == "stamp" || effect.color == "blue" ? "rgb(0, 0, 255, 0.6)" : "rgb(255, 255, 255, 0.6)" : "rgb(255, 0, 0, 0.6)";
                        ctx.save();
                        ctx.translate((effect.location ? effect.location.x : effect.x) - offset.x, (effect.location ? effect.location.y : effect.y) - offset.y);
                        renderCircle(0, 0, effect.scale, ctx, false, false, color, color2, effect.color == "stamp" ? 12 : undefined);
                        ctx.restore();
                        if ((effect.indexM && effect.scale <= 0) || (effect.scale >= effect.maxScale)) {
                            bombeffect.splice(i, 1);
                        }
                    }
                }
                updatePlayer(delta);
                if (hasPlayers()) updatePlayers(delta, isBlind);
                ctx.globalAlpha = 1;
                if (!isBlind) renderLasers(delta);
                updateBullets(delta);
                for (let i = 0; i < text.length; i++) {
                    let Text = text[i];
                    if (Text) {
                        Text.life -= delta;
                        Text.x += Math.cos(Text.dir) * 2;
                        Text.y += Math.sin(Text.dir) * 2;
                        if (Text.life <= 0) {
                            text.splice(i, 1);
                        }
                    }
                }
                for (let i = 0; i < shieldEffects.length; i++) {
                    let effect = shieldEffects[i];
                    if (effect) {
                        if (isBlind) break;
                        if (effect.last == null) effect.last = Date.now();
                        ctx.save();
                        ctx.translate(effect.location.x - offset.x, effect.location.y - offset.y);
                        ctx.rotate(effect.dir - Math.PI / 8);
                        ctx.lineWidth = 12;
                        ctx.strokeStyle = effect.type == "energy" ? "#0000ff" : effect.type == "purple" ? "#800080" : "#ffff00";
                        ctx.beginPath();
                        ctx.arc(0, 0, effect.scale, 0, Math.PI / 4);
                        ctx.stroke();
                        ctx.restore();
                        if (Date.now() - effect.last >= 100) {
                            shieldEffects.splice(i, 1);
                        }
                    }
                }
                if (player.gameMode == 0 || player.gameMode == 6) {
                    updateEnemies(delta);
                }
                updateDomains(delta);
                ctx.textBaseline = "middle";
                ctx.textAlign = "center";
                for (let i = 0; i < text.length; i++) {
                    let Text = text[i];
                    if (Text && isOnScreen(Text.x - offset.x, Text.y - offset.y, 50)) {
                        ctx.fillStyle = Text.color;
                        ctx.strokeStyle = Text.color == "#ffff00" ? "#f00" : "#ffff00";
                        ctx.font = "50px Open Sans";
                        if (Text.stroke) {
                            ctx.lineWidth = ctx.stroke;
                            ctx.strokeText(abbreviateNumber(removeDecimals(Text.value)), Text.x - offset.x, Text.y - offset.y);
                        }
                        ctx.fillText(abbreviateNumber(removeDecimals(Text.value)), Text.x - offset.x, Text.y - offset.y);
                    }
                }
                renderDomains(delta);
                if (players[0] && players[0].robotIndex >= 0 || player.gameMode == 2) gameTimePlayed += delta;
                renderGameDataThing(delta);
                document.getElementById("timePlayed").style.color = player.mapID == 1 ? "#fff" : "#000";
                document.getElementById("timePlayed").innerHTML = `
                ${settingToggles.showFPS ? `FPS: ${fpsInfo.real}` : ""}
                `;
                ctx.fillStyle = "rgb(0, 0, 0, 0.1)";
                ctx.fillRect(0, 0, maxScreen.x, maxScreen.y);
                document.getElementById("LOGGER").innerHTML = "";
                for (let i = 0; i < KILLLOGS.length; i++) {
                    let log = KILLLOGS[i];
                    if (log) {
                        let nameOne = {
                            color: log.attacker.isAlly == true ? "#00f" : "#f00",
                            name: log.attacker.name
                        };
                        let nameTwo = {
                            color: log.victim.isAlly == true ? "#00f" : "#f00",
                            name: log.victim.name
                        };
                        if (nameOne.name == "Game") {
                            document.getElementById("LOGGER").innerHTML += `
                            <div style="text-align: center; background-color: rgb(0, 0, 0, 0.2); margin-top: 3px; border-radius: 4px; padding-left: 5px; padding-right: 5px;">
                            <span style="color: ${nameTwo.color};">${nameTwo.name}</span>
                            <span style="color: #fff">destroyed</span>
                            </div>
                            `;
                        } else {
                            document.getElementById("LOGGER").innerHTML += `
                            <div style="text-align: center; background-color: rgb(0, 0, 0, 0.2); margin-top: 3px; border-radius: 4px; padding-left: 5px; padding-right: 5px;">
                            <span style="color: ${nameOne.color};">${nameOne.name}</span>
                            <span style="color: #fff;">[${log.weapon.name}${log.weapon.level >= 13 ? ` <span style="color: #${levelToMKColor(log.weapon.level)}">${levelToMKText(log.weapon.level)}</span>` : ""}]</span>
                            <span style="color: ${nameTwo.color};">${nameTwo.name}</span>
                            </div>
                            `;
                        }
                    }
                }
                updateEffectDisplayOnEnemies(isBlind);
            } else {
                document.getElementById("effectsForEnemies").style.display = "none";
                document.getElementById("effectsForEnemies").innerHTML = "";
                document.getElementById("LOGGER").innerHTML = "";
                document.getElementById("abilityCharges").innerHTML = "";
                document.getElementById("shields").innerHTML = "";
                document.getElementById("LMAOLMAOLMAOLMAO").innerHTML = "";
                document.getElementById("gameDataThing").innerHTML = "";
                document.getElementById("timePlayed").innerHTML = "";
                ctx.clearRect(0, 0, maxScreen.x, maxScreen.y);
                ctx.fillStyle = "rgb(0, 0, 0, 0.1)";
                ctx.fillRect(0, 0, maxScreen.x, maxScreen.y);
            }
        } catch (e) {
            console.error(e);
        }
        window.requestAnimationFrame(updateGame);
    }
    window.requestAnimationFrame(updateGame);
}());
